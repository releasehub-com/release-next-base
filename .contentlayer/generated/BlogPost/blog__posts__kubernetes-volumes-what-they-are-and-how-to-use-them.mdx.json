{
  "title": "Kubernetes Volumes: What They Are and How to Use Them",
  "summary": "Learn how to inject file systems into Kubernetes pods using volumes and talk about the different types of their uses.",
  "publishDate": "Tue Sep 13 2022 18:26:07 GMT+0000 (Coordinated Universal Time)",
  "author": "erik-landerholm",
  "readingTime": 5,
  "categories": [
    "kubernetes",
    "platform-engineering"
  ],
  "mainImage": "/blog-images/e2fad2ca4879f4bfe48dc3b52c46df72.jpg",
  "imageAlt": "A table with a cell phone, pencil, glasses and a plant",
  "showCTA": true,
  "ctaCopy": "Discover how Release.com's dynamic environments streamline Kubernetes volume management for persistent data storage.",
  "ctaLink": "https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=kubernetes-volumes-what-they-are-and-how-to-use-them",
  "relatedPosts": [
    ""
  ],
  "ogImage": "/blog-images/e2fad2ca4879f4bfe48dc3b52c46df72.jpg",
  "excerpt": "Learn how to inject file systems into Kubernetes pods using volumes and talk about the different types of their uses.",
  "tags": [
    "kubernetes",
    "platform-engineering"
  ],
  "ctaButton": "Try Release for Free",
  "body": {
    "raw": "\nBy default, the file system available to a Kubernetes pod is limited to the pod's lifetime. As such, when the pod is deleted, all changes are lost.\n\nBut many applications will need to store data persistently, irrespective of whether a pod is running or not. For example, we need to retain data that was updated in the database or files written. Also, we may want to share a file system across multiple containers, and those may be running on different nodes.\n\nLet's take a look at Kubernetes [volumes](https://kubernetes.io/docs/concepts/storage/volumes/), which can address these problems.\n\n### The Basics\n\nMost data storage that applications use is ultimately file system-based, e.g., even though a database may keep some or all of its data in memory while running, it also keeps it updated in the data files on the file system for persistence. \n\nVolumes allow us to inject the application with a reference to a file system, which the application can then read from or write to. \n\nInjecting the file system makes it independent of the container's lifetime. We need to specify an absolute path where the injected file system should be mounted within the container's file system. \n\nVolumes may be persistent or not. There are many different types of volumes, as we shall see. \n\nA volume has to first be defined using the **volumes** key, and then used by a container using the **volumeMounts** key. \n\n#### Example\n\nBelow is a partial YAML snippet to illustrate how we can define and use volumes in a pod. Depending on the type of volume, its definition and usage could be in separate places. \n\n```yaml\napiVersion: v0\nkind: Pod\nmetadata:\n   name: my-pod\nspec:\n   containers:\n   - image: some-image-name\n     name: my-container\n     volumeMounts:\n     - mountPath: /tempfiles\n       name: temp-files-volume\n   volumes:\n   - name: temp-files-volume\n     emptyDir: {}\n```\n\nHere, we've defined a volume of the **emptyDir** type. We'll see more about this later. \n\nSince this type can only be used at the level of a single pod, not across, it's defined along with the pod. There could be multiple containers in a pod (though usually not), and they could all use the same volume. \n\nSo, if one container in a pod writes a new file to the volume, it would be visible to the other containers in that pod that use that volume. The name of the volume can be anything. \n\nThe **volumeMounts** entry under the container specifies where to mount that volume within the container's file system. In this case, we want /tempfiles. \n\nWhen the application in the container writes to /tempfiles, it'll be writing to the temp-files volume. A container may use many different volumes or none. Note that in order to use volumes, the application in the container has to use the path that we specified in mountPath. \n\nSo, if you want to use a container image with volumes, make sure that the path it uses to read/write files matches the path we specified in **volumeMounts.** \n\nA volume could—depending on its type—specify other attributes like accessModes, i.e., what kind of access it allows. \n\nModes can be **ReadWriteOnce**, **ReadOnlyMany**, **ReadWriteMany**, and **ReadWriteOncePod**. Note that specifying an access mode may not constrain the actual usage by the container. See [access modes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes) for details. \n\nNow, let's take a look at different types of volumes. \n\n![A picture containing textDescription automatically generated](/blog-images/bd7448beaaf00cde3327a932d3196820.jpeg)\n\n### Volume Types\n\n#### EmptyDir\n\nKubernetes first creates an emptyDir volume when it assigns the [pod](https://kubernetes.io/docs/concepts/workloads/pods/) using that volume to a [node](https://kubernetes.io/docs/concepts/architecture/nodes/). As the name suggests, it's empty to start with, i.e., it contains no files/directories. \n\nContainers in the same pod can share the volume so that changes made by any container are visible to others. The emptyDir volume persists as long as the pod using it does—a container crash does not delete a pod. \n\nThus, it's an ephemeral or temporary kind of storage for things like cached files/data or intermediate results, etc. Also, we cannot use it to share data across pods. \n\n#### Persistent\n\n[Persistent volumes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/) are defined by an administrator at the Kubernetes cluster level and can be used by multiple nodes in the cluster. They can retain their data even if we delete the pod using them. \n\nApplications in containers can request to use a persistent volume by specifying a persistent volume **claim**. The claim specifies how much storage of what type it requires and using which access mode. \n\nThe cluster can allocate the storage for a claim in two ways: statically if a claim is satisfied by a provisioned volume, and dynamically—for if no volume is available for a claim, the cluster may try to provision the volume dynamically based on the storage class specified. \n\nThe claim with the allocated storage is valid as long as the pod making the claim exists. \n\nThe **reclaim policy** of a volume specifies what to do with a volume once the application no longer needs the volume storage—for example, when we delete a pod using the volume. \n\nAccordingly, we can either retain or delete the data on the volume. Note also that the available access modes will depend on what type of volume is used. Since Kubernetes itself does not provide a file-sharing solution, we need to set that up first. \n\nFor instance, when using NFS, we need to set up the NFS share first, and then we can refer to it when creating a persistent volume. Additionally, we may need to install drivers for supporting that volume on the cluster. \n\n![Graphical user interface, text, applicationDescription automatically generated](/blog-images/59109fced26c504cecd82674233bb3c4.png)\n\n##### YAML Example\n\nLet's look at an example configuration for an NFS volume. \n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\nname: nfs-vol\nspec:\ncapacity:\nstorage: 1Mi\naccessModes:\n  - ReadWriteMany\nnfs:\nserver: nfs-server-name\npath: \"/\"\nmountOptions:\n  - nfsvers=4.1\n```\n\nThe name, capacity, and accessModes are common to all types of volumes, whereas the section at the end, \"nfs\" in this case, is specific to the type of volume. \n\nWe can create the volume with **kubectl apply**. To get information about a volume, we would use \n\n```yaml\nkubectl get pv\n```\n\nNow, create a persistent volume claim, and again with kubectl apply \n\n```yaml\n\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: my-pv-claim\nspec:\n  storageClassName: manual\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 3Gi\n\n```\n\nHere, we can request a particular storage class (useful for dynamic provisioning), the access mode, and the amount of storage needed. \n\nWe can query for a claim using \n\n```yaml\nkubectl get pvc\n```\n\nFinally, we can use the claim in a pod: \n\n```\n\napiVersion: v1\nkind: Pod\nmetadata:\n  name: my-pod\nspec:\n  volumes:\n    - name: my-pv-storage\n      persistentVolumeClaim:\n        claimName: my-pv-claim\n  containers:\n    - name: my-pv-container\n      image: nginx\n      ports:\n        - containerPort: 8080\n          name: \"tomcat-server\"\n      volumeMounts:\n        - mountPath: \"/usr/data\"\n          name: my-pv-storage\n\n```\n\nHere, we link the persistent volume to the claim we created earlier. Then, as usual, we refer to the volume to mount it at the specified path in the container. \n\nNext, let's go through the supported types of persistent volumes. \n\n##### HostPath\n\nThis is probably the easiest way to test persistent volumes. \n\nHostPath mounts content from the node's file system into the pod. It has specific use cases, like when the container needs to run sys tools or access Docker internals. Containers usually shouldn't make any assumptions about the host node, so good practice discourages such use. \n\nAlso, hostPath exposes the host's file system—and potentially the cluster—to security flaws in the application. We should only use it for testing on a single node, as it doesn't work in a multi-node cluster. You can check out the **local** volume type instead. \n\n##### Local\n\nUsing local storage devices mounted on nodes is a better alternative to hostPath for sharing a file system between multiple pods but on the same node. \n\nThe volume definition contains **node affinity,** which points to the particular node name on which the local storage is available. The controller will assign pods using the local storage volume to the node that has the local storage, thus using the node affinity to identify the node name. \n\nIf the node with the local storage becomes unhealthy, the storage will become unavailable, and pods using it will fail too. Thus, local storage is not suitable where fail safety is important. \n\n![Graphical user interface, text, applicationDescription automatically generated](/blog-images/23297143a280c4334df4d2cc653a7d19.png)\n\n#### Projected\n\nA projected volume maps several existing volume sources into the same directory. The supported volume types for this are downwardAPI, secret, configMap, and serviceAccountToken. \n\n#### ISCSI\n\niSCSI—SCSI over IP—is an IP-based standard for transferring data that supports host access by carrying SCSI commands over IP networks. [SCSI](https://en.wikipedia.org/wiki/SCSI) is a set of standards for physically connecting and transferring data between computers and peripheral devices. \n\n#### CSI\n\nThe container storage interface defined by Kubernetes is a standard for exposing arbitrary block and file storage systems to containerized workloads. To support using a new type of file system as a volume, we need to write a CSI driver for that file system and install it on the cluster. A list of CSI drivers can be seen [here](https://kubernetes-csi.github.io/docs/drivers.html), including drivers for file systems on popular cloud providers like AWS and Azure. \n\n#### Fc\n\nFc, or [Fibre Channel storage](https://www.ibm.com/docs/en/ds8880/8.1.1?topic=attachment-fibre-channel-storage-area-networks), is a high-speed network that attaches servers and storage devices. \n\n#### Nfs\n\nA [network file system](https://en.wikipedia.org/wiki/Network_File_System) is a distributed file system originally developed by Sun Microsystems that's based on the [open network computing remote procedure call](https://en.wikipedia.org/wiki/Open_Network_Computing_Remote_Procedure_Call). \n\n#### Cephfs\n\nA [Ceph file system](https://docs.ceph.com/en/quincy/cephfs/) is a POSIX-compliant, open-source file system built on top of Ceph’s distributed object store, **Rados**. It provides a multi-use, highly available, and performant file store. \n\n#### RBD\n\nA Rados block device is the device on which the Ceph file system is built. Block storage allows us to access storage as blocks of raw data rather than files and directories. \n\n#### AwsElasticBlockStore (deprecated)\n\nWe can use this volume type to mount an AWS EBS store. It is now deprecated, so we should use the CSI drivers instead. \n\n#### AzureDisk (deprecated)\n\nThis is used to mount an Azure disk. It is now deprecated, so we should use the CSI drivers instead. \n\nThe above list of persistent volume types is not exhaustive, but it covers the commonly used types. \n\n#### ConfigMap\n\nThis type of volume exposes key value pairs from a ConfigMap as files on the file system. \n\nSpecifically, the key becomes the file name, and the value becomes the file contents. For example, the log-level=debug key value is represented as a file named log-level with contents = \"debug\". We can specify the path at which we want to mount the volume in the container. But first, we need to create a ConfigMap using **kubectl create.** \n\nWe can create it from properties files or literal values. It's also possible to expose the values from the ConfigMap as environment variables for a pod. See [more](https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/) for details. \n\n#### Downward API\n\nThe downward API exposes pod and container field values to applications. The downward API volume exposes the key value pairs as files on the file system similar to ConfigMap above. \n\n#### Secret\n\nThis is a tempfs-based file system used to store secrets, e.g., for authentication. It's similar to ConfigMap. We need to first create a  secret using the Kubernetes API. We can also expose secrets as environment variables. \n\n### Conclusion\n\nIn this post, we've highlighted how to inject file systems into Kubernetes pods using volumes. \n\nWe've also explored the different kinds of volumes and their uses. Using volumes allows us to use various types of storage, persist data independent of the pod, and also share data across pods.\n",
    "code": "var Component=(()=>{var d=Object.create;var i=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var g=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=>{for(var s in e)i(t,s,{get:e[s],enumerable:!0})},r=(t,e,s,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of m(e))!f.call(t,a)&&a!==s&&i(t,a,{get:()=>e[a],enumerable:!(o=p(e,a))||o.enumerable});return t};var v=(t,e,s)=>(s=t!=null?d(u(t)):{},r(e||!t||!t.__esModule?i(s,\"default\",{value:t,enumerable:!0}):s,t)),w=t=>r(i({},\"__esModule\",{value:!0}),t);var c=g((S,l)=>{l.exports=_jsx_runtime});var T={};y(T,{default:()=>N,frontmatter:()=>b});var n=v(c()),b={title:\"Kubernetes Volumes: What They Are and How to Use Them\",summary:\"Learn how to inject file systems into Kubernetes pods using volumes and talk about the different types of their uses.\",publishDate:\"Tue Sep 13 2022 18:26:07 GMT+0000 (Coordinated Universal Time)\",author:\"erik-landerholm\",readingTime:5,categories:[\"kubernetes\",\"platform-engineering\"],mainImage:\"/blog-images/e2fad2ca4879f4bfe48dc3b52c46df72.jpg\",imageAlt:\"A table with a cell phone, pencil, glasses and a plant\",showCTA:!0,ctaCopy:\"Discover how Release.com's dynamic environments streamline Kubernetes volume management for persistent data storage.\",ctaLink:\"https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=kubernetes-volumes-what-they-are-and-how-to-use-them\",relatedPosts:[\"\"],ogImage:\"/blog-images/e2fad2ca4879f4bfe48dc3b52c46df72.jpg\",excerpt:\"Learn how to inject file systems into Kubernetes pods using volumes and talk about the different types of their uses.\",tags:[\"kubernetes\",\"platform-engineering\"],ctaButton:\"Try Release for Free\"};function h(t){let e=Object.assign({p:\"p\",a:\"a\",h3:\"h3\",span:\"span\",strong:\"strong\",h4:\"h4\",pre:\"pre\",code:\"code\",img:\"img\",h5:\"h5\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"By default, the file system available to a Kubernetes pod is limited to the pod's lifetime. As such, when the pod is deleted, all changes are lost.\"}),`\n`,(0,n.jsx)(e.p,{children:\"But many applications will need to store data persistently, irrespective of whether a pod is running or not. For example, we need to retain data that was updated in the database or files written. Also, we may want to share a file system across multiple containers, and those may be running on different nodes.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Let's take a look at Kubernetes \",(0,n.jsx)(e.a,{href:\"https://kubernetes.io/docs/concepts/storage/volumes/\",children:\"volumes\"}),\", which can address these problems.\"]}),`\n`,(0,n.jsxs)(e.h3,{id:\"the-basics\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#the-basics\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"The Basics\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Most data storage that applications use is ultimately file system-based, e.g., even though a database may keep some or all of its data in memory while running, it also keeps it updated in the data files on the file system for persistence.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"Volumes allow us to inject the application with a reference to a file system, which the application can then read from or write to.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"Injecting the file system makes it independent of the container's lifetime. We need to specify an absolute path where the injected file system should be mounted within the container's file system.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"Volumes may be persistent or not. There are many different types of volumes, as we shall see.\\xA0\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"A volume has to first be defined using the \",(0,n.jsx)(e.strong,{children:\"volumes\"}),\" key, and then used by a container using the \",(0,n.jsx)(e.strong,{children:\"volumeMounts\"}),\" key.\\xA0\"]}),`\n`,(0,n.jsxs)(e.h4,{id:\"example\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#example\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Example\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Below is a partial YAML snippet to illustrate how we can define and use volumes in a pod. Depending on the type of volume, its definition and usage could be in separate places.\\xA0\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`apiVersion: v0\nkind: Pod\nmetadata:\n  \\xA0name: my-pod\nspec:\n  \\xA0containers:\n  \\xA0- image: some-image-name\n  \\xA0 \\xA0name: my-container\n  \\xA0 \\xA0volumeMounts:\n  \\xA0 \\xA0- mountPath: /tempfiles\n  \\xA0 \\xA0 \\xA0name: temp-files-volume\n  \\xA0volumes:\n  \\xA0- name: temp-files-volume\n  \\xA0 \\xA0emptyDir: {}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Here, we've defined a volume of the \",(0,n.jsx)(e.strong,{children:\"emptyDir\"}),\" type. We'll see more about this later.\\xA0\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Since this type can only be used at the level of a single pod, not across, it's defined along with the pod. There could be multiple containers in a pod (though usually not), and they could all use the same volume.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"So, if one container in a pod writes a new file to the volume, it would be visible to the other containers in that pod that use that volume. The name of the volume can be anything.\\xA0\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.strong,{children:\"volumeMounts\"}),\" entry under the container specifies where to mount that volume within the container's file system. In this case, we want /tempfiles.\\xA0\"]}),`\n`,(0,n.jsx)(e.p,{children:\"When the application in the container writes to /tempfiles, it'll be writing to the temp-files volume. A container may use many different volumes or none. Note that in order to use volumes, the application in the container has to use the path that we specified in mountPath.\\xA0\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"So, if you want to use a container image with volumes, make sure that the path it uses to read/write files matches the path we specified in \",(0,n.jsx)(e.strong,{children:\"volumeMounts.\"}),\"\\xA0\"]}),`\n`,(0,n.jsx)(e.p,{children:\"A volume could\\u2014depending on its type\\u2014specify other attributes like accessModes, i.e., what kind of access it allows.\\xA0\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Modes can be \",(0,n.jsx)(e.strong,{children:\"ReadWriteOnce\"}),\", \",(0,n.jsx)(e.strong,{children:\"ReadOnlyMany\"}),\", \",(0,n.jsx)(e.strong,{children:\"ReadWriteMany\"}),\", and \",(0,n.jsx)(e.strong,{children:\"ReadWriteOncePod\"}),\". Note that specifying an access mode may not constrain the actual usage by the container. See \",(0,n.jsx)(e.a,{href:\"https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes\",children:\"access modes\"}),\" for details.\\xA0\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Now, let's take a look at different types of volumes.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/bd7448beaaf00cde3327a932d3196820.jpeg\",alt:\"A picture containing textDescription automatically generated\"})}),`\n`,(0,n.jsxs)(e.h3,{id:\"volume-types\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#volume-types\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Volume Types\"]}),`\n`,(0,n.jsxs)(e.h4,{id:\"emptydir\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#emptydir\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"EmptyDir\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Kubernetes first creates an emptyDir volume when it assigns the \",(0,n.jsx)(e.a,{href:\"https://kubernetes.io/docs/concepts/workloads/pods/\",children:\"pod\"}),\" using that volume to a \",(0,n.jsx)(e.a,{href:\"https://kubernetes.io/docs/concepts/architecture/nodes/\",children:\"node\"}),\". As the name suggests, it's empty to start with, i.e., it contains no files/directories.\\xA0\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Containers in the same pod can share the volume so that changes made by any container are visible to others. The emptyDir volume persists as long as the pod using it does\\u2014a container crash does not delete a pod.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"Thus, it's an ephemeral or temporary kind of storage for things like cached files/data or intermediate results, etc. Also, we cannot use it to share data across pods.\\xA0\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"persistent\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#persistent\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Persistent\"]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.a,{href:\"https://kubernetes.io/docs/concepts/storage/persistent-volumes/\",children:\"Persistent volumes\"}),\" are defined by an administrator at the Kubernetes cluster level and can be used by multiple nodes in the cluster. They can retain their data even if we delete the pod using them.\\xA0\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Applications in containers can request to use a persistent volume by specifying a persistent volume \",(0,n.jsx)(e.strong,{children:\"claim\"}),\". The claim specifies how much storage of what type it requires and using which access mode.\\xA0\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The cluster can allocate the storage for a claim in two ways: statically if a claim is satisfied by a provisioned volume, and dynamically\\u2014for if no volume is available for a claim, the cluster may try to provision the volume dynamically based on the storage class specified.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"The claim with the allocated storage is valid as long as the pod making the claim exists.\\xA0\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.strong,{children:\"reclaim policy\"}),\" of a volume specifies what to do with a volume once the application no longer needs the volume storage\\u2014for example, when we delete a pod using the volume.\\xA0\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Accordingly, we can either retain or delete the data on the volume. Note also that the available access modes will depend on what type of volume is used. Since Kubernetes itself does not provide a file-sharing solution, we need to set that up first.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"For instance, when using NFS, we need to set up the NFS share first, and then we can refer to it when creating a persistent volume. Additionally, we may need to install drivers for supporting that volume on the cluster.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/59109fced26c504cecd82674233bb3c4.png\",alt:\"Graphical user interface, text, applicationDescription automatically generated\"})}),`\n`,(0,n.jsxs)(e.h5,{id:\"yaml-example\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#yaml-example\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"YAML Example\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Let's look at an example configuration for an NFS volume.\\xA0\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`apiVersion: v1\nkind: PersistentVolume\nmetadata:\nname: nfs-vol\nspec:\ncapacity:\nstorage: 1Mi\naccessModes:\n  - ReadWriteMany\nnfs:\nserver: nfs-server-name\npath: \"/\"\nmountOptions:\n  - nfsvers=4.1\n`})}),`\n`,(0,n.jsx)(e.p,{children:'The name, capacity, and accessModes are common to all types of volumes, whereas the section at the end, \"nfs\" in this case, is specific to the type of volume.\\xA0'}),`\n`,(0,n.jsxs)(e.p,{children:[\"We can create the volume with \",(0,n.jsx)(e.strong,{children:\"kubectl apply\"}),\". To get information about a volume, we would use\\xA0\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`kubectl get pv\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Now, create a persistent volume claim, and again with kubectl apply\\xA0\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n \\xA0name: my-pv-claim\nspec:\n \\xA0storageClassName: manual\n \\xA0accessModes:\n \\xA0 \\xA0- ReadWriteOnce\n \\xA0resources:\n \\xA0 \\xA0requests:\n \\xA0 \\xA0 \\xA0storage: 3Gi\n\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Here, we can request a particular storage class (useful for dynamic provisioning), the access mode, and the amount of storage needed.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"We can query for a claim using\\xA0\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`kubectl get pvc\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Finally, we can use the claim in a pod:\\xA0\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`\napiVersion: v1\nkind: Pod\nmetadata:\n \\xA0name: my-pod\nspec:\n \\xA0volumes:\n \\xA0 \\xA0- name: my-pv-storage\n \\xA0 \\xA0 \\xA0persistentVolumeClaim:\n \\xA0 \\xA0 \\xA0 \\xA0claimName: my-pv-claim\n \\xA0containers:\n \\xA0 \\xA0- name: my-pv-container\n \\xA0 \\xA0 \\xA0image: nginx\n \\xA0 \\xA0 \\xA0ports:\n \\xA0 \\xA0 \\xA0 \\xA0- containerPort: 8080\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0name: \"tomcat-server\"\n \\xA0 \\xA0 \\xA0volumeMounts:\n \\xA0 \\xA0 \\xA0 \\xA0- mountPath: \"/usr/data\"\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0name: my-pv-storage\n\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Here, we link the persistent volume to the claim we created earlier. Then, as usual, we refer to the volume to mount it at the specified path in the container.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"Next, let's go through the supported types of persistent volumes.\\xA0\"}),`\n`,(0,n.jsxs)(e.h5,{id:\"hostpath\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#hostpath\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"HostPath\"]}),`\n`,(0,n.jsx)(e.p,{children:\"This is probably the easiest way to test persistent volumes.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"HostPath mounts content from the node's file system into the pod. It has specific use cases, like when the container needs to run sys tools or access Docker internals. Containers usually shouldn't make any assumptions about the host node, so good practice discourages such use.\\xA0\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Also, hostPath exposes the host's file system\\u2014and potentially the cluster\\u2014to security flaws in the application. We should only use it for testing on a single node, as it doesn't work in a multi-node cluster. You can check out the \",(0,n.jsx)(e.strong,{children:\"local\"}),\" volume type instead.\\xA0\"]}),`\n`,(0,n.jsxs)(e.h5,{id:\"local\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#local\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Local\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Using local storage devices mounted on nodes is a better alternative to hostPath for sharing a file system between multiple pods but on the same node.\\xA0\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The volume definition contains \",(0,n.jsx)(e.strong,{children:\"node affinity,\"}),\" which points to the particular node name on which the local storage is available. The controller will assign pods using the local storage volume to the node that has the local storage, thus using the node affinity to identify the node name.\\xA0\"]}),`\n`,(0,n.jsx)(e.p,{children:\"If the node with the local storage becomes unhealthy, the storage will become unavailable, and pods using it will fail too. Thus, local storage is not suitable where fail safety is important.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/23297143a280c4334df4d2cc653a7d19.png\",alt:\"Graphical user interface, text, applicationDescription automatically generated\"})}),`\n`,(0,n.jsxs)(e.h4,{id:\"projected\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#projected\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Projected\"]}),`\n`,(0,n.jsx)(e.p,{children:\"A projected volume maps several existing volume sources into the same directory. The supported volume types for this are downwardAPI, secret, configMap, and serviceAccountToken.\\xA0\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"iscsi\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#iscsi\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"ISCSI\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"iSCSI\\u2014SCSI over IP\\u2014is an IP-based standard for transferring data that supports host access by carrying SCSI commands over IP networks. \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/SCSI\",children:\"SCSI\"}),\" is a set of standards for physically connecting and transferring data between computers and peripheral devices.\\xA0\"]}),`\n`,(0,n.jsxs)(e.h4,{id:\"csi\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#csi\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"CSI\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The container storage interface defined by Kubernetes is a standard for exposing arbitrary block and file storage systems to containerized workloads. To support using a new type of file system as a volume, we need to write a CSI driver for that file system and install it on the cluster. A list of CSI drivers can be seen \",(0,n.jsx)(e.a,{href:\"https://kubernetes-csi.github.io/docs/drivers.html\",children:\"here\"}),\", including drivers for file systems on popular cloud providers like AWS and Azure.\\xA0\"]}),`\n`,(0,n.jsxs)(e.h4,{id:\"fc\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#fc\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Fc\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Fc, or \",(0,n.jsx)(e.a,{href:\"https://www.ibm.com/docs/en/ds8880/8.1.1?topic=attachment-fibre-channel-storage-area-networks\",children:\"Fibre Channel storage\"}),\", is a high-speed network that attaches servers and storage devices.\\xA0\"]}),`\n`,(0,n.jsxs)(e.h4,{id:\"nfs\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#nfs\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Nfs\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Network_File_System\",children:\"network file system\"}),\" is a distributed file system originally developed by Sun Microsystems that's based on the \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Open_Network_Computing_Remote_Procedure_Call\",children:\"open network computing remote procedure call\"}),\".\\xA0\"]}),`\n`,(0,n.jsxs)(e.h4,{id:\"cephfs\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#cephfs\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Cephfs\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A \",(0,n.jsx)(e.a,{href:\"https://docs.ceph.com/en/quincy/cephfs/\",children:\"Ceph file system\"}),\" is a POSIX-compliant, open-source file system built on top of Ceph\\u2019s distributed object store, \",(0,n.jsx)(e.strong,{children:\"Rados\"}),\". It provides a multi-use, highly available, and performant file store.\\xA0\"]}),`\n`,(0,n.jsxs)(e.h4,{id:\"rbd\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#rbd\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"RBD\"]}),`\n`,(0,n.jsx)(e.p,{children:\"A Rados block device is the device on which the Ceph file system is built. Block storage allows us to access storage as blocks of raw data rather than files and directories.\\xA0\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"awselasticblockstore-deprecated\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#awselasticblockstore-deprecated\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"AwsElasticBlockStore (deprecated)\"]}),`\n`,(0,n.jsx)(e.p,{children:\"We can use this volume type to mount an AWS EBS store. It is now deprecated, so we should use the CSI drivers instead.\\xA0\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"azuredisk-deprecated\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#azuredisk-deprecated\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"AzureDisk (deprecated)\"]}),`\n`,(0,n.jsx)(e.p,{children:\"This is used to mount an Azure disk. It is now deprecated, so we should use the CSI drivers instead.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"The above list of persistent volume types is not exhaustive, but it covers the commonly used types.\\xA0\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"configmap\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#configmap\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"ConfigMap\"]}),`\n`,(0,n.jsx)(e.p,{children:\"This type of volume exposes key value pairs from a ConfigMap as files on the file system.\\xA0\"}),`\n`,(0,n.jsxs)(e.p,{children:['Specifically, the key becomes the file name, and the value becomes the file contents. For example, the log-level=debug key value is represented as a file named log-level with contents = \"debug\". We can specify the path at which we want to mount the volume in the container. But first, we need to create a ConfigMap using ',(0,n.jsx)(e.strong,{children:\"kubectl create.\"}),\"\\xA0\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"We can create it from properties files or literal values. It's also possible to expose the values from the ConfigMap as environment variables for a pod. See \",(0,n.jsx)(e.a,{href:\"https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/\",children:\"more\"}),\" for details.\\xA0\"]}),`\n`,(0,n.jsxs)(e.h4,{id:\"downward-api\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#downward-api\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Downward API\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The downward API exposes pod and container field values to applications. The downward API volume exposes the key value pairs as files on the file system similar to ConfigMap above.\\xA0\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"secret\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#secret\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Secret\"]}),`\n`,(0,n.jsx)(e.p,{children:\"This is a tempfs-based file system used to store secrets, e.g., for authentication. It's similar to ConfigMap. We need to first create a \\xA0secret using the Kubernetes API. We can also expose secrets as environment variables.\\xA0\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"conclusion\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#conclusion\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Conclusion\"]}),`\n`,(0,n.jsx)(e.p,{children:\"In this post, we've highlighted how to inject file systems into Kubernetes pods using volumes.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"We've also explored the different kinds of volumes and their uses. Using volumes allows us to use various types of storage, persist data independent of the pod, and also share data across pods.\"})]})}function k(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(h,t)})):h(t)}var N=k;return w(T);})();\n;return Component;"
  },
  "_id": "blog/posts/kubernetes-volumes-what-they-are-and-how-to-use-them.mdx",
  "_raw": {
    "sourceFilePath": "blog/posts/kubernetes-volumes-what-they-are-and-how-to-use-them.mdx",
    "sourceFileName": "kubernetes-volumes-what-they-are-and-how-to-use-them.mdx",
    "sourceFileDir": "blog/posts",
    "contentType": "mdx",
    "flattenedPath": "blog/posts/kubernetes-volumes-what-they-are-and-how-to-use-them"
  },
  "type": "BlogPost",
  "computedSlug": "kubernetes-volumes-what-they-are-and-how-to-use-them"
}