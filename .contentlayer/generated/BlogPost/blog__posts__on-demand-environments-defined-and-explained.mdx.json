{
  "title": "On-Demand Environments Defined and Explained",
  "summary": "We cover on-demand environments, the best way to implement them, and the advantages and disadvantages of on-demand envir",
  "publishDate": "Mon Jan 23 2023 14:09:53 GMT+0000 (Coordinated Universal Time)",
  "author": "",
  "readingTime": 6,
  "categories": [
    "platform-engineering",
    "product"
  ],
  "mainImage": "/blog-images/d7cc904aebc0c67b9e417b029995d57f.jpeg",
  "imageAlt": "On-Demand Environments Defined and Explained",
  "showCTA": true,
  "ctaCopy": "Improve feature testing with Release's on-demand environments for seamless collaboration and independent staging. Try it now!",
  "ctaLink": "https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=on-demand-environments-defined-and-explained",
  "relatedPosts": [
    ""
  ],
  "ogImage": "/blog-images/d7cc904aebc0c67b9e417b029995d57f.jpeg",
  "excerpt": "We cover on-demand environments, the best way to implement them, and the advantages and disadvantages of on-demand envir",
  "tags": [
    "platform-engineering",
    "product"
  ],
  "ctaButton": "Try Release for Free",
  "body": {
    "raw": "\nThere is no better feeling than having a seamless development process. However, teams that use a shared staging environment to test their features often complain about feature conflicts and code-breaking. In this post, you’ll learn about on-demand environments and how they can help improve your development process.\n\n![](/blog-images/fefc582df66e8014144f0be8412dbff2.png)\n\n## **What is an On-Demand Environment?** \n\nAn on-demand environment is a temporary, isolated environment that developers set up to test features, build features, or fix bugs without disrupting other development processes. On-demand environments create a full-fledged replica of your project, which includes all microservices and dependencies that your app needs to function. You can create as many on-demand environments as you want and they can run simultaneously. In other words, every developer on your team working on specific features can have their own little playground to make and break their code without hindering other developers' work. And if they mess the replica up completely, they can throw it away and create another one.\n\nUsing an on-demand environment automatically gives you an independent [staging environment](https://releasehub.com/staging-environments) for every single feature. This is great because your developers have a place they can verify that their work meets expectations before merging it into production. In contrast, using a shared staging environment to test features might lead to a bottleneck. The on-demand environment approach is a much better way to go about feature testing in your software development process.\n\n![On-demand environment](/blog-images/e4805408c84441f7f99b3ec3b63b10f1.jpeg)\n\n## **Implementing On-Demand Environments**\n\nTypically, we create this environment manually, which includes configuring all your microservices (for example, dependencies, libraries, databases, and third-party software) using a tool like [Terraform](https://www.terraform.io/), but this approach requires a fair amount of precise reconfiguration of your project setup.\n\n- **Each Git branch should be prefixed** with the name of the task or feature associated with it. This makes it clear and easy to identify what each feature branch represents. For instance, for **fea-productName-branch-URL, Fea** \\= feature name, **productName** = product name, and **branch-URL** = Git branch URL.\n- **Access and parameterize** all your configurations that might differ between developers. For instance, you can package your configurations in a dataset and store them on the [AWS Systems Manager,](https://aws.amazon.com/systems-manager/) then use Terraform to communicate with them whenever you need them to spin up an environment.\n- **Define rules and restrictions** for your environments. You can use Terraform with [Azure Policy](https://learn.microsoft.com/en-us/azure/governance/policy/overview) to create policies for what sort of action can be carried out in each environment. For example, for security, you can restrict your developers from communicating with specific databases or even restrict them from using some services in specific locations.\n- **Consider cost.** You may want to create a configuration that automatically deletes an environment after merging and deleting pull requests. Also, you can configure it to stop every instance of services running on environments that do not require them.\n\n## **Buy an Environment Instead**\n\nThese days, many organizations use remote automated tools for creating on-demand environments. This lets them enjoy all the privileges of a full-fledged environment without bothering themselves or their DevOps team with the task of creating one manually. These automated tools allow you and your team to concentrate on more important tasks, like developing an application with all the features it needs, but without headaches.\n\nAutomation tools can create an on-demand environment out of the box for you, which would include the full-fledged application, its frontend and backend, and every service or dependency it may require to fully function. These tools make creating an environment on demand quite easy and accessible. It takes care of most of the heavy lifting for you, like managing configurations and dependencies and destroying the environment when necessary. In contrast, if you use the manual process of creating these environments, you have to handle all these manipulations by yourself.\n\n## **Advantages of On-Demand Environments**\n\n### **Faster App Release Time**\n\nThe traditional way to test every feature in development involved a shared staging environment. This is not idle, because a staging environment merges all the features in the app for testing and that can result in feature conflict. This delays production because a fix needs to happen before you carry on. On-demand environments come in handy because your team gets an isolated environment where they can work on every feature in your app independently, without worrying about it affecting other development work. This ultimately lets you avoid bottlenecks in your development process, giving your app a faster time to market. And this gives you an edge over competitors that don’t use on-demand environments.\n\n### **Dedicated Testing for Each Feature**\n\nA good software development company seizes any chance they get to test that their product meets exceptions. With an on-demand environment, you get another chance to test your product and you get to test every feature independently. This gives you and your team more time to figure out what works and what doesn’t.\n\n### **Product Quality**\n\nImagine a team using a shared staging environment for testing features in their app. Because of all the problems they might face with testing in a shared staging environment, they might run out of patience and release products that, at the end of the day, don’t really impress. But with on-demand environments, every developer working on a feature gets an isolated environment to build and test their feature before shipping to a staging or production environment. This can immensely improve the quality of your product. Note that you don't have to have a staging environment when you use on-demand environments, but a staging environment lets you test all the features that you worked on individually in the on-demand environment as a unit.\n\n### **Time Saving**\n\nIt takes a lot of time to resolve feature conflicts in a staging environment because you have to figure out which code change or feature broke the code. This wastes time unnecessarily. Time is precious and you need to complete other tasks. On-demand environments let other work continue, so you don’t waste time while you fix broken code. With an isolated development area, the development of your main app continues, unaffected.\n\n### **Happy Team**\n\nAvoiding work stoppages because of feature conflicts makes teams happy and we can all agree that when your team is happy, you're bound to have quality work.\n\n![](/blog-images/087fdf64fb6fd421d4a70b7883ab56b8.png)\n\n## **Disadvantages of On-Demand Environments**\n\nOne of the major concerns with on-demand environments is cost. Because all your micro-services actively work in more than one instance of your application, bills start to pile up. You can mitigate this by using an automation tool that manages the lifespan of all your environments, from when you activate them to when you disable them. These tools can automatically destroy any environment you no longer need, saving you money. You can also define policies for the maximum number of environments that you or your team can create.\n\n## **Conclusion** \n\nWe covered on-demand environments, the best way to implement them, and the advantages and disadvantages of on-demand environments. Now the only thing left is putting the icing on the cake.\n\nIf you read this post in full, you now know some of the tremendous benefits on-demand environments can bring to your development process. [Release](https://releasehub.com/ebook/the-complete-guide-to-automated-software-environments) is one tool you can use to spin up environments on-demand without dealing with lengthy set ups or convoluted processes. It doesn't matter if you have a complex app with [Docker Compose](https://docs.docker.com/compose/) or you just want to deploy a simple [static app](https://docs.releasehub.com/reference-documentation/static-service-deployment) with package.json, Release can generate a template using these files to build your environment on-demand. If any of this intrigues you and you are yearning for an effortless means of creating environments for your projects, don't hesitate to learn about the magic of [Release](https://releasehub.com/ebook/the-complete-guide-to-automated-software-environments).\n",
    "code": "var Component=(()=>{var h=Object.create;var i=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var f=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=>{for(var a in e)i(t,a,{get:e[a],enumerable:!0})},s=(t,e,a,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of u(e))!g.call(t,o)&&o!==a&&i(t,o,{get:()=>e[o],enumerable:!(r=m(e,o))||r.enumerable});return t};var v=(t,e,a)=>(a=t!=null?h(p(t)):{},s(e||!t||!t.__esModule?i(a,\"default\",{value:t,enumerable:!0}):a,t)),b=t=>s(i({},\"__esModule\",{value:!0}),t);var d=f((j,c)=>{c.exports=_jsx_runtime});var N={};y(N,{default:()=>T,frontmatter:()=>w});var n=v(d()),w={title:\"On-Demand Environments Defined and Explained\",summary:\"We cover on-demand environments, the best way to implement them, and the advantages and disadvantages of on-demand envir\",publishDate:\"Mon Jan 23 2023 14:09:53 GMT+0000 (Coordinated Universal Time)\",author:\"\",readingTime:6,categories:[\"platform-engineering\",\"product\"],mainImage:\"/blog-images/d7cc904aebc0c67b9e417b029995d57f.jpeg\",imageAlt:\"On-Demand Environments Defined and Explained\",showCTA:!0,ctaCopy:\"Improve feature testing with Release's on-demand environments for seamless collaboration and independent staging. Try it now!\",ctaLink:\"https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=on-demand-environments-defined-and-explained\",relatedPosts:[\"\"],ogImage:\"/blog-images/d7cc904aebc0c67b9e417b029995d57f.jpeg\",excerpt:\"We cover on-demand environments, the best way to implement them, and the advantages and disadvantages of on-demand envir\",tags:[\"platform-engineering\",\"product\"],ctaButton:\"Try Release for Free\"};function l(t){let e=Object.assign({p:\"p\",img:\"img\",h2:\"h2\",a:\"a\",span:\"span\",strong:\"strong\",ul:\"ul\",li:\"li\",h3:\"h3\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"There is no better feeling than having a seamless development process. However, teams that use a shared staging environment to test their features often complain about feature conflicts and code-breaking. In this post, you\\u2019ll learn about on-demand environments and how they can help improve your development process.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/fefc582df66e8014144f0be8412dbff2.png\",alt:\"\"})}),`\n`,(0,n.jsxs)(e.h2,{id:\"what-is-an-on-demand-environment\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#what-is-an-on-demand-environment\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"What is an On-Demand Environment?\"}),\"\\xA0\"]}),`\n`,(0,n.jsx)(e.p,{children:\"An on-demand environment is a temporary, isolated environment that developers set up to test features, build features, or fix bugs without disrupting other development processes. On-demand environments create a full-fledged replica of your project, which includes all microservices and dependencies that your app needs to function. You can create as many on-demand environments as you want and they can run simultaneously. In other words, every developer on your team working on specific features can have their own little playground to make and break their code without hindering other developers' work. And if they mess the replica up completely, they can throw it away and create another one.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Using an on-demand environment automatically gives you an independent \",(0,n.jsx)(e.a,{href:\"https://releasehub.com/staging-environments\",children:\"staging environment\"}),\" for every single feature. This is great because your developers have a place they can verify that their work meets expectations before merging it into production. In contrast, using a shared staging environment to test features might lead to a bottleneck. The on-demand environment approach is a much better way to go about feature testing in your software development process.\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/e4805408c84441f7f99b3ec3b63b10f1.jpeg\",alt:\"On-demand environment\"})}),`\n`,(0,n.jsxs)(e.h2,{id:\"implementing-on-demand-environments\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#implementing-on-demand-environments\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"Implementing On-Demand Environments\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Typically, we create this environment manually, which includes configuring all your microservices (for example, dependencies, libraries, databases, and third-party software) using a tool like \",(0,n.jsx)(e.a,{href:\"https://www.terraform.io/\",children:\"Terraform\"}),\", but this approach requires a fair amount of precise reconfiguration of your project setup.\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Each Git branch should be prefixed\"}),\" with the name of the task or feature associated with it. This makes it clear and easy to identify what each feature branch represents. For instance, for \",(0,n.jsx)(e.strong,{children:\"fea-productName-branch-URL, Fea\"}),\" = feature name, \",(0,n.jsx)(e.strong,{children:\"productName\"}),\" = product name, and \",(0,n.jsx)(e.strong,{children:\"branch-URL\"}),\" = Git branch URL.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Access and parameterize\"}),\" all your configurations that might differ between developers. For instance, you can package your configurations in a dataset and store them on the \",(0,n.jsx)(e.a,{href:\"https://aws.amazon.com/systems-manager/\",children:\"AWS Systems Manager,\"}),\" then use Terraform to communicate with them whenever you need them to spin up an environment.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Define rules and restrictions\"}),\" for your environments. You can use Terraform with \",(0,n.jsx)(e.a,{href:\"https://learn.microsoft.com/en-us/azure/governance/policy/overview\",children:\"Azure Policy\"}),\" to create policies for what sort of action can be carried out in each environment. For example, for security, you can restrict your developers from communicating with specific databases or even restrict them from using some services in specific locations.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Consider cost.\"}),\" You may want to create a configuration that automatically deletes an environment after merging and deleting pull requests. Also, you can configure it to stop every instance of services running on environments that do not require them.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.h2,{id:\"buy-an-environment-instead\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#buy-an-environment-instead\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"Buy an Environment Instead\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"These days, many organizations use remote automated tools for creating on-demand environments. This lets them enjoy all the privileges of a full-fledged environment without bothering themselves or their DevOps team with the task of creating one manually. These automated tools allow you and your team to concentrate on more important tasks, like developing an application with all the features it needs, but without headaches.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Automation tools can create an on-demand environment out of the box for you, which would include the full-fledged application, its frontend and backend, and every service or dependency it may require to fully function. These tools make creating an environment on demand quite easy and accessible. It takes care of most of the heavy lifting for you, like managing configurations and dependencies and destroying the environment when necessary. In contrast, if you use the manual process of creating these environments, you have to handle all these manipulations by yourself.\"}),`\n`,(0,n.jsxs)(e.h2,{id:\"advantages-of-on-demand-environments\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#advantages-of-on-demand-environments\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"Advantages of On-Demand Environments\"})]}),`\n`,(0,n.jsxs)(e.h3,{id:\"faster-app-release-time\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#faster-app-release-time\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"Faster App Release Time\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"The traditional way to test every feature in development involved a shared staging environment. This is not idle, because a staging environment merges all the features in the app for testing and that can result in feature conflict. This delays production because a fix needs to happen before you carry on. On-demand environments come in handy because your team gets an isolated environment where they can work on every feature in your app independently, without worrying about it affecting other development work. This ultimately lets you avoid bottlenecks in your development process, giving your app a faster time to market. And this gives you an edge over competitors that don\\u2019t use on-demand environments.\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"dedicated-testing-for-each-feature\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#dedicated-testing-for-each-feature\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"Dedicated Testing for Each Feature\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"A good software development company seizes any chance they get to test that their product meets exceptions. With an on-demand environment, you get another chance to test your product and you get to test every feature independently. This gives you and your team more time to figure out what works and what doesn\\u2019t.\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"product-quality\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#product-quality\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"Product Quality\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"Imagine a team using a shared staging environment for testing features in their app. Because of all the problems they might face with testing in a shared staging environment, they might run out of patience and release products that, at the end of the day, don\\u2019t really impress. But with on-demand environments, every developer working on a feature gets an isolated environment to build and test their feature before shipping to a staging or production environment. This can immensely improve the quality of your product. Note that you don't have to have a staging environment when you use on-demand environments, but a staging environment lets you test all the features that you worked on individually in the on-demand environment as a unit.\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"time-saving\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#time-saving\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"Time Saving\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"It takes a lot of time to resolve feature conflicts in a staging environment because you have to figure out which code change or feature broke the code. This wastes time unnecessarily. Time is precious and you need to complete other tasks. On-demand environments let other work continue, so you don\\u2019t waste time while you fix broken code. With an isolated development area, the development of your main app continues, unaffected.\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"happy-team\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#happy-team\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"Happy Team\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"Avoiding work stoppages because of feature conflicts makes teams happy and we can all agree that when your team is happy, you're bound to have quality work.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/087fdf64fb6fd421d4a70b7883ab56b8.png\",alt:\"\"})}),`\n`,(0,n.jsxs)(e.h2,{id:\"disadvantages-of-on-demand-environments\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#disadvantages-of-on-demand-environments\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"Disadvantages of On-Demand Environments\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"One of the major concerns with on-demand environments is cost. Because all your micro-services actively work in more than one instance of your application, bills start to pile up. You can mitigate this by using an automation tool that manages the lifespan of all your environments, from when you activate them to when you disable them. These tools can automatically destroy any environment you no longer need, saving you money. You can also define policies for the maximum number of environments that you or your team can create.\"}),`\n`,(0,n.jsxs)(e.h2,{id:\"conclusion\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#conclusion\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"Conclusion\"}),\"\\xA0\"]}),`\n`,(0,n.jsx)(e.p,{children:\"We covered on-demand environments, the best way to implement them, and the advantages and disadvantages of on-demand environments. Now the only thing left is putting the icing on the cake.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"If you read this post in full, you now know some of the tremendous benefits on-demand environments can bring to your development process. \",(0,n.jsx)(e.a,{href:\"https://releasehub.com/ebook/the-complete-guide-to-automated-software-environments\",children:\"Release\"}),\" is one tool you can use to spin up environments on-demand without dealing with lengthy set ups or convoluted processes. It doesn't matter if you have a complex app with \",(0,n.jsx)(e.a,{href:\"https://docs.docker.com/compose/\",children:\"Docker Compose\"}),\" or you just want to deploy a simple \",(0,n.jsx)(e.a,{href:\"https://docs.releasehub.com/reference-documentation/static-service-deployment\",children:\"static app\"}),\" with package.json, Release can generate a template using these files to build your environment on-demand. If any of this intrigues you and you are yearning for an effortless means of creating environments for your projects, don't hesitate to learn about the magic of \",(0,n.jsx)(e.a,{href:\"https://releasehub.com/ebook/the-complete-guide-to-automated-software-environments\",children:\"Release\"}),\".\"]})]})}function k(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(l,t)})):l(t)}var T=k;return b(N);})();\n;return Component;"
  },
  "_id": "blog/posts/on-demand-environments-defined-and-explained.mdx",
  "_raw": {
    "sourceFilePath": "blog/posts/on-demand-environments-defined-and-explained.mdx",
    "sourceFileName": "on-demand-environments-defined-and-explained.mdx",
    "sourceFileDir": "blog/posts",
    "contentType": "mdx",
    "flattenedPath": "blog/posts/on-demand-environments-defined-and-explained"
  },
  "type": "BlogPost",
  "computedSlug": "on-demand-environments-defined-and-explained"
}