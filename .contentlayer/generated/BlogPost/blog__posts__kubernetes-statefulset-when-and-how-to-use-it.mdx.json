{
  "title": "Kubernetes StatefulSet: When and How to Use It",
  "summary": "At first glance, StatefulSets are very similar to standard Deployments, but there are some important differences.",
  "publishDate": "Wed Sep 07 2022 16:19:50 GMT+0000 (Coordinated Universal Time)",
  "author": "nick-busey",
  "readingTime": 5,
  "categories": [
    "kubernetes",
    "platform-engineering"
  ],
  "mainImage": "/blog-images/029fddb95501b95dac344adedfa94257.jpg",
  "imageAlt": "a cell phone with the screen saying eat, sleep, code, repeat",
  "showCTA": true,
  "ctaCopy": "Looking to manage stateful applications in Kubernetes like a pro? Try Release.com for seamless environment provisioning and testing.",
  "ctaLink": "https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=kubernetes-statefulset-when-and-how-to-use-it",
  "relatedPosts": [
    ""
  ],
  "ogImage": "/blog-images/029fddb95501b95dac344adedfa94257.jpg",
  "excerpt": "At first glance, StatefulSets are very similar to standard Deployments, but there are some important differences.",
  "tags": [
    "kubernetes",
    "platform-engineering"
  ],
  "ctaButton": "Try Release for Free",
  "body": {
    "raw": "\n‍[Kubernetes](https://en.wikipedia.org/wiki/Kubernetes) was designed with stateless microservices in mind. But these days, it also comes with support for stateful applications, which is especially handy if you want to migrate your applications gradually. At first glance, StatefulSets are very similar to standard Kubernetes Deployments, but there are some important differences. In this post, you'll learn what StatefulSets actually are and when and how to use them. \n\n### What Are Stateful Applications?\n\nBefore we start explaining Kubernetes StatefulSets, you need to understand what stateful means and the difference between stateless and stateful applications. When you think about cloud-native applications, you most likely have a picture of an application that can run in multiple copies and where any copy can be restarted at any time while traffic is being redirected effortlessly to other instances. \n\nIn order for this model to work, the application needs to get some data from somewhere, execute some functions, and return the data. It can't store the data itself, and it shouldn't be dependent on other pods. If it were, you wouldn't be able to easily kill that instance without risking data loss. But in general, if an application doesn't store data itself in persistent storage and doesn't need to be started together with other microservices in a specific order, then it's stateless. \n\n#### Stateful vs Stateless\n\nAnd as you can probably guess, stateful applications are the opposite. They do need to keep some data in order to work. The most common example of a stateful application is a database. The whole point of, for example, MongoDB or MySQL applications is to store data. Therefore, both MongoDB and MySQL are stateful. You can't simply kill the instance of MongoDB and restart it somewhere else and expect it to work. \n\nFirst of all, by killing it unexpectedly, the data may get corrupted. And second, you can't simply restart MongoDB somewhere else because you need to first somehow reference the same data for it, which usually means either copying data or attaching the same persistent storage to it. \n\nUsing persistent data is not the only thing that can make an application stateful. If your microservice doesn't store any data but needs to be started in a specific order with other microservices, then it's also stateful. Or if you can't simply roll out a new version of the application because you also need to follow specific update procedures, then your application is most likely stateful. \n\nNow that you have that clear, let's talk about Kubernetes StatefulSets. \n\n![Graphical user interface, text, applicationDescription automatically generated](/blog-images/f8993a6902e8b36420f0fc82ff271a93.png)\n\n#### Kubernetes StatefulSet\n\nTraditionally, a normal Kubernetes Deployment assumes that your application is stateless. Therefore, Kubernetes may, at any point, just kill one of your instances and redeploy it elsewhere on the cluster when necessary. If your application is stateful, this could easily create an issue. You would either end up with corrupted data or your application could simply crash and require manual intervention. \n\nTherefore, specifically for stateful applications, Kubernetes offers so-called StatefulSets. These are special Kubernetes objects that will create and manage pods for your stateful application. Unlike in a standard Deployment, StatefulSets are aware that your application is stateful and will therefore treat it accordingly. \n\n#### Stable And Ordered\n\nKubernetes StatefulSets provide two main advantages (for stateful applications) over Deployments: a stable identity of the pods and the ability to follow specific Deployment orders. \n\nStable identity means persistent identity in this case. And persistent pod identity means that when a pod gets rescheduled for whatever reason, it will have the same network identifiers and the same storage assigned to it. So, from the perspective of other pods, it will look like the same pod. This is not the case when using Deployments, and it's very important for the proper working of stateful applications. \n\nWe already mentioned that if your application needs to be deployed or updated in a specific order, that's a good indication that it's stateful. In a traditional Deployment, if you'll have multiple pods in one Deployment, they would be deployed in a random order, which in the case of stateful application would probably mean that the application won't start properly. And therefore, this ability to follow a specific order when deploying or updating is built into the StatefulSets. \n\n![Graphical user interface, text, applicationDescription automatically generated](/blog-images/c340926b66f892274a9e48f60dc44fef.png)\n\n#### Creating StatefulSet\n\nEnough theory. Let's create some StatefulSets. The YAML definition of StatefulSets is very similar to standard Deployments and in a simple example looks like this: \n\n```yaml\napiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n   name: example-statefulset\nspec:\n   selector:\n     matchLabels:\n       app: nginx\n   replicas: 1\n   serviceName: nginx\n   template:\n     metadata:\n       labels:\n         app: nginx\n     spec:\n       containers:\n       - name: nginx\n         image: registry.k8s.io/nginx-slim:0.8\n         ports:\n         - containerPort: 80\n           name: web\n```\n\nOnce you save the above code in a YAML file, you can deploy it, as usual, using **kubectl apply**: \n\n```yaml\n$ kubectl apply -f statefulset.yaml\nstatefulset.apps/example-statefulset created\n```\n\nYou can then validate that everything is working with **kubectl get**: \n\n```yaml\n$ kubectl get statefulsets\nNAME                  READY   AGE\nexample-statefulset   1/1     2m4s\n\n$ kubectl get pods\nNAME                    READY   STATUS    RESTARTS   AGE\nexample-statefulset-0   1/1     Running   0          2m8s\n```\n\nOK, your first StatefulSet is up and running. Congratulations. This was, however, a very simple example with only one pod in your StatefulSet. But you'll most likely use StatefulSets with multiple pods to get all the benefits. \n\n![TextDescription automatically generated with medium confidence](/blog-images/5b3db806e95be1ac41e59ed74e466982.jpeg)\n\n### StatefulSets Specifics\n\nLet's spice things up a little to see StatefulSets doing its job. Execute the following command to scale your nginx from one to ten replicas: \n\n```yaml\n$ kubectl scale statefulsets example-statefulset --replicas=10\nstatefulset.apps/example-statefulset scaled\n```\n\nNow, if you watch what's happening, you'll see the specific behavior of StatefulSets: \n\n```yaml\n$ kubectl get pods\nNAME                    READY   STATUS              RESTARTS   AGE\nexample-statefulset-0   1/1     Running             0          11m\nexample-statefulset-1   0/1     ContainerCreating   0          1s\n\n$ kubectl get pods\nNAME                    READY   STATUS              RESTARTS   AGE\nexample-statefulset-0   1/1     Running             0          11m\nexample-statefulset-1   1/1     Running             0          2s\nexample-statefulset-2   0/1     ContainerCreating   0          0s\n\n$ kubectl get pods\nNAME                    READY   STATUS              RESTARTS   AGE\nexample-statefulset-0   1/1     Running             0          11m\nexample-statefulset-1   1/1     Running             0          4s\nexample-statefulset-2   1/1     Running             0          2s\nexample-statefulset-3   0/1     ContainerCreating   0          1s\n\n(...)\n\n$ kubectl get pods\nNAME                    READY   STATUS    RESTARTS   AGE\nexample-statefulset-0   1/1     Running   0          14m\nexample-statefulset-1   1/1     Running   0          3m19s\nexample-statefulset-2   1/1     Running   0          3m17s\nexample-statefulset-3   1/1     Running   0          3m16s\nexample-statefulset-4   1/1     Running   0          3m14s\nexample-statefulset-5   1/1     Running   0          3m13s\nexample-statefulset-6   1/1     Running   0          3m12s\nexample-statefulset-7   1/1     Running   0          3m10s\nexample-statefulset-8   1/1     Running   0          3m9s\nexample-statefulset-9   1/1     Running   0          3m7s\n```\n\nYou can see that Kubernetes provisioned all replicas in order, one by one. This is one of the differences between Deployments and StatefulSets. In Deployments, all pods will be deployed in random order, with more than one pod being created at once. In StatefulSets, it happens sequentially, and pods are even numbered and do not get a random hash assigned as part of the name, which is the case in Deployments. Moreover, if at any point one of the replicas fails to start, the whole process will stop. So, for example, Kubernetes will only create **example-statefulset-5** after **example-statefulset-4** is up and running. \n\n### Name Stays the Same\n\nFollowing the same logic, if something happens to any of the pods, it will be recreated with the same name. \n\n```\n\n$ kubectl delete pod example-statefulset-3\npod \"example-statefulset-3\" deleted\n\n$ kubectl get pods\nNAME                    READY   STATUS    RESTARTS   AGE\nexample-statefulset-0   1/1     Running   0          20m\nexample-statefulset-1   1/1     Running   0          9m41s\nexample-statefulset-2   1/1     Running   0          9m39s\nexample-statefulset-4   1/1     Running   0          9m36s\nexample-statefulset-5   1/1     Running   0          9m35s\nexample-statefulset-6   1/1     Running   0          9m34s\nexample-statefulset-7   1/1     Running   0          9m32s\nexample-statefulset-8   1/1     Running   0          9m31s\nexample-statefulset-9   1/1     Running   0          9m29s\nexample-statefulset-3   1/1     Running   0          1s\n\n```\n\nThis, again, differs from Deployments, where you'd get another randomly named pod. This is important for stateful applications because, most likely, each pod will hold its own state. Therefore, it's crucial not to mix them up. Also, other microservices that would connect to these pods will probably need to always connect to the same pod even if it dies and is rescheduled. \n\nThe same applies to networking. You can always connect to a specific pod by its domain name, like **example-statefulset-6.nginx.default.svc.cluster.local,** and you'll have a guarantee that you'll always reach the same pod. That's not the case with Deployments. \n\n### Summary\n\nKubernetes StatefulSets are really useful. In theory, using them means doing something that Kubernetes wasn't designed to work with in the first place. But it's really hard to have every single application on your cluster stateless. Especially in big environments with dozens or even hundreds of applications, there will always be some microservice that needs to hold some state. In some cases, it simply doesn't make sense to spend time and money on redesigning a stateless application to be stateful if it won't bring much difference or business value. \n\nIn this post, you learned what [StatefulSets](https://docs.releasehub.com/reference-documentation/application-settings/application-template/schema-definition#stateful-sets-and-deployments) are and how to create them. If you want to learn more about other Kubernetes resources, take a look at [our blog](https://release.com/blog).\n",
    "code": "var Component=(()=>{var d=Object.create;var i=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var h=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var g=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),y=(a,e)=>{for(var n in e)i(a,n,{get:e[n],enumerable:!0})},o=(a,e,n,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of h(e))!f.call(a,s)&&s!==n&&i(a,s,{get:()=>e[s],enumerable:!(l=u(e,s))||l.enumerable});return a};var b=(a,e,n)=>(n=a!=null?d(m(a)):{},o(e||!a||!a.__esModule?i(n,\"default\",{value:a,enumerable:!0}):n,a)),w=a=>o(i({},\"__esModule\",{value:!0}),a);var c=g((R,r)=>{r.exports=_jsx_runtime});var v={};y(v,{default:()=>k,frontmatter:()=>S});var t=b(c()),S={title:\"Kubernetes StatefulSet: When and How to Use It\",summary:\"At first glance, StatefulSets are very similar to standard Deployments, but there are some important differences.\",publishDate:\"Wed Sep 07 2022 16:19:50 GMT+0000 (Coordinated Universal Time)\",author:\"nick-busey\",readingTime:5,categories:[\"kubernetes\",\"platform-engineering\"],mainImage:\"/blog-images/029fddb95501b95dac344adedfa94257.jpg\",imageAlt:\"a cell phone with the screen saying eat, sleep, code, repeat\",showCTA:!0,ctaCopy:\"Looking to manage stateful applications in Kubernetes like a pro? Try Release.com for seamless environment provisioning and testing.\",ctaLink:\"https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=kubernetes-statefulset-when-and-how-to-use-it\",relatedPosts:[\"\"],ogImage:\"/blog-images/029fddb95501b95dac344adedfa94257.jpg\",excerpt:\"At first glance, StatefulSets are very similar to standard Deployments, but there are some important differences.\",tags:[\"kubernetes\",\"platform-engineering\"],ctaButton:\"Try Release for Free\"};function p(a){let e=Object.assign({p:\"p\",a:\"a\",h3:\"h3\",span:\"span\",h4:\"h4\",img:\"img\",pre:\"pre\",code:\"code\",strong:\"strong\"},a.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"\\u200D\",(0,t.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Kubernetes\",children:\"Kubernetes\"}),\" was designed with stateless microservices in mind. But these days, it also comes with support for stateful applications, which is especially handy if you want to migrate your applications gradually. At first glance, StatefulSets are very similar to standard Kubernetes Deployments, but there are some important differences. In this post, you'll learn what StatefulSets actually are and when and how to use them.\\xA0\"]}),`\n`,(0,t.jsxs)(e.h3,{id:\"what-are-stateful-applications\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#what-are-stateful-applications\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"What Are Stateful Applications?\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Before we start explaining Kubernetes StatefulSets, you need to understand what stateful means and the difference between stateless and stateful applications. When you think about cloud-native applications, you most likely have a picture of an application that can run in multiple copies and where any copy can be restarted at any time while traffic is being redirected effortlessly to other instances.\\xA0\"}),`\n`,(0,t.jsx)(e.p,{children:\"In order for this model to work, the application needs to get some data from somewhere, execute some functions, and return the data. It can't store the data itself, and it shouldn't be dependent on other pods. If it were, you wouldn't be able to easily kill that instance without risking data loss. But in general, if an application doesn't store data itself in persistent storage and doesn't need to be started together with other microservices in a specific order, then it's stateless.\\xA0\"}),`\n`,(0,t.jsxs)(e.h4,{id:\"stateful-vs-stateless\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#stateful-vs-stateless\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"Stateful vs Stateless\"]}),`\n`,(0,t.jsx)(e.p,{children:\"And as you can probably guess, stateful applications are the opposite. They do need to keep some data in order to work. The most common example of a stateful application is a database. The whole point of, for example, MongoDB or MySQL applications is to store data. Therefore, both MongoDB and MySQL are stateful. You can't simply kill the instance of MongoDB and restart it somewhere else and expect it to work.\\xA0\"}),`\n`,(0,t.jsx)(e.p,{children:\"First of all, by killing it unexpectedly, the data may get corrupted. And second, you can't simply restart MongoDB somewhere else because you need to first somehow reference the same data for it, which usually means either copying data or attaching the same persistent storage to it.\\xA0\"}),`\n`,(0,t.jsx)(e.p,{children:\"Using persistent data is not the only thing that can make an application stateful. If your microservice doesn't store any data but needs to be started in a specific order with other microservices, then it's also stateful. Or if you can't simply roll out a new version of the application because you also need to follow specific update procedures, then your application is most likely stateful.\\xA0\"}),`\n`,(0,t.jsx)(e.p,{children:\"Now that you have that clear, let's talk about Kubernetes StatefulSets.\\xA0\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/blog-images/f8993a6902e8b36420f0fc82ff271a93.png\",alt:\"Graphical user interface, text, applicationDescription automatically generated\"})}),`\n`,(0,t.jsxs)(e.h4,{id:\"kubernetes-statefulset\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#kubernetes-statefulset\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"Kubernetes StatefulSet\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Traditionally, a normal Kubernetes Deployment assumes that your application is stateless. Therefore, Kubernetes may, at any point, just kill one of your instances and redeploy it elsewhere on the cluster when necessary. If your application is stateful, this could easily create an issue. You would either end up with corrupted data or your application could simply crash and require manual intervention.\\xA0\"}),`\n`,(0,t.jsx)(e.p,{children:\"Therefore, specifically for stateful applications, Kubernetes offers so-called StatefulSets. These are special Kubernetes objects that will create and manage pods for your stateful application. Unlike in a standard Deployment, StatefulSets are aware that your application is stateful and will therefore treat it accordingly.\\xA0\"}),`\n`,(0,t.jsxs)(e.h4,{id:\"stable-and-ordered\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#stable-and-ordered\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"Stable And Ordered\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Kubernetes StatefulSets provide two main advantages (for stateful applications) over Deployments: a stable identity of the pods and the ability to follow specific Deployment orders.\\xA0\"}),`\n`,(0,t.jsx)(e.p,{children:\"Stable identity means persistent identity in this case. And persistent pod identity means that when a pod gets rescheduled for whatever reason, it will have the same network identifiers and the same storage assigned to it. So, from the perspective of other pods, it will look like the same pod. This is not the case when using Deployments, and it's very important for the proper working of stateful applications.\\xA0\"}),`\n`,(0,t.jsx)(e.p,{children:\"We already mentioned that if your application needs to be deployed or updated in a specific order, that's a good indication that it's stateful. In a traditional Deployment, if you'll have multiple pods in one Deployment, they would be deployed in a random order, which in the case of stateful application would probably mean that the application won't start properly. And therefore, this ability to follow a specific order when deploying or updating is built into the StatefulSets.\\xA0\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/blog-images/c340926b66f892274a9e48f60dc44fef.png\",alt:\"Graphical user interface, text, applicationDescription automatically generated\"})}),`\n`,(0,t.jsxs)(e.h4,{id:\"creating-statefulset\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#creating-statefulset\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"Creating StatefulSet\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Enough theory. Let's create some StatefulSets. The YAML definition of StatefulSets is very similar to standard Deployments and in a simple example looks like this:\\xA0\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-yaml\",children:`apiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  \\xA0name: example-statefulset\nspec:\n  \\xA0selector:\n  \\xA0 \\xA0matchLabels:\n  \\xA0 \\xA0 \\xA0app: nginx\n  \\xA0replicas: 1\n  \\xA0serviceName: nginx\n  \\xA0template:\n  \\xA0 \\xA0metadata:\n  \\xA0 \\xA0 \\xA0labels:\n  \\xA0 \\xA0 \\xA0 \\xA0app: nginx\n  \\xA0 \\xA0spec:\n  \\xA0 \\xA0 \\xA0containers:\n  \\xA0 \\xA0 \\xA0- name: nginx\n  \\xA0 \\xA0 \\xA0 \\xA0image: registry.k8s.io/nginx-slim:0.8\n  \\xA0 \\xA0 \\xA0 \\xA0ports:\n  \\xA0 \\xA0 \\xA0 \\xA0- containerPort: 80\n  \\xA0 \\xA0 \\xA0 \\xA0 \\xA0name: web\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Once you save the above code in a YAML file, you can deploy it, as usual, using \",(0,t.jsx)(e.strong,{children:\"kubectl apply\"}),\":\\xA0\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-yaml\",children:`$ kubectl apply -f statefulset.yaml\nstatefulset.apps/example-statefulset created\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"You can then validate that everything is working with \",(0,t.jsx)(e.strong,{children:\"kubectl get\"}),\":\\xA0\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-yaml\",children:`$ kubectl get statefulsets\nNAME \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0READY \\xA0 AGE\nexample-statefulset \\xA0 1/1 \\xA0 \\xA0 2m4s\n\n$ kubectl get pods\nNAME \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0READY \\xA0 STATUS \\xA0 \\xA0RESTARTS \\xA0 AGE\nexample-statefulset-0 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA02m8s\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"OK, your first StatefulSet is up and running. Congratulations. This was, however, a very simple example with only one pod in your StatefulSet. But you'll most likely use StatefulSets with multiple pods to get all the benefits.\\xA0\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/blog-images/5b3db806e95be1ac41e59ed74e466982.jpeg\",alt:\"TextDescription automatically generated with medium confidence\"})}),`\n`,(0,t.jsxs)(e.h3,{id:\"statefulsets-specifics\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#statefulsets-specifics\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"StatefulSets Specifics\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Let's spice things up a little to see StatefulSets doing its job. Execute the following command to scale your nginx from one to ten replicas:\\xA0\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-yaml\",children:`$ kubectl scale statefulsets example-statefulset --replicas=10\nstatefulset.apps/example-statefulset scaled\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"Now, if you watch what's happening, you'll see the specific behavior of StatefulSets:\\xA0\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-yaml\",children:`$ kubectl get pods\nNAME \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0READY \\xA0 STATUS \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0RESTARTS \\xA0 AGE\nexample-statefulset-0 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA011m\nexample-statefulset-1 \\xA0 0/1 \\xA0 \\xA0 ContainerCreating \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA01s\n\n$ kubectl get pods\nNAME \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0READY \\xA0 STATUS \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0RESTARTS \\xA0 AGE\nexample-statefulset-0 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA011m\nexample-statefulset-1 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA02s\nexample-statefulset-2 \\xA0 0/1 \\xA0 \\xA0 ContainerCreating \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA00s\n\n$ kubectl get pods\nNAME \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0READY \\xA0 STATUS \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0RESTARTS \\xA0 AGE\nexample-statefulset-0 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA011m\nexample-statefulset-1 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA04s\nexample-statefulset-2 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA02s\nexample-statefulset-3 \\xA0 0/1 \\xA0 \\xA0 ContainerCreating \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA01s\n\n(...)\n\n$ kubectl get pods\nNAME \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0READY \\xA0 STATUS \\xA0 \\xA0RESTARTS \\xA0 AGE\nexample-statefulset-0 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA014m\nexample-statefulset-1 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA03m19s\nexample-statefulset-2 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA03m17s\nexample-statefulset-3 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA03m16s\nexample-statefulset-4 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA03m14s\nexample-statefulset-5 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA03m13s\nexample-statefulset-6 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA03m12s\nexample-statefulset-7 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA03m10s\nexample-statefulset-8 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA03m9s\nexample-statefulset-9 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA03m7s\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"You can see that Kubernetes provisioned all replicas in order, one by one. This is one of the differences between Deployments and StatefulSets. In Deployments, all pods will be deployed in random order, with more than one pod being created at once. In StatefulSets, it happens sequentially, and pods are even numbered and do not get a random hash assigned as part of the name, which is the case in Deployments. Moreover, if at any point one of the replicas fails to start, the whole process will stop. So, for example, Kubernetes will only create \",(0,t.jsx)(e.strong,{children:\"example-statefulset-5\"}),\" after \",(0,t.jsx)(e.strong,{children:\"example-statefulset-4\"}),\" is up and running.\\xA0\"]}),`\n`,(0,t.jsxs)(e.h3,{id:\"name-stays-the-same\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#name-stays-the-same\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"Name Stays the Same\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Following the same logic, if something happens to any of the pods, it will be recreated with the same name.\\xA0\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:`\n$ kubectl delete pod example-statefulset-3\npod \"example-statefulset-3\" deleted\n\n$ kubectl get pods\nNAME \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0READY \\xA0 STATUS \\xA0 \\xA0RESTARTS \\xA0 AGE\nexample-statefulset-0 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA020m\nexample-statefulset-1 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA09m41s\nexample-statefulset-2 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA09m39s\nexample-statefulset-4 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA09m36s\nexample-statefulset-5 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA09m35s\nexample-statefulset-6 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA09m34s\nexample-statefulset-7 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA09m32s\nexample-statefulset-8 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA09m31s\nexample-statefulset-9 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA09m29s\nexample-statefulset-3 \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA01s\n\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"This, again, differs from Deployments, where you'd get another randomly named pod. This is important for stateful applications because, most likely, each pod will hold its own state. Therefore, it's crucial not to mix them up. Also, other microservices that would connect to these pods will probably need to always connect to the same pod even if it dies and is rescheduled.\\xA0\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The same applies to networking. You can always connect to a specific pod by its domain name, like \",(0,t.jsx)(e.strong,{children:\"example-statefulset-6.nginx.default.svc.cluster.local,\"}),\" and you'll have a guarantee that you'll always reach the same pod. That's not the case with Deployments.\\xA0\"]}),`\n`,(0,t.jsxs)(e.h3,{id:\"summary\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#summary\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"Summary\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Kubernetes StatefulSets are really useful. In theory, using them means doing something that Kubernetes wasn't designed to work with in the first place. But it's really hard to have every single application on your cluster stateless. Especially in big environments with dozens or even hundreds of applications, there will always be some microservice that needs to hold some state. In some cases, it simply doesn't make sense to spend time and money on redesigning a stateless application to be stateful if it won't bring much difference or business value.\\xA0\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"In this post, you learned what \",(0,t.jsx)(e.a,{href:\"https://docs.releasehub.com/reference-documentation/application-settings/application-template/schema-definition#stateful-sets-and-deployments\",children:\"StatefulSets\"}),\" are and how to create them. If you want to learn more about other Kubernetes resources, take a look at \",(0,t.jsx)(e.a,{href:\"https://release.com/blog\",children:\"our blog\"}),\".\"]})]})}function x(a={}){let{wrapper:e}=a.components||{};return e?(0,t.jsx)(e,Object.assign({},a,{children:(0,t.jsx)(p,a)})):p(a)}var k=x;return w(v);})();\n;return Component;"
  },
  "_id": "blog/posts/kubernetes-statefulset-when-and-how-to-use-it.mdx",
  "_raw": {
    "sourceFilePath": "blog/posts/kubernetes-statefulset-when-and-how-to-use-it.mdx",
    "sourceFileName": "kubernetes-statefulset-when-and-how-to-use-it.mdx",
    "sourceFileDir": "blog/posts",
    "contentType": "mdx",
    "flattenedPath": "blog/posts/kubernetes-statefulset-when-and-how-to-use-it"
  },
  "type": "BlogPost",
  "computedSlug": "kubernetes-statefulset-when-and-how-to-use-it"
}