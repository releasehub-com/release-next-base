{
  "title": "A Simple Guide to Software Environments",
  "summary": "Learn about tools to scope and limit instances of your software as it progresses from development to a finished product.",
  "publishDate": "Tue Apr 11 2023 21:10:39 GMT+0000 (Coordinated Universal Time)",
  "author": "alexander-fridman",
  "readingTime": 5,
  "categories": [
    "platform-engineering",
    "product"
  ],
  "mainImage": "/blog-images/b3927fc80db8ab1869298638402348e7.png",
  "imageAlt": "A Simple Guide to Software Environments",
  "showCTA": true,
  "ctaCopy": "Empower developers to streamline software environments from local to production with Release's on-demand, full-stack environments.",
  "ctaLink": "https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=a-simple-guide-to-software-environments",
  "relatedPosts": [
    ""
  ],
  "ogImage": "/blog-images/b3927fc80db8ab1869298638402348e7.png",
  "excerpt": "Learn about tools to scope and limit instances of your software as it progresses from development to a finished product.",
  "tags": [
    "platform-engineering",
    "product"
  ],
  "ctaButton": "Try Release for Free",
  "body": {
    "raw": "\n### Introduction\n\nBuilding software is hard. It takes a lot of time and effort and it’s a somewhat cumbersome process. Software development passes through various stages in the product lifecycle before it reaches the end user. A spec must be defined, developers have to code the product, QA has to test it, and DevOps engineers have to deploy it. During this process, the code passes through several environments, from the developers’ local PC to containers in the cloud. \n\n### What Are Software Environments\n\nSoftware environments are tools to scope and limit instances of your software as it progresses from development to a customer facing product. Each environment contains the following: \n\n- Copy of your software code\n- Copy of the database tables you use with (possibly) environment-specific data\n- Internal network so the different microservices your code uses can communicate with each other and with external services\n- Global values (environment variables)\n- Access control to limit who can view the application and make changes to it in the specific environment\n- Infrastructure to support it (servers and such)\n- Testing software to test the code\n\nLet's elaborate by giving specific examples of different environments. \n\n![A computer sits on a window sillDescription automatically generated with medium confidence](/blog-images/1897df55a97102dba7c22d77ec9fd988.jpeg)\n\n### Local Environment\n\nThe local environment is where a developer writes software code. They may be writing the whole application or just a specific feature for the application. The developer usually has a local database that works with the application code, and sometimes access to external microservices needed by the code. In other scenarios, where direct access from the developer’s laptop to external services is not possible, we use software mocks instead. When the app runs locally on the developer’s laptop, performance of the app in terms of CPU and RAM is low, compared with running it on a dedicated server or in other environments. In addition, there’s no access control for this environment. Anyone who can access the laptop has access to the application. On the other hand, it's the simplest and most immediate way to develop and test code. \n\n### Development Environment\n\nThe development environment is where multiple developers upload their code to. It’s meant to be the first place where other stakeholders can test the code and the application’s different features. Developers merge the code and run a CI/CD pipeline here. The [CI/CD pipeline](https://en.wikipedia.org/wiki/CI/CD) usually consists of the following steps: \n\n- Changes to the database (database migrations)\n- Static code analysis\n- Vulnerability scanning\n- Deployment to the development environment of the end artifact (JAR in Java or a binary)\n\nIn addition, this environment has more robust and thorough tests than those a developer runs on their laptop (e.g., integration tests). Developers apply the latest updates to the application in the development environment. Because it’s constantly being updated, the application is not stable in the development environment. It has a dedicated URL, environment variables, and better performance than versions run on individual developers’ local PCs. Usually all the developers on the team have access to this the development environment and to its database, which are not accessible outside of the organization (to clients, for instance). \n\n### Staging Environment\n\nThe staging environment is the next environment the software passes through before it’s made accessible to end users. The staging environment should be very similar to the production environment, mirroring it as accurately as possible, because its purpose is to be the last checkpoint before making the latest software publicly available. It should run on the same infrastructure, have the same database content, and the same environment variables (or as similar as possible) to those in the production environment. \n\n![](/blog-images/d163f05b3191007407e8aa9e95e7728d.png)\n\nTraditionally, the CI/CD pipeline that runs in the staging environment involves the most extensive testing of all the environments. All stakeholders in the organization have access to view this environment, but only a handful of key employees have direct access to modify it (IT team, DevOps, senior developers). It's a stable environment and after the code passes the tests, it will be deployed to production. However, recently companies started shifting testing to the left and conducting robust testing earlier in the cycle. \n\n### Production Environment\n\nThe production environment runs the code that serves end users — your customers. It's a stable environment with powerful infrastructure that can handle spikes in demand and has extensive monitoring and logging. Unlike in other environments, down time here results in an immediate service outage. To protect the infrastructure, environment variables, database, and code, access to the production environment is usually restricted to only system administrators. Because automatic tests can reduce performance and change the database, no tests are run in the production environment. \n\n### Customer Demo / Customer Specific Environment\n\nIt sometimes happens that you want to create a version of your software specific to a certain client or to demonstrate a certain feature before it’s available to customers. This happens in the [customer demo environment](https://release.com/blog/great-saas-sales-demos). It has all the bells and whistles of the production environment, but it might have a superset or subset of features from the production environment and a client-specific GUI or dedicated access control, relevant to one client only. \n\n### Environment Pain Points\n\nProvisioning environments is difficult and time consuming. Provisioning new environments requires servers, a deployment mechanism, design of CI/CD pipelines, database servers, access control definitions and so forth. In addition, every environment consumes significant resources to maintain it. For instance, the IT team needs to make sure that connectivity works as expected, make snapshots of the database, edit the list of stakeholders who have access to each environment, and so on. \n\n![A person holding a cigaretteDescription automatically generated with low confidence](/blog-images/b84ab91f3b3c2644c684fc86f02766c0.jpeg)\n\n### Easing Pain Points\n\nRecently, new products that provide [environments as a service (EaaS)](https://release.com/blog/environments-as-a-service-eaas-top-3-benefits) appeared on the market to address those pain points. They provide an unlimited number of automated environments with the click of a button, centralized management of environments, and a lower overhead for making changes to existing environments. \n\n### Increased Velocity\n\nIn addition to simplifying and speeding up environment deployment, EaaS solutions facilitate increased velocity of the R&D process as a whole because developers can spend less time in each environment and can push more code to production faster. For example, they don’t have to pause pushing code for monthly maintenance. Basically, EaaS is another building block every organization should have in their DevOps tool belt to allow the R&D department to deliver more without requiring additional resources. \n\n![](/blog-images/94d763d02b3c630507739be73eeb7155.png)\n\n### Conclusion\n\nEnvironments are an integral part of software development. As software progresses from development to production, it goes through different environments along the way, each with its own purpose. Per its purpose, each environment offers a certain level of performance, access control, code version, and database content. Provisioning and managing environments manually is time consuming and resource intensive. So are creating VMs or containers, setting up networking, adding SSL certificates, providing access control and so forth. EaaS tools have emerged to solve those issues. They provide environment provisioning with a click, an unlimited number of environments, central management, and more. [Eliminating the bottleneck of environment management](https://release.com/blog/increase-developer-velocity-by-removing-environment-bottlenecks) will allow every R&D team to increase development velocity and produce more with the same amount of resources.\n",
    "code": "var Component=(()=>{var h=Object.create;var a=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var f=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),g=(t,e)=>{for(var o in e)a(t,o,{get:e[o],enumerable:!0})},r=(t,e,o,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of p(e))!v.call(t,i)&&i!==o&&a(t,i,{get:()=>e[i],enumerable:!(s=m(e,i))||s.enumerable});return t};var b=(t,e,o)=>(o=t!=null?h(u(t)):{},r(e||!t||!t.__esModule?a(o,\"default\",{value:t,enumerable:!0}):o,t)),w=t=>r(a({},\"__esModule\",{value:!0}),t);var l=f((N,c)=>{c.exports=_jsx_runtime});var C={};g(C,{default:()=>I,frontmatter:()=>y});var n=b(l()),y={title:\"A Simple Guide to Software Environments\",summary:\"Learn about tools to scope and limit instances of your software as it progresses from development to a finished product.\",publishDate:\"Tue Apr 11 2023 21:10:39 GMT+0000 (Coordinated Universal Time)\",author:\"alexander-fridman\",readingTime:5,categories:[\"platform-engineering\",\"product\"],mainImage:\"/blog-images/b3927fc80db8ab1869298638402348e7.png\",imageAlt:\"A Simple Guide to Software Environments\",showCTA:!0,ctaCopy:\"Empower developers to streamline software environments from local to production with Release's on-demand, full-stack environments.\",ctaLink:\"https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=a-simple-guide-to-software-environments\",relatedPosts:[\"\"],ogImage:\"/blog-images/b3927fc80db8ab1869298638402348e7.png\",excerpt:\"Learn about tools to scope and limit instances of your software as it progresses from development to a finished product.\",tags:[\"platform-engineering\",\"product\"],ctaButton:\"Try Release for Free\"};function d(t){let e=Object.assign({h3:\"h3\",a:\"a\",span:\"span\",p:\"p\",ul:\"ul\",li:\"li\",img:\"img\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.h3,{id:\"introduction\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#introduction\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Introduction\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Building software is hard. It takes a lot of time and effort and it\\u2019s a somewhat cumbersome process. Software development passes through various stages in the product lifecycle before it reaches the end user. A spec must be defined, developers have to code the product, QA has to test it, and DevOps engineers have to deploy it. During this process, the code passes through several environments, from the developers\\u2019 local PC to containers in the cloud.\\xA0\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"what-are-software-environments\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#what-are-software-environments\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"What Are Software Environments\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Software environments are tools to scope and limit instances of your software as it progresses from development to a customer facing product. Each environment contains the following:\\xA0\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Copy of your software code\"}),`\n`,(0,n.jsx)(e.li,{children:\"Copy of the database tables you use with (possibly) environment-specific data\"}),`\n`,(0,n.jsx)(e.li,{children:\"Internal network so the different microservices your code uses can communicate with each other and with external services\"}),`\n`,(0,n.jsx)(e.li,{children:\"Global values (environment variables)\"}),`\n`,(0,n.jsx)(e.li,{children:\"Access control to limit who can view the application and make changes to it in the specific environment\"}),`\n`,(0,n.jsx)(e.li,{children:\"Infrastructure to support it (servers and such)\"}),`\n`,(0,n.jsx)(e.li,{children:\"Testing software to test the code\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Let's elaborate by giving specific examples of different environments.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/1897df55a97102dba7c22d77ec9fd988.jpeg\",alt:\"A computer sits on a window sillDescription automatically generated with medium confidence\"})}),`\n`,(0,n.jsxs)(e.h3,{id:\"local-environment\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#local-environment\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Local Environment\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The local environment is where a developer writes software code. They may be writing the whole application or just a specific feature for the application. The developer usually has a local database that works with the application code, and sometimes access to external microservices needed by the code. In other scenarios, where direct access from the developer\\u2019s laptop to external services is not possible, we use software mocks instead. When the app runs locally on the developer\\u2019s laptop, performance of the app in terms of CPU and RAM is low, compared with running it on a dedicated server or in other environments. In addition, there\\u2019s no access control for this environment. Anyone who can access the laptop has access to the application. On the other hand, it's the simplest and most immediate way to develop and test code.\\xA0\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"development-environment\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#development-environment\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Development Environment\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The development environment is where multiple developers upload their code to. It\\u2019s meant to be the first place where other stakeholders can test the code and the application\\u2019s different features. Developers merge the code and run a CI/CD pipeline here. The \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/CI/CD\",children:\"CI/CD pipeline\"}),\" usually consists of the following steps:\\xA0\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Changes to the database (database migrations)\"}),`\n`,(0,n.jsx)(e.li,{children:\"Static code analysis\"}),`\n`,(0,n.jsx)(e.li,{children:\"Vulnerability scanning\"}),`\n`,(0,n.jsx)(e.li,{children:\"Deployment to the development environment of the end artifact (JAR in Java or a binary)\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"In addition, this environment has more robust and thorough tests than those a developer runs on their laptop (e.g., integration tests). Developers apply the latest updates to the application in the development environment. Because it\\u2019s constantly being updated, the application is not stable in the development environment. It has a dedicated URL, environment variables, and better performance than versions run on individual developers\\u2019 local PCs. Usually all the developers on the team have access to this the development environment and to its database, which are not accessible outside of the organization (to clients, for instance).\\xA0\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"staging-environment\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#staging-environment\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Staging Environment\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The staging environment is the next environment the software passes through before it\\u2019s made accessible to end users. The staging environment should be very similar to the production environment, mirroring it as accurately as possible, because its purpose is to be the last checkpoint before making the latest software publicly available. It should run on the same infrastructure, have the same database content, and the same environment variables (or as similar as possible) to those in the production environment.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/d163f05b3191007407e8aa9e95e7728d.png\",alt:\"\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Traditionally, the CI/CD pipeline that runs in the staging environment involves the most extensive testing of all the environments. All stakeholders in the organization have access to view this environment, but only a handful of key employees have direct access to modify it (IT team, DevOps, senior developers). It's a stable environment and after the code passes the tests, it will be deployed to production. However, recently companies started shifting testing to the left and conducting robust testing earlier in the cycle.\\xA0\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"production-environment\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#production-environment\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Production Environment\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The production environment runs the code that serves end users \\u2014 your customers. It's a stable environment with powerful infrastructure that can handle spikes in demand and has extensive monitoring and logging. Unlike in other environments, down time here results in an immediate service outage. To protect the infrastructure, environment variables, database, and code, access to the production environment is usually restricted to only system administrators. Because automatic tests can reduce performance and change the database, no tests are run in the production environment.\\xA0\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"customer-demo--customer-specific-environment\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#customer-demo--customer-specific-environment\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Customer Demo / Customer Specific Environment\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"It sometimes happens that you want to create a version of your software specific to a certain client or to demonstrate a certain feature before it\\u2019s available to customers. This happens in the \",(0,n.jsx)(e.a,{href:\"https://release.com/blog/great-saas-sales-demos\",children:\"customer demo environment\"}),\". It has all the bells and whistles of the production environment, but it might have a superset or subset of features from the production environment and a client-specific GUI or dedicated access control, relevant to one client only.\\xA0\"]}),`\n`,(0,n.jsxs)(e.h3,{id:\"environment-pain-points\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#environment-pain-points\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Environment Pain Points\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Provisioning environments is difficult and time consuming. Provisioning new environments requires servers, a deployment mechanism, design of CI/CD pipelines, database servers, access control definitions and so forth. In addition, every environment consumes significant resources to maintain it. For instance, the IT team needs to make sure that connectivity works as expected, make snapshots of the database, edit the list of stakeholders who have access to each environment, and so on.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/b84ab91f3b3c2644c684fc86f02766c0.jpeg\",alt:\"A person holding a cigaretteDescription automatically generated with low confidence\"})}),`\n`,(0,n.jsxs)(e.h3,{id:\"easing-pain-points\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#easing-pain-points\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Easing Pain Points\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Recently, new products that provide \",(0,n.jsx)(e.a,{href:\"https://release.com/blog/environments-as-a-service-eaas-top-3-benefits\",children:\"environments as a service (EaaS)\"}),\" appeared on the market to address those pain points. They provide an unlimited number of automated environments with the click of a button, centralized management of environments, and a lower overhead for making changes to existing environments.\\xA0\"]}),`\n`,(0,n.jsxs)(e.h3,{id:\"increased-velocity\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#increased-velocity\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Increased Velocity\"]}),`\n`,(0,n.jsx)(e.p,{children:\"In addition to simplifying and speeding up environment deployment, EaaS solutions facilitate increased velocity of the R&D process as a whole because developers can spend less time in each environment and can push more code to production faster. For example, they don\\u2019t have to pause pushing code for monthly maintenance. Basically, EaaS is another building block every organization should have in their DevOps tool belt to allow the R&D department to deliver more without requiring additional resources.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/94d763d02b3c630507739be73eeb7155.png\",alt:\"\"})}),`\n`,(0,n.jsxs)(e.h3,{id:\"conclusion\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#conclusion\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Conclusion\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Environments are an integral part of software development. As software progresses from development to production, it goes through different environments along the way, each with its own purpose. Per its purpose, each environment offers a certain level of performance, access control, code version, and database content. Provisioning and managing environments manually is time consuming and resource intensive. So are creating VMs or containers, setting up networking, adding SSL certificates, providing access control and so forth. EaaS tools have emerged to solve those issues. They provide environment provisioning with a click, an unlimited number of environments, central management, and more. \",(0,n.jsx)(e.a,{href:\"https://release.com/blog/increase-developer-velocity-by-removing-environment-bottlenecks\",children:\"Eliminating the bottleneck of environment management\"}),\" will allow every R&D team to increase development velocity and produce more with the same amount of resources.\"]})]})}function k(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(d,t)})):d(t)}var I=k;return w(C);})();\n;return Component;"
  },
  "_id": "blog/posts/a-simple-guide-to-software-environments.mdx",
  "_raw": {
    "sourceFilePath": "blog/posts/a-simple-guide-to-software-environments.mdx",
    "sourceFileName": "a-simple-guide-to-software-environments.mdx",
    "sourceFileDir": "blog/posts",
    "contentType": "mdx",
    "flattenedPath": "blog/posts/a-simple-guide-to-software-environments"
  },
  "type": "BlogPost",
  "computedSlug": "a-simple-guide-to-software-environments"
}