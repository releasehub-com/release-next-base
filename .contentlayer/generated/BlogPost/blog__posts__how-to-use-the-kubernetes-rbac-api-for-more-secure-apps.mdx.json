{
  "title": "How to Use the Kubernetes RBAC API for More Secure Apps",
  "summary": "RBAC API gives permissions to an object in a Kubernetes cluster to improve governance & strengthen secuity.",
  "publishDate": "Fri Sep 30 2022 18:55:19 GMT+0000 (Coordinated Universal Time)",
  "author": "tommy-mcclung",
  "readingTime": 4,
  "categories": [
    "kubernetes",
    "platform-engineering"
  ],
  "mainImage": "/blog-images/514418c7a457bea6c774f627b909a699.jpg",
  "imageAlt": "Close-up of people shaking hands",
  "showCTA": true,
  "ctaCopy": "Unlock secure, on-demand Kubernetes environments with RBAC controls for streamlined app development and testing.",
  "ctaLink": "https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=how-to-use-the-kubernetes-rbac-api-for-more-secure-apps",
  "relatedPosts": [
    ""
  ],
  "ogImage": "/blog-images/514418c7a457bea6c774f627b909a699.jpg",
  "excerpt": "RBAC API gives permissions to an object in a Kubernetes cluster to improve governance & strengthen secuity.",
  "tags": [
    "kubernetes",
    "platform-engineering"
  ],
  "ctaButton": "Try Release for Free",
  "body": {
    "raw": "\nIf you manage a Kubernetes cluster, sooner or later, you'll need to assign roles and permissions to users so that everyone has visibility and access only to the resources they need. For example, some users must have read-only access, while others must only be able to write to certain resources or APIs. In addition, there must be users with unlimited access to all available resources. \n\nSuppose you have a team of four users: \n\n- Patricia: leader of the dev team\n- James: part of the dev team\n- Oliver: leader of the QA team\n- Amelia: part of the QA team\n\nJames works on one of the many projects within the company's cluster and therefore needs access to your namespace. Patricia, being the dev leader, needs full access to all projects. Oliver, likewise, needs full read access to all objects in the cluster. However, Amelia is working on the same project as James and can only have read access in this namespace. \n\nRole-based access control (RBAC) is an authorization mechanism built to handle such cases. In this article, we will discuss what RBAC API is and how you can use Kubernetes RBAC API to develop secure applications. \n\n![Close-up of people shaking handsDescription automatically generated](/blog-images/c86b1152882a95adcd1ae1ebf5677e4d.jpeg)\n\n### What is RBAC?\n\nThe concept of role-based access control is not something new. RBAC is based on the concepts of roles, permissions, and user groups, and it's one of the most widespread access control models being used in organizations today.  \n\nIn organizational use, RBAC allows you to create secure access models based on the real functions that people have within the organization rather than on the actions they must be able to perform. \n\n### What is the RBAC API, and how is it used in Kubernetes?\n\nKubernetes (as of version 1.6) introduced the concept of role-based access control as a system for distributing access rights to various objects in a Kubernetes cluster. \n\nObjects in a Kubernetes cluster are YAML manifests, and permissions determine which user can only view the manifests and who can create, modify, or even delete them. \n\nBefore we go into how RBAC works in Kubernetes, it's important to understand what a user is in Kubernetes. Everyone who sends requests to the API server is a user in a Kubernetes cluster. This means that not only administrators and developers are users, but also various CI/CD scripts and control plane, **kubelet**, and **kube-proxy** components on nodes are considered users.  \n\nThe RBAC model includes five entities:  \n\n- Role\n- RoleBinding\n- ClusterRole\n- ClusterRoleBinding\n- ServiceAccount\n\nLet's explore each entity in more detail. **‍**\n\n### Role\n\nThe **role** is a YAML manifest that describes a set of rights on Kubernetes cluster objects. \n\nHere it's important to understand that cluster objects are YAML manifests stored in **etcd**. The API server checks all rights as they relate to the requests that the API server receives.  \n\nIf you restrict the user to execute **kubectl exec**, but that user has access to the worker node, then they will not be able to block it from entering the worker node and doing docker exec in the RBAC container. \n\nWe can go to the cluster, and in **ns ingress-nginx**, look at the **role: ingress-nginx**: \n\n```yaml\nkubectl get role -n ingress-nginx ingress-nginx -o yaml\n```\n\nHere we are interested in the rules section. This is a list of rules that describe access rights. \n\nIn each rule, we have three parameters. Let's look at an example: \n\n```yaml\n\napiGroups:\n  - extensions\n  - networking.k8s.io\n resources:\n  - ingresses\n verbs:\n  - get\n  - list\n  - watch\n\n```\n\nHere **apiGroups:** describes the manifest API group. If only the version is specified in apiVersion—without a group, for example, as in the Pod manifest—then this manifest is considered to have the so-called root group (core-group). In the role, the root group is specified as an empty string. \n\nThe **resources:** parameter refers to a list of resources to which we describe access. You can view the list of resources in your cluster with the command **kubectl api-resources**. Some sub-resources describe specific actions. For example, the **pods/log** sub-resource allows you to view container logs in a pod.  \n\nThe **verbs:** parameter is a list of actions that you can perform on the resources described above: get, view the list, monitor changes, edit, delete, etc. \n\n### RoleBinding\n\nLet's now look at the **RoleBinding** manifest: \n\n```yaml\nkubectl get rolebinding ingress-nginx -n ingress-nginx -o yaml\n```\n\nIt has two types of fields: **roleRef** and **subjects:** \n\n```yaml\n\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: ingress-nginx\nsubjects:\n- kind: ServiceAccount\n  name: ingress-nginx\n  namespace: ingress-nginx\n- kind: User\n  name: jane              # \"name\" is case sensitive\n  apiGroup: rbac.authorization.k8s.io\n- kind: Group\n  name: developer      \n  apiGroup: rbac.authorization.k8s.io\n\n```\n\nHere's what we have: \n\n- **roleRef** specifies the role.\n- **subjects** specifies who will be assigned this role.\n- **kind** specifies permissions for requests not authenticated through a token from the service account.\n\n### ClusterRole\n\nThe **role** entity is namespace dependent and we can create roles with the same name in different namespaces. While **ClusterRole** is a cluster object, this entity describes the rights to objects in the entire cluster. \n\nKubernetes has many preconfigured cluster roles. These include the **admin**, **edit**, and **view** roles, which describe the rights that allow administrating, editing, or only viewing entities. If you have administrator rights, you can view the role in your cluster with the following command: \n\n```yaml\nkubectl get clusterrole edit -o yaml\n```\n\n### ClusterRoleBinding\n\nRoleBinding only gives access to entities in the same namespace as the RoleBinding manifest. **ClusterRoleBinding** allows you to grant access to entities in all cluster namespaces simultaneously. \n\n### Service Account\n\nKubernetes knows nothing about users in the form we are used to seeing them in when it comes to other access restriction systems, where users have a login or a password. Still, it has mechanisms for calling external password verification services, such as **oidc**, a user certificate verification option, or even the usual HTTP basic auth with the classic Apache file **htpasswd**. \n\n‍**ServiceAccount** was created primarily to limit the rights of applications that run in a cluster. All communication between cluster components goes through requests to the API server, and a special JWT token just authorizes each such request. This token is automatically generated when an object of the **ServiceAccount** type is created and placed in [secret.](https://release.com/blog/kubernetes-secrets-management-a-practical-guide)  \n\n### How to use RBAC API in Kubernetes\n\n[RBAC authorization](https://kubernetes.io/docs/reference/access-authn-authz/rbac/) is one way to assign roles to users in a Kubernetes cluster. Here are the steps: \n\n1\\. Connect the [service account token](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/). Without this token, you will need to re-download **kubeconfig** after any change in roles. \n\n2\\. Assign roles. Here's an example manifest that creates two namespaces and two users, each of which will only be able to [manage pods](https://release.com/blog/kubernetes-pod-a-beginners-guide-to-an-essential-resource) in their own namespace: \n\n```yaml\n\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: test-one\n---\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: test-two\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: read-pods-one\n  namespace: test-one\nsubjects:\n- kind: ServiceAccount\n  name: test-sa-one\n  apiGroup: \"\"\nroleRef:\n  kind: Role\n  name: pod-reader-one\n  apiGroup: rbac.authorization.k8s.io\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: read-pods-two\n  namespace: test-two\nsubjects:\n- kind: ServiceAccount\n  name: test-sa-two\n  apiGroup: \"\"\nroleRef:\n  kind: Role\n  name: pod-reader-two\n  apiGroup: rbac.authorization.k8s.io\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  namespace: test-one\n  name: pod-reader-one\nrules:\n- apiGroups: [\"\"] # \"\" indicates the core API group\n  resources: [\"pods\"]\n  verbs: [\"get\", \"watch\", \"list\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  namespace: test-two\n  name: pod-reader-two\nrules:\n- apiGroups: [\"\"] # \"\" indicates the core API group\n  resources: [\"pods\"]\n  verbs: [\"get\", \"watch\", \"list\"]\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  namespace: test-one\n  name: test-sa-one\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  namespace: test-two\n  name: test-sa-twoRun the manifest.\n\n```\n\n3\\. Run the manifest.\n\n4\\. Create tokens: \n\n```yaml\nkubectl get secret $(kubectl get serviceaccount test-sa-one -o jsonpath='{.secrets[0].name}' --namespace test-one) -o jsonpath='{.data.token}' --namespace test-one | base64 -d\n\nkubectl get secret $(kubectl get serviceaccount test-sa-two -o jsonpath='{.secrets[0].name}' --namespace test-two) -o jsonpath='{.data.token}' --namespace test-two | base64 -d\n```\n\n5\\. Manually add tokens to users in the **kubeconfig.yaml** file for authorization without a password: \n\n```yaml\n\nusers:\n...\n- name: test-sa-one\nuser:\n  token:\n- name: test-sa-two\nuser:\n  token:\n...\n\n```\n\n6\\. Check the distribution of roles: \n\n```yaml\n\nkubectl config set-context --current --user=test-sa-two\nContext \"admin@kubernetes\" modified.\n\nkubectl get pods --namespace test-two\nNo resources found in test-two namespace.\n\nkubectl get pods --namespace test-one\nError from server (Forbidden): pods is forbidden: User \"system:serviceaccount:test-two:test-sa-two\" cannot list resource \"pods\" in API group \"\" in the namespace \"test-one\"\n________\n\nkubectl config set-context --current --user=test-sa-one\nContext \"admin@kubernetes\" modified.\n\nkubectl get pods --namespace test-two\nError from server (Forbidden): pods is forbidden: User \"system:serviceaccount:test-one:test-sa-one\" cannot list resource \"pods\" in API group \"\" in the namespace \"test-two\"\n\nkubectl get pods --namespace test-one\nNo resources found in test-one namespace.\n\n```\n\nThe test-sa-two user now has access to pods in the **test-two** namespace and no access to the **test-one** namespace. Similarly, the \"test-sa-one\" user has access to pods in the **test-one** namespace but not those in the **test-two** namespace.\n\n### Kubernetes RBAC as a Security Strategy\n\nThe RBAC model has proved particularly effective for managing roles and is now considered a Kubernetes security best practice.  \n\nRBAC reduces the risk of unwanted access to critical resources and allows you to implement the principle of least privilege by giving access to only needed resources, which makes your cluster more secure.  \n\nMoreover, if you are using RBAC, you don't have to check the individual permissions assigned to each user. You can monitor who has access to resources simply by consulting roles, which makes auditing easier. \n\n### Conclusion\n\nIn summary, RBAC API is a role-based approach to giving permissions to an object in a Kubernetes cluster. By making it part of the Kubernetes pipeline, you can improve governance and significantly strengthen security.\n",
    "code": "var Component=(()=>{var d=Object.create;var i=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var b=(s,e)=>()=>(e||s((e={exports:{}}).exports,e),e.exports),f=(s,e)=>{for(var t in e)i(s,t,{get:e[t],enumerable:!0})},o=(s,e,t,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of p(e))!g.call(s,r)&&r!==t&&i(s,r,{get:()=>e[r],enumerable:!(a=u(e,r))||a.enumerable});return s};var w=(s,e,t)=>(t=s!=null?d(m(s)):{},o(e||!s||!s.__esModule?i(t,\"default\",{value:s,enumerable:!0}):t,s)),k=s=>o(i({},\"__esModule\",{value:!0}),s);var l=b((j,c)=>{c.exports=_jsx_runtime});var R={};f(R,{default:()=>A,frontmatter:()=>v});var n=w(l()),v={title:\"How to Use the Kubernetes RBAC API for More Secure Apps\",summary:\"RBAC API gives permissions to an object in a Kubernetes cluster to improve governance & strengthen secuity.\",publishDate:\"Fri Sep 30 2022 18:55:19 GMT+0000 (Coordinated Universal Time)\",author:\"tommy-mcclung\",readingTime:4,categories:[\"kubernetes\",\"platform-engineering\"],mainImage:\"/blog-images/514418c7a457bea6c774f627b909a699.jpg\",imageAlt:\"Close-up of people shaking hands\",showCTA:!0,ctaCopy:\"Unlock secure, on-demand Kubernetes environments with RBAC controls for streamlined app development and testing.\",ctaLink:\"https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=how-to-use-the-kubernetes-rbac-api-for-more-secure-apps\",relatedPosts:[\"\"],ogImage:\"/blog-images/514418c7a457bea6c774f627b909a699.jpg\",excerpt:\"RBAC API gives permissions to an object in a Kubernetes cluster to improve governance & strengthen secuity.\",tags:[\"kubernetes\",\"platform-engineering\"],ctaButton:\"Try Release for Free\"};function h(s){let e=Object.assign({p:\"p\",ul:\"ul\",li:\"li\",img:\"img\",h3:\"h3\",a:\"a\",span:\"span\",strong:\"strong\",pre:\"pre\",code:\"code\"},s.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"If you manage a Kubernetes cluster, sooner or later, you'll need to assign roles and permissions to users so that everyone has visibility and access only to the resources they need. For example, some users must have read-only access, while others must only be able to write to certain resources or APIs. In addition, there must be users with unlimited access to all available resources.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"Suppose you have a team of four users:\\xA0\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Patricia: leader of the dev team\"}),`\n`,(0,n.jsx)(e.li,{children:\"James: part of the dev team\"}),`\n`,(0,n.jsx)(e.li,{children:\"Oliver: leader of the QA team\"}),`\n`,(0,n.jsx)(e.li,{children:\"Amelia: part of the QA team\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"James works on one of the many projects within the company's cluster and therefore needs access to your namespace. Patricia, being the dev leader, needs full access to all projects. Oliver, likewise, needs full read access to all objects in the cluster. However, Amelia is working on the same project as James and can only have read access in this namespace.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"Role-based access control (RBAC) is an authorization mechanism built to handle such cases. In this article, we will discuss what RBAC API is and how you can use Kubernetes RBAC API to develop secure applications.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/c86b1152882a95adcd1ae1ebf5677e4d.jpeg\",alt:\"Close-up of people shaking handsDescription automatically generated\"})}),`\n`,(0,n.jsxs)(e.h3,{id:\"what-is-rbac\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#what-is-rbac\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"What is RBAC?\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The concept of role-based access control is not something new. RBAC is based on the concepts of roles, permissions, and user groups, and it's one of the most widespread access control models being used in organizations today. \\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"In organizational use, RBAC allows you to create secure access models based on the real functions that people have within the organization rather than on the actions they must be able to perform.\\xA0\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"what-is-the-rbac-api-and-how-is-it-used-in-kubernetes\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#what-is-the-rbac-api-and-how-is-it-used-in-kubernetes\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"What is the RBAC API, and how is it used in Kubernetes?\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Kubernetes (as of version 1.6) introduced the concept of role-based access control as a system for distributing access rights to various objects in a Kubernetes cluster.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"Objects in a Kubernetes cluster are YAML manifests, and permissions determine which user can only view the manifests and who can create, modify, or even delete them.\\xA0\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Before we go into how RBAC works in Kubernetes, it's important to understand what a user is in Kubernetes. Everyone who sends requests to the API server is a user in a Kubernetes cluster. This means that not only administrators and developers are users, but also various CI/CD scripts and control plane, \",(0,n.jsx)(e.strong,{children:\"kubelet\"}),\", and \",(0,n.jsx)(e.strong,{children:\"kube-proxy\"}),\" components on nodes are considered users. \\xA0\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The RBAC model includes five entities: \\xA0\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Role\"}),`\n`,(0,n.jsx)(e.li,{children:\"RoleBinding\"}),`\n`,(0,n.jsx)(e.li,{children:\"ClusterRole\"}),`\n`,(0,n.jsx)(e.li,{children:\"ClusterRoleBinding\"}),`\n`,(0,n.jsx)(e.li,{children:\"ServiceAccount\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Let's explore each entity in more detail.\\xA0\",(0,n.jsx)(e.strong,{children:\"\\u200D\"})]}),`\n`,(0,n.jsxs)(e.h3,{id:\"role\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#role\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Role\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.strong,{children:\"role\"}),\" is a YAML manifest that describes a set of rights on Kubernetes cluster objects.\\xA0\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Here it's important to understand that cluster objects are YAML manifests stored in \",(0,n.jsx)(e.strong,{children:\"etcd\"}),\". The API server checks all rights as they relate to the requests that the API server receives. \\xA0\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"If you restrict the user to execute \",(0,n.jsx)(e.strong,{children:\"kubectl exec\"}),\", but that user has access to the worker node, then they will not be able to block it from entering the worker node and doing docker exec in the RBAC container.\\xA0\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"We can go to the cluster, and in \",(0,n.jsx)(e.strong,{children:\"ns ingress-nginx\"}),\", look at the \",(0,n.jsx)(e.strong,{children:\"role: ingress-nginx\"}),\":\\xA0\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`kubectl get role -n ingress-nginx ingress-nginx -o yaml\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Here we are interested in the rules section. This is a list of rules that describe access rights.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"In each rule, we have three parameters. Let's look at an example:\\xA0\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`\napiGroups:\n \\xA0- extensions\n \\xA0- networking.k8s.io\n resources:\n \\xA0- ingresses\n verbs:\n \\xA0- get\n \\xA0- list\n \\xA0- watch\n\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Here \",(0,n.jsx)(e.strong,{children:\"apiGroups:\"}),\" describes the manifest API group. If only the version is specified in apiVersion\\u2014without a group, for example, as in the Pod manifest\\u2014then this manifest is considered to have the so-called root group (core-group). In the role, the root group is specified as an empty string.\\xA0\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.strong,{children:\"resources:\"}),\" parameter refers to a list of resources to which we describe access. You can view the list of resources in your cluster with the command \",(0,n.jsx)(e.strong,{children:\"kubectl api-resources\"}),\". Some sub-resources describe specific actions. For example, the \",(0,n.jsx)(e.strong,{children:\"pods/log\"}),\" sub-resource allows you to view container logs in a pod. \\xA0\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.strong,{children:\"verbs:\"}),\" parameter is a list of actions that you can perform on the resources described above: get, view the list, monitor changes, edit, delete, etc.\\xA0\"]}),`\n`,(0,n.jsxs)(e.h3,{id:\"rolebinding\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#rolebinding\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"RoleBinding\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Let's now look at the \",(0,n.jsx)(e.strong,{children:\"RoleBinding\"}),\" manifest:\\xA0\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`kubectl get rolebinding ingress-nginx -n ingress-nginx -o yaml\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"It has two types of fields: \",(0,n.jsx)(e.strong,{children:\"roleRef\"}),\" and \",(0,n.jsx)(e.strong,{children:\"subjects:\"}),\"\\xA0\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`\nroleRef:\n \\xA0apiGroup: rbac.authorization.k8s.io\n \\xA0kind: Role\n \\xA0name: ingress-nginx\nsubjects:\n- kind: ServiceAccount\n \\xA0name: ingress-nginx\n \\xA0namespace: ingress-nginx\n- kind: User\n \\xA0name: jane \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0# \"name\" is case sensitive\n \\xA0apiGroup: rbac.authorization.k8s.io\n- kind: Group\n \\xA0name: developer \\xA0 \\xA0 \\xA0\n \\xA0apiGroup: rbac.authorization.k8s.io\n\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Here's what we have:\\xA0\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"roleRef\"}),\" specifies the role.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"subjects\"}),\" specifies who will be assigned this role.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"kind\"}),\" specifies permissions for requests not authenticated through a token from the service account.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.h3,{id:\"clusterrole\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#clusterrole\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"ClusterRole\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.strong,{children:\"role\"}),\" entity is namespace dependent and we can create roles with the same name in different namespaces. While \",(0,n.jsx)(e.strong,{children:\"ClusterRole\"}),\" is a cluster object, this entity describes the rights to objects in the entire cluster.\\xA0\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Kubernetes has many preconfigured cluster roles. These include the \",(0,n.jsx)(e.strong,{children:\"admin\"}),\", \",(0,n.jsx)(e.strong,{children:\"edit\"}),\", and \",(0,n.jsx)(e.strong,{children:\"view\"}),\" roles, which describe the rights that allow administrating, editing, or only viewing entities. If you have administrator rights, you can view the role in your cluster with the following command:\\xA0\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`kubectl get clusterrole edit -o yaml\n`})}),`\n`,(0,n.jsxs)(e.h3,{id:\"clusterrolebinding\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#clusterrolebinding\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"ClusterRoleBinding\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"RoleBinding only gives access to entities in the same namespace as the RoleBinding manifest. \",(0,n.jsx)(e.strong,{children:\"ClusterRoleBinding\"}),\" allows you to grant access to entities in all cluster namespaces simultaneously.\\xA0\"]}),`\n`,(0,n.jsxs)(e.h3,{id:\"service-account\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#service-account\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Service Account\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Kubernetes knows nothing about users in the form we are used to seeing them in when it comes to other access restriction systems, where users have a login or a password. Still, it has mechanisms for calling external password verification services, such as \",(0,n.jsx)(e.strong,{children:\"oidc\"}),\", a user certificate verification option, or even the usual HTTP basic auth with the classic Apache file \",(0,n.jsx)(e.strong,{children:\"htpasswd\"}),\".\\xA0\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"\\u200D\",(0,n.jsx)(e.strong,{children:\"ServiceAccount\"}),\" was created primarily to limit the rights of applications that run in a cluster. All communication between cluster components goes through requests to the API server, and a special JWT token just authorizes each such request. This token is automatically generated when an object of the \",(0,n.jsx)(e.strong,{children:\"ServiceAccount\"}),\" type is created and placed in \",(0,n.jsx)(e.a,{href:\"https://release.com/blog/kubernetes-secrets-management-a-practical-guide\",children:\"secret.\"}),\" \\xA0\"]}),`\n`,(0,n.jsxs)(e.h3,{id:\"how-to-use-rbac-api-in-kubernetes\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#how-to-use-rbac-api-in-kubernetes\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"How to use RBAC API in Kubernetes\"]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.a,{href:\"https://kubernetes.io/docs/reference/access-authn-authz/rbac/\",children:\"RBAC authorization\"}),\" is one way to assign roles to users in a Kubernetes cluster. Here are the steps:\\xA0\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"1. Connect the \",(0,n.jsx)(e.a,{href:\"https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/\",children:\"service account token\"}),\". Without this token, you will need to re-download \",(0,n.jsx)(e.strong,{children:\"kubeconfig\"}),\" after any change in roles.\\xA0\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"2. Assign roles. Here's an example manifest that creates two namespaces and two users, each of which will only be able to \",(0,n.jsx)(e.a,{href:\"https://release.com/blog/kubernetes-pod-a-beginners-guide-to-an-essential-resource\",children:\"manage pods\"}),\" in their own namespace:\\xA0\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`\napiVersion: v1\nkind: Namespace\nmetadata:\n \\xA0name: test-one\n---\napiVersion: v1\nkind: Namespace\nmetadata:\n \\xA0name: test-two\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n \\xA0name: read-pods-one\n \\xA0namespace: test-one\nsubjects:\n- kind: ServiceAccount\n \\xA0name: test-sa-one\n \\xA0apiGroup: \"\"\nroleRef:\n \\xA0kind: Role\n \\xA0name: pod-reader-one\n \\xA0apiGroup: rbac.authorization.k8s.io\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n \\xA0name: read-pods-two\n \\xA0namespace: test-two\nsubjects:\n- kind: ServiceAccount\n \\xA0name: test-sa-two\n \\xA0apiGroup: \"\"\nroleRef:\n \\xA0kind: Role\n \\xA0name: pod-reader-two\n \\xA0apiGroup: rbac.authorization.k8s.io\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n \\xA0namespace: test-one\n \\xA0name: pod-reader-one\nrules:\n- apiGroups: [\"\"] # \"\" indicates the core API group\n \\xA0resources: [\"pods\"]\n \\xA0verbs: [\"get\", \"watch\", \"list\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n \\xA0namespace: test-two\n \\xA0name: pod-reader-two\nrules:\n- apiGroups: [\"\"] # \"\" indicates the core API group\n \\xA0resources: [\"pods\"]\n \\xA0verbs: [\"get\", \"watch\", \"list\"]\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n \\xA0namespace: test-one\n \\xA0name: test-sa-one\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n \\xA0namespace: test-two\n \\xA0name: test-sa-twoRun the manifest.\n\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"3. Run the manifest.\"}),`\n`,(0,n.jsx)(e.p,{children:\"4. Create tokens:\\xA0\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`kubectl get secret $(kubectl get serviceaccount test-sa-one -o jsonpath='{.secrets[0].name}' --namespace test-one) -o jsonpath='{.data.token}' --namespace test-one | base64 -d\n\nkubectl get secret $(kubectl get serviceaccount test-sa-two -o jsonpath='{.secrets[0].name}' --namespace test-two) -o jsonpath='{.data.token}' --namespace test-two | base64 -d\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"5. Manually add tokens to users in the \",(0,n.jsx)(e.strong,{children:\"kubeconfig.yaml\"}),\" file for authorization without a password:\\xA0\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`\nusers:\n...\n- name: test-sa-one\nuser:\n \\xA0token:\n- name: test-sa-two\nuser:\n \\xA0token:\n...\n\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"6. Check the distribution of roles:\\xA0\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`\nkubectl config set-context --current --user=test-sa-two\nContext \"admin@kubernetes\" modified.\n\nkubectl get pods --namespace test-two\nNo resources found in test-two namespace.\n\nkubectl get pods --namespace test-one\nError from server (Forbidden): pods is forbidden: User \"system:serviceaccount:test-two:test-sa-two\" cannot list resource \"pods\" in API group \"\" in the namespace \"test-one\"\n________\n\nkubectl config set-context --current --user=test-sa-one\nContext \"admin@kubernetes\" modified.\n\nkubectl get pods --namespace test-two\nError from server (Forbidden): pods is forbidden: User \"system:serviceaccount:test-one:test-sa-one\" cannot list resource \"pods\" in API group \"\" in the namespace \"test-two\"\n\nkubectl get pods --namespace test-one\nNo resources found in test-one namespace.\n\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The test-sa-two user now has access to pods in the \",(0,n.jsx)(e.strong,{children:\"test-two\"}),\" namespace and no access to the \",(0,n.jsx)(e.strong,{children:\"test-one\"}),' namespace. Similarly, the \"test-sa-one\" user has access to pods in the ',(0,n.jsx)(e.strong,{children:\"test-one\"}),\" namespace but not those in the \",(0,n.jsx)(e.strong,{children:\"test-two\"}),\" namespace.\"]}),`\n`,(0,n.jsxs)(e.h3,{id:\"kubernetes-rbac-as-a-security-strategy\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#kubernetes-rbac-as-a-security-strategy\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Kubernetes RBAC as a Security Strategy\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The RBAC model has proved particularly effective for managing roles and is now considered a Kubernetes security best practice. \\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"RBAC reduces the risk of unwanted access to critical resources and allows you to implement the principle of least privilege by giving access to only needed resources, which makes your cluster more secure. \\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"Moreover, if you are using RBAC, you don't have to check the individual permissions assigned to each user. You can monitor who has access to resources simply by consulting roles, which makes auditing easier.\\xA0\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"conclusion\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#conclusion\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Conclusion\"]}),`\n`,(0,n.jsx)(e.p,{children:\"In summary, RBAC API is a role-based approach to giving permissions to an object in a Kubernetes cluster. By making it part of the Kubernetes pipeline, you can improve governance and significantly strengthen security.\"})]})}function y(s={}){let{wrapper:e}=s.components||{};return e?(0,n.jsx)(e,Object.assign({},s,{children:(0,n.jsx)(h,s)})):h(s)}var A=y;return k(R);})();\n;return Component;"
  },
  "_id": "blog/posts/how-to-use-the-kubernetes-rbac-api-for-more-secure-apps.mdx",
  "_raw": {
    "sourceFilePath": "blog/posts/how-to-use-the-kubernetes-rbac-api-for-more-secure-apps.mdx",
    "sourceFileName": "how-to-use-the-kubernetes-rbac-api-for-more-secure-apps.mdx",
    "sourceFileDir": "blog/posts",
    "contentType": "mdx",
    "flattenedPath": "blog/posts/how-to-use-the-kubernetes-rbac-api-for-more-secure-apps"
  },
  "type": "BlogPost",
  "computedSlug": "how-to-use-the-kubernetes-rbac-api-for-more-secure-apps"
}