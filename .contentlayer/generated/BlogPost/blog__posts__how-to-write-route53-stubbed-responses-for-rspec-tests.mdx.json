{
  "title": "How To Write Route53 Stubbed Responses For Rspec Tests",
  "summary": "Short Example for writing AWS Ruby SDK unit tests for Route53 API calls with stubbed responses",
  "publishDate": "Thu Sep 09 2021 02:28:14 GMT+0000 (Coordinated Universal Time)",
  "author": "regis-wilson",
  "readingTime": 6,
  "categories": [
    "platform-engineering",
    "product"
  ],
  "mainImage": "/blog-images/be577b12dad97ecf46a4f0ff2cdd1d35.jpg",
  "imageAlt": "A person hands holding wires and making tests on a circuit board",
  "showCTA": true,
  "ctaCopy": "Automate your environment setup like testing AWS Route53 responses with Release's on-demand environments.",
  "ctaLink": "https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=how-to-write-route53-stubbed-responses-for-rspec-tests",
  "relatedPosts": [
    ""
  ],
  "ogImage": "/blog-images/be577b12dad97ecf46a4f0ff2cdd1d35.jpg",
  "excerpt": "Short Example for writing AWS Ruby SDK unit tests for Route53 API calls with stubbed responses",
  "tags": [
    "platform-engineering",
    "product"
  ],
  "ctaButton": "Try Release for Free",
  "body": {
    "raw": "\n### How to Write Route53 Stubbed Responses For Rspec Tests\n\nIn this blog post, I will go over a recent exercise to fix some bugs, refactor, and write tests for some of our code related to Route53. Route53 is an AWS service that creates, updates, and provides Domain Name Service (DNS) for the internet. The reason that code unit tests are so important is because it helps reveal bugs, creates supportable and high quality code, and allows restructuring and refactoring with confidence. The downside to writing unit tests is that it can be time consuming, difficult at times, and bloating to the normal code base. It is not uncommon for unit tests’ \"lines of code\" (LOC) count to far exceed the LOC for the actual codebase. You would not be crazy to have nearly an order of magnitude difference in LOC for actual codebase versus LOC for unit test cases.\n\nIn this case, interacting with the AWS Route53 API was daunting to test and stubbing responses seemed incredibly difficult until I found some examples written by another one of our engineers that showed how the rspec and API SDKs could be made to work in a fairly straightforward and (dare I say) downright fun method for unit testing Ruby code.\n\n### The Code Under Examination\n\nThis straightforward code snippet was my first target for unit testing. It is very simple and only does one thing. It is ripe for refactoring for readability and reusability for other sections of the code. This should be the best way to begin the project and get familiar with the rspec templates I’d be using later. Before I start refactoring and fixing bugs, I wanted to write tests. Other than the fairly “inliney” and hard to follow syntax and “magical” code, can you spot any bugs?\n\n```ruby line-numbers\n\ndef route53_hosted_zone_id(subdomain)\n  route53.list_hosted_zones_by_name.map do |response|\n    response.hosted_zones.detect{|zone| zone.name == \"#{subdomain}.\" }&.id&.gsub(/.*\\//, '')\n  end.flatten.compact.first\nend\n\n```\n\n### Write Helpers Before the Refactor\n\nI am already itching to remove the magical subdomain rewriting and gsub deleting into separate methods that can be reused and are easier to read:\n\n```ruby line-numbers\n\ndef cannonicalise(hostname)\n  hostname = domain_parts(hostname).join('.')\n\n  \"#{hostname}.\"\nend\n\ndef parse_hosted_zone_id(hosted_zone_id)\n  return nil if hosted_zone_id.blank?\n\n  hosted_zone_id.gsub(%r{.*/+}, '')\nend\n\n```\n\n### Stub and Test the New Methods\n\nFirst things first, we need to do a little bit of boilerplate to get the API calls mocked and stubbed, then add a few very simple tests to get started.\n\n```ruby line-numbers\n\n# frozen_string_literal: true\n\nrequire 'rails_helper'\n\nRSpec.describe Cloud::Aws::Route53 do\n  let(:route53) { Aws::Route53::Client.new(stub_responses: true) }\n\n  subject { FactoryBot.create(:v2_cloud_integration) }\n\n  before do\n    allow(subject).to receive(:route53).and_return(route53)\n  end\n\n  describe '#parse_hosted_zone_id' do\n    context 'with a valid hostedzone identifier' do\n      it 'returns just the zoneid' do\n        expect(subject.parse_hosted_zone_id('/hostedzone/Z1234ABC')).to eq('Z1234ABC')\n      end\n    end\n  end\n  describe '#cannonicalise' do\n    context 'without a dot' do\n      it 'returns the zone with a dot' do\n        expect(subject.cannonicalise('some.host')).to eq('some.host.')\n      end\n    end\n    context 'with a dot' do\n      it 'returns the zone with a dot' do\n        expect(subject.cannonicalise('some.host.')).to eq('some.host.')\n      end\n    end\n  end\nend\n\n```\n\n### Write A Fixture\n\nPerfect, now we can test our new **cannonicalise** and **parse_hosted_zone_id** methods and we have a stubbed response coming from the Route53 API calls. Let’s write a simple new test to uncover some bugs by testing the api responses we get. The first step is to write some fixtures we can test with. Here we generate two faked stubbed responses for a very [common domain](https://example.com).\n\n```ruby line-numbers\n\n  context 'an AWS cloud integration' do\n    before do\n      route53.stub_responses(:list_hosted_zones_by_name, {\n                               is_truncated: false,\n                               max_items: 100,\n                               hosted_zones: [\n                                 {\n                                   id: '/hostedzone/Z321EXAMPLE',\n                                   name: 'example.com.',\n                                   config: {\n                                     comment: 'Some comment 1',\n                                     private_zone: true\n                                   },\n                                   caller_reference: SecureRandom.hex\n                                 },\n                                 {\n                                   id: '/hostedzone/Z123EXAMPLE',\n                                   name: 'example.com.',\n                                   config: {\n                                     comment: 'Some comment 2',\n                                     private_zone: false\n                                   },\n                                   caller_reference: SecureRandom.hex\n                                 }\n                               ]\n                             })\n    end\nend\n\n```\n\nIf you’re wondering how to make these fixtures, you can easily read the [AWS Ruby SDK V3 documentation](https://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/Route53/Client.html#list_hosted_zones_by_name-instance_method) for sample inputs and outputs, or you can make API calls via the AWS CLI and inspect the responses, or you can even just put in some values and see what happens when you run rspec. For example, if I remove, say, the \\`caller_reference\\` parameter, I’ll get an error that helpfully identifies the problem.\n\n![](/blog-images/1533e9e3859e67cfef95708dd3aadb80.png)\n\nRemoving required parameters gives a helpful error message to correct the problem.\n\nYou really can’t go wrong with the SDK validation and stubbed responses taken from the examples or from live requests you make with the CLI! This is already a tremendous benefit and we’re not even testing our own code yet.\n\n### Write a Test Case with the Stubbed Responses\n\nNow we can write some unit test cases and loop through several responses that we expect to find the hosted zone. Voilá we’ve uncovered some bugs just by being a little creative with our inputs! Do you see why?\n\n```ruby line-numbers\n\ndescribe '#route53_hosted_zone_id' do\n  %w[\n    example.com\n    example.com.\n    www.example.com\n    www.example.com.\n    test.www.example.com\n    test.www.example.com.\n    deep.test.www.example.com\n  ].each do |hostname|\n    context 'for hosts that exist in the parent zone' do\n      it \"returns the hosted_zone_id for #{hostname}\" do\n        expect(route53).to receive(:list_hosted_zones_by_name).with(no_args).and_call_original\n        hosted_zone_id = subject.route53_hosted_zone_id(hostname)\n        expect(hosted_zone_id).to eq('Z123EXAMPLE')\n      end\n    end\n  end\nend\n\n```\n\n![](/blog-images/62c5d2015dd19e4280f0680a300995af.png)\n\nWith some creativity in test inputs and stubbed responses from the API, we can uncover some edge cases and bugs to fix!\n\nWhat these failed test cases are telling us is that the code worked under perfect conditions but in strange scenarios that may not be uncommon (for example, having an internal private zone and public zone with the same name, or selecting a two-level-deep name in a zone) could cause unpredictable behaviours.\n\n### The Solution is an Exercise for the Reader\n\nNow we merely need to write or refactor the code from our original snippet to pass all of our new test cases. One of the issues that our test cases revealed was that two-level-deep names (say, test.www.example.com in the zone example.com) would be missed. We also needed a way to ensure that zones are not private, perhaps with an optional parameter to specify private zones. Here is an example that passes all the existing tests and welcome feedback on any other bugs or optimisations you find.\n\n```ruby line-numbers\n\ndef route53_hosted_zone_ids_by_name(is_private_zone: false)\n  # TODO: danger, does not handle duplicate zone names!!!\n  hosted_zone_ids_by_name = {}\n  route53.list_hosted_zones_by_name.each do |response|\n    response.hosted_zones.each do |zone|\n      if !!zone.config.private_zone == is_private_zone\n        hosted_zone_ids_by_name[zone.name] = parse_hosted_zone_id(zone.id)\n      end\n    end\n  end\n  hosted_zone_ids_by_name\nend\n\ndef route53_hosted_zone_id(hostname)\n  # Recursively look for the zone id of the nearest parent (host, subdomain, or apex)\n  hosted_zone_ids_by_name = route53_hosted_zone_ids_by_name\n\n  loop do\n    hostname = cannonicalise(hostname)\n    break if hosted_zone_ids_by_name[hostname].present?\n\n    # Strip off one level and try again\n    hostname = domain_parts(hostname).drop(1).join('.')\n    break if hostname.blank?\n  end\n  hosted_zone_ids_by_name[hostname]\nend\n\n```\n\n### Congratulations\n\nAll test cases now pass! Keep writing tests until you get nearly 100% coverage!\n\n> Hero Image by [Jeswin Thomas](https://unsplash.com/@jeswinthomas?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/testing?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)\n",
    "code": "var Component=(()=>{var l=Object.create;var a=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),g=(t,e)=>{for(var o in e)a(t,o,{get:e[o],enumerable:!0})},i=(t,e,o,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of m(e))!f.call(t,s)&&s!==o&&a(t,s,{get:()=>e[s],enumerable:!(r=u(e,s))||r.enumerable});return t};var _=(t,e,o)=>(o=t!=null?l(p(t)):{},i(e||!t||!t.__esModule?a(o,\"default\",{value:t,enumerable:!0}):o,t)),w=t=>i(a({},\"__esModule\",{value:!0}),t);var c=b((R,d)=>{d.exports=_jsx_runtime});var v={};g(v,{default:()=>z,frontmatter:()=>y});var n=_(c()),y={title:\"How To Write Route53 Stubbed Responses For Rspec Tests\",summary:\"Short Example for writing AWS Ruby SDK unit tests for Route53 API calls with stubbed responses\",publishDate:\"Thu Sep 09 2021 02:28:14 GMT+0000 (Coordinated Universal Time)\",author:\"regis-wilson\",readingTime:6,categories:[\"platform-engineering\",\"product\"],mainImage:\"/blog-images/be577b12dad97ecf46a4f0ff2cdd1d35.jpg\",imageAlt:\"A person hands holding wires and making tests on a circuit board\",showCTA:!0,ctaCopy:\"Automate your environment setup like testing AWS Route53 responses with Release's on-demand environments.\",ctaLink:\"https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=how-to-write-route53-stubbed-responses-for-rspec-tests\",relatedPosts:[\"\"],ogImage:\"/blog-images/be577b12dad97ecf46a4f0ff2cdd1d35.jpg\",excerpt:\"Short Example for writing AWS Ruby SDK unit tests for Route53 API calls with stubbed responses\",tags:[\"platform-engineering\",\"product\"],ctaButton:\"Try Release for Free\"};function h(t){let e=Object.assign({h3:\"h3\",a:\"a\",span:\"span\",p:\"p\",pre:\"pre\",code:\"code\",strong:\"strong\",img:\"img\",blockquote:\"blockquote\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.h3,{id:\"how-to-write-route53-stubbed-responses-for-rspec-tests\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#how-to-write-route53-stubbed-responses-for-rspec-tests\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"How to Write Route53 Stubbed Responses For Rspec Tests\"]}),`\n`,(0,n.jsx)(e.p,{children:'In this blog post, I will go over a recent exercise to fix some bugs, refactor, and write tests for some of our code related to Route53. Route53 is an AWS service that creates, updates, and provides Domain Name Service (DNS) for the internet. The reason that code unit tests are so important is because it helps reveal bugs, creates supportable and high quality code, and allows restructuring and refactoring with confidence. The downside to writing unit tests is that it can be time consuming, difficult at times, and bloating to the normal code base. It is not uncommon for unit tests\\u2019 \"lines of code\" (LOC) count to far exceed the LOC for the actual codebase. You would not be crazy to have nearly an order of magnitude difference in LOC for actual codebase versus LOC\\xA0for unit test cases.'}),`\n`,(0,n.jsx)(e.p,{children:\"In this case, interacting with the AWS Route53 API was daunting to test and stubbing responses seemed incredibly difficult until I found some examples written by another one of our engineers that showed how the rspec and API SDKs could be made to work in a fairly straightforward and (dare I say) downright fun method for unit testing Ruby code.\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"the-code-under-examination\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#the-code-under-examination\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"The Code Under Examination\"]}),`\n`,(0,n.jsx)(e.p,{children:\"This straightforward code snippet was my first target for unit testing. It is very simple and only does one thing. It is ripe for refactoring for readability and reusability for other sections of the code. This should be the best way to begin the project and get familiar with the rspec templates I\\u2019d be using later. Before I start refactoring and fixing bugs, I wanted to write tests. Other than the fairly \\u201Cinliney\\u201D and hard to follow syntax and \\u201Cmagical\\u201D code, can you spot any bugs?\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ruby\",children:`\ndef route53_hosted_zone_id(subdomain)\n \\xA0route53.list_hosted_zones_by_name.map do |response|\n \\xA0 \\xA0response.hosted_zones.detect{|zone| zone.name == \"#{subdomain}.\" }&.id&.gsub(/.*\\\\//, '')\n \\xA0end.flatten.compact.first\nend\n\n`})}),`\n`,(0,n.jsxs)(e.h3,{id:\"write-helpers-before-the-refactor\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#write-helpers-before-the-refactor\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Write Helpers Before the Refactor\"]}),`\n`,(0,n.jsx)(e.p,{children:\"I am already itching to remove the magical subdomain rewriting and gsub deleting into separate methods that can be reused and are easier to read:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ruby\",children:`\ndef cannonicalise(hostname)\n \\xA0hostname = domain_parts(hostname).join('.')\n\n \\xA0\"#{hostname}.\"\nend\n\ndef parse_hosted_zone_id(hosted_zone_id)\n \\xA0return nil if hosted_zone_id.blank?\n\n \\xA0hosted_zone_id.gsub(%r{.*/+}, '')\nend\n\n`})}),`\n`,(0,n.jsxs)(e.h3,{id:\"stub-and-test-the-new-methods\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#stub-and-test-the-new-methods\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Stub and Test the New Methods\"]}),`\n`,(0,n.jsx)(e.p,{children:\"First things first, we need to do a little bit of boilerplate to get the API calls mocked and stubbed, then add a few very simple tests to get started.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ruby\",children:`\n# frozen_string_literal: true\n\nrequire 'rails_helper'\n\nRSpec.describe Cloud::Aws::Route53 do\n \\xA0let(:route53) { Aws::Route53::Client.new(stub_responses: true) }\n\n \\xA0subject { FactoryBot.create(:v2_cloud_integration) }\n\n \\xA0before do\n \\xA0 \\xA0allow(subject).to receive(:route53).and_return(route53)\n \\xA0end\n\n \\xA0describe '#parse_hosted_zone_id' do\n \\xA0 \\xA0context 'with a valid hostedzone identifier' do\n \\xA0 \\xA0 \\xA0it 'returns just the zoneid' do\n \\xA0 \\xA0 \\xA0 \\xA0expect(subject.parse_hosted_zone_id('/hostedzone/Z1234ABC')).to eq('Z1234ABC')\n \\xA0 \\xA0 \\xA0end\n \\xA0 \\xA0end\n \\xA0end\n \\xA0describe '#cannonicalise' do\n \\xA0 \\xA0context 'without a dot' do\n \\xA0 \\xA0 \\xA0it 'returns the zone with a dot' do\n \\xA0 \\xA0 \\xA0 \\xA0expect(subject.cannonicalise('some.host')).to eq('some.host.')\n \\xA0 \\xA0 \\xA0end\n \\xA0 \\xA0end\n \\xA0 \\xA0context 'with a dot' do\n \\xA0 \\xA0 \\xA0it 'returns the zone with a dot' do\n \\xA0 \\xA0 \\xA0 \\xA0expect(subject.cannonicalise('some.host.')).to eq('some.host.')\n \\xA0 \\xA0 \\xA0end\n \\xA0 \\xA0end\n \\xA0end\nend\n\n`})}),`\n`,(0,n.jsxs)(e.h3,{id:\"write-a-fixture\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#write-a-fixture\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Write A Fixture\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Perfect, now we can test our new \",(0,n.jsx)(e.strong,{children:\"cannonicalise\"}),\" and \",(0,n.jsx)(e.strong,{children:\"parse_hosted_zone_id\"}),\" methods and we have a stubbed response coming from the Route53 API calls. Let\\u2019s write a simple new test to uncover some bugs by testing the api responses we get. The first step is to write some fixtures we can test with. Here we generate two faked stubbed responses for a very \",(0,n.jsx)(e.a,{href:\"https://example.com\",children:\"common domain\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ruby\",children:`\n \\xA0context 'an AWS cloud integration' do\n \\xA0 \\xA0before do\n \\xA0 \\xA0 \\xA0route53.stub_responses(:list_hosted_zones_by_name, {\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 is_truncated: false,\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 max_items: 100,\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 hosted_zones: [\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 {\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 id: '/hostedzone/Z321EXAMPLE',\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 name: 'example.com.',\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 config: {\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 comment: 'Some comment 1',\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 private_zone: true\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 },\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 caller_reference: SecureRandom.hex\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 },\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 {\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 id: '/hostedzone/Z123EXAMPLE',\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 name: 'example.com.',\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 config: {\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 comment: 'Some comment 2',\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 private_zone: false\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 },\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 caller_reference: SecureRandom.hex\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 ]\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 })\n \\xA0 \\xA0end\nend\n\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"If you\\u2019re wondering how to make these fixtures, you can easily read the \",(0,n.jsx)(e.a,{href:\"https://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/Route53/Client.html#list_hosted_zones_by_name-instance_method\",children:\"AWS Ruby SDK V3 documentation\"}),\" for sample inputs and outputs, or you can make API calls via the AWS CLI and inspect the responses, or you can even just put in some values and see what happens when you run rspec. For example, if I remove, say, the `caller_reference` parameter, I\\u2019ll get an error that helpfully identifies the problem.\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/1533e9e3859e67cfef95708dd3aadb80.png\",alt:\"\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Removing required parameters gives a helpful error message to correct the problem.\"}),`\n`,(0,n.jsx)(e.p,{children:\"You really can\\u2019t go wrong with the SDK validation and stubbed responses taken from the examples or from live requests you make with the CLI! This is already a tremendous benefit and we\\u2019re not even testing our own code yet.\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"write-a-test-case-with-the-stubbed-responses\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#write-a-test-case-with-the-stubbed-responses\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Write a Test Case with the Stubbed Responses\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Now we can write some unit test cases and loop through several responses that we expect to find the hosted zone. Voil\\xE1 we\\u2019ve uncovered some bugs just by being a little creative with our inputs! Do you see why?\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ruby\",children:`\ndescribe '#route53_hosted_zone_id' do\n \\xA0%w[\n \\xA0 \\xA0example.com\n \\xA0 \\xA0example.com.\n \\xA0 \\xA0www.example.com\n \\xA0 \\xA0www.example.com.\n \\xA0 \\xA0test.www.example.com\n \\xA0 \\xA0test.www.example.com.\n \\xA0 \\xA0deep.test.www.example.com\n \\xA0].each do |hostname|\n \\xA0 \\xA0context 'for hosts that exist in the parent zone' do\n \\xA0 \\xA0 \\xA0it \"returns the hosted_zone_id for #{hostname}\" do\n \\xA0 \\xA0 \\xA0 \\xA0expect(route53).to receive(:list_hosted_zones_by_name).with(no_args).and_call_original\n \\xA0 \\xA0 \\xA0 \\xA0hosted_zone_id = subject.route53_hosted_zone_id(hostname)\n \\xA0 \\xA0 \\xA0 \\xA0expect(hosted_zone_id).to eq('Z123EXAMPLE')\n \\xA0 \\xA0 \\xA0end\n \\xA0 \\xA0end\n \\xA0end\nend\n\n`})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/62c5d2015dd19e4280f0680a300995af.png\",alt:\"\"})}),`\n`,(0,n.jsx)(e.p,{children:\"With some creativity in test inputs and stubbed responses from the API, we can uncover some edge cases and bugs to fix!\"}),`\n`,(0,n.jsx)(e.p,{children:\"What these failed test cases are telling us is that the code worked under perfect conditions but in strange scenarios that may not be uncommon (for example, having an internal private zone and public zone with the same name, or selecting a two-level-deep name in a zone) could cause unpredictable behaviours.\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"the-solution-is-an-exercise-for-the-reader\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#the-solution-is-an-exercise-for-the-reader\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"The Solution is an Exercise for the Reader\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Now we merely need to write or refactor the code from our original snippet to pass all of our new test cases. One of the issues that our test cases revealed was that two-level-deep names (say, test.\",(0,n.jsx)(e.a,{href:\"http://www.example.com\",children:\"www.example.com\"}),\" in the zone example.com) would be missed. We also needed a way to ensure that zones are not private, perhaps with an optional parameter to specify private zones. Here is an example that passes all the existing tests and welcome feedback on any other bugs or optimisations you find.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ruby\",children:`\ndef route53_hosted_zone_ids_by_name(is_private_zone: false)\n \\xA0# TODO: danger, does not handle duplicate zone names!!!\n \\xA0hosted_zone_ids_by_name = {}\n \\xA0route53.list_hosted_zones_by_name.each do |response|\n \\xA0 \\xA0response.hosted_zones.each do |zone|\n \\xA0 \\xA0 \\xA0if !!zone.config.private_zone == is_private_zone\n \\xA0 \\xA0 \\xA0 \\xA0hosted_zone_ids_by_name[zone.name] = parse_hosted_zone_id(zone.id)\n \\xA0 \\xA0 \\xA0end\n \\xA0 \\xA0end\n \\xA0end\n \\xA0hosted_zone_ids_by_name\nend\n\ndef route53_hosted_zone_id(hostname)\n \\xA0# Recursively look for the zone id of the nearest parent (host, subdomain, or apex)\n \\xA0hosted_zone_ids_by_name = route53_hosted_zone_ids_by_name\n\n \\xA0loop do\n \\xA0 \\xA0hostname = cannonicalise(hostname)\n \\xA0 \\xA0break if hosted_zone_ids_by_name[hostname].present?\n\n \\xA0 \\xA0# Strip off one level and try again\n \\xA0 \\xA0hostname = domain_parts(hostname).drop(1).join('.')\n \\xA0 \\xA0break if hostname.blank?\n \\xA0end\n \\xA0hosted_zone_ids_by_name[hostname]\nend\n\n`})}),`\n`,(0,n.jsxs)(e.h3,{id:\"congratulations\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#congratulations\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Congratulations\"]}),`\n`,(0,n.jsx)(e.p,{children:\"All test cases now pass! Keep writing tests until you get nearly 100% coverage!\"}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"Hero Image by \",(0,n.jsx)(e.a,{href:\"https://unsplash.com/@jeswinthomas?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\",children:\"Jeswin\\xA0Thomas\"}),\" on \",(0,n.jsx)(e.a,{href:\"https://unsplash.com/s/photos/testing?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\",children:\"Unsplash\"})]}),`\n`]})]})}function x(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(h,t)})):h(t)}var z=x;return w(v);})();\n;return Component;"
  },
  "_id": "blog/posts/how-to-write-route53-stubbed-responses-for-rspec-tests.mdx",
  "_raw": {
    "sourceFilePath": "blog/posts/how-to-write-route53-stubbed-responses-for-rspec-tests.mdx",
    "sourceFileName": "how-to-write-route53-stubbed-responses-for-rspec-tests.mdx",
    "sourceFileDir": "blog/posts",
    "contentType": "mdx",
    "flattenedPath": "blog/posts/how-to-write-route53-stubbed-responses-for-rspec-tests"
  },
  "type": "BlogPost",
  "computedSlug": "how-to-write-route53-stubbed-responses-for-rspec-tests"
}