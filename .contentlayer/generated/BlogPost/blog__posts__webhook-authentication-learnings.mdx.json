{
  "title": "Webhook Authentication Learnings for GitHub, GitLab, and Bitbucket",
  "summary": "I was recently tasked with implementing GitLab support for Release and to complete that task I needed to implement authe",
  "publishDate": "Wed Jun 02 2021 17:13:56 GMT+0000 (Coordinated Universal Time)",
  "author": "jeremy-kreutzbender",
  "readingTime": 9,
  "categories": [
    "platform-engineering",
    "product"
  ],
  "mainImage": "/blog-images/f640a5f16852b36e83669568508fa7c2.jpg",
  "imageAlt": "Rope passing on rock climbing pitons conveying the idea of Webhook Authentication",
  "showCTA": true,
  "ctaCopy": "Looking to streamline webhook authentication like in the blog post? Try Release for seamless environment management.",
  "ctaLink": "https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=webhook-authentication-learnings",
  "relatedPosts": [
    ""
  ],
  "ogImage": "/blog-images/f640a5f16852b36e83669568508fa7c2.jpg",
  "excerpt": "I was recently tasked with implementing GitLab support for Release and to complete that task I needed to implement authe",
  "tags": [
    "platform-engineering",
    "product"
  ],
  "ctaButton": "Try Release for Free",
  "body": {
    "raw": "\nI was recently tasked with implementing GitLab support for Release and to complete that task I needed to implement authentication for GitLab and a way to handle their webhooks. I completed the authentication first and left the webhook implementation for another pull request as I wanted to refactor the way we were handling all webhooks.\n\nAs I started the webhook work, the state of how Release handled webhooks was that GitHub was using the [github_webhook](https://github.com/ssaunier/github_webhook) gem and Bitbucket was using some custom built code that lived in a Controller Concern. With the need to add a third client I wanted to align everything into a few classes that allow us to easily onboard more providers if the need ever arose.\n\nAs I finished up the work I thought it would be useful to share some things I found about the differences between the three providers and share some of the code that I wrote in case anyone else is trying to do a similar implementation. First I'll talk about a few things I came across and later, in the Technical Details section, I'll go over a few classes we're using in our Ruby on Rails project for handling the webhooks.\n\nI enjoyed doing this work because it spanned a lot different aspects of our codebase, including designing a refactor that would allow for processing webhooks from three different sources, reading documentation and understanding three different APIs, and writing tests to ensure that as we move forward we shouldn't need to every worry about breaking our webhook processing.\n\n### Authentication Methods\n\nFurther down in the Technical Details section, I'll show some code for the **_Authenticator_** class so you'll see the implementation around this topic, but I wanted to touch on how each of the three providers handles authenticating the webhooks. We'll start with GitHub.\n\n- **GitHub** - With a GitHub App, when you create the App, you can supply a secret key which will be used as the basis for authenticating the webhooks for all repositories. Their approach is to combine the payload of the webhook and the secret to generate a hash. The generated hash will be passed as a header when the request is sent to you. The documentation gives an example in Ruby on how to generate your own version of the hash. Then, if the comparison of the two hashes matches, you know the authenticity of the request is valid. I would rate this as the most secure way of authenticating the webhooks because if the request were intercepted and decoded, the secret used to generate the hash is not present anywhere in the request. You can read GitHub's [Securing your webhooks documentation](https://docs.github.com/en/developers/webhooks-and-events/webhooks/securing-your-webhooks) for yourself if you want to learn more.\n- **GitLab** - GitLab follows a similar approach to GitHub, except that a different webhook object must be created on GitLab for each Repository (as opposed to the singular GitHub App). Each webhook installation can take in a secret as it is being created and that secret is sent with the webhook request in the headers. There is no generating of a hash like GitHub, the secret is simply added to the request. Due to the secret being sent in the header, we decided to generate a different secret for every Repository as we save the Repository in the database. This means that if a request were to be intercepted and decoded, at most a single Repository would be compromised. You can read Gitlab's [Webhook documentation](https://docs.gitlab.com/ee/user/project/integrations/webhooks.html) for yourself if you want to learn more.\n- **Bitbucket Cloud** - Bitbucket is set up in a similar fashion to GitLab where we have to create a webhook object for each Repository. However, unlike Gitlab, Bitbucket Cloud does not offer a way to add a secret. I came across a [JIRA Ticket](https://jira.atlassian.com/browse/BCLOUD-14683) that was created in 2017 outlining this omission of a way to secure the requests but it is currently still open. It is unfortunate that Bitbucket doesn't offer a way to authenticate the webhook requests as it would allow someone to potentially send requests with bad information. They do offer an alternative solution in their documentation about whitelisting specific IPs that the requests could come from, but my opinion is that they should implement adding the secret and at least follow in GitLab's approach to send the secret in the headers. You can read Bitbucket Cloud's [Manage webhooks documentation](https://support.atlassian.com/bitbucket-cloud/docs/manage-webhooks/) for yourself if you want to learn more.\n\n### The Action Is Separated From The Event\n\nOne aspect I really like with Github and GitLab is that they differentiate their webhook request through an event and an action. The event is sent as a header in the request and an example would be _pull_request_ (on Github) or _merge_request_ (on GitLab). There are many different things that can happen with a Pull Request though: it might be one of opened, closed, merged, reopened, and so on. Those different actions that could happen on the Pull Request are sent over in the payload as the key _action_ with the value of the aforementioned states. From a coding perspective this event and action pattern allowed me to create a method, say _process_pull_request_ and inside of that method, handle the many different actions that could occur in another method, say _pull_request_opened_. I found that designing the code this way allowed for a good abstraction and thorough unit testing of all the different action methods.\n\nThe outlier is Bitbucket which added the event and the action together in the header. For example, when a Pull Request is created, the header contains _pullrequest:created_, when closed _pullrequest:rejected_, and when merged _pullrequest:fulfilled_. When using Release for ephemeral environments, closing and merging a Pull Request are considered the same type of action: we will destroy that ephemeral environment. But since the header contains two different values, I had to implement two different methods: _process_pullrequest_rejected_ and _process_pullrequest_fulfilled_ which simply call another method. While it is a pretty minor inconvenience, I like the code pattern of the action and event separated compared to having them combined.\n\n### Technical Details\n\nFirst and foremost I want to acknowledge the great work on the [github_webhook](https://github.com/ssaunier/github_webhook) gem as I used a good amount of what they had done to create the foundation for the **_Authenticator_** and **_Processor_** classes. What follows is the Ruby code I wrote to manage the webhooks from the three providers that Release currently supports.\n\n### The Authenticator\n\nFirst up, we'll look at the **_Authenticator_** class. Its purpose is to authenticate the webhooks that we are receiving to ensure that they're valid. You'll see that there is an optional parameter for the Repository and it is optional because as I mentioned in the Authentication Methods above, for GitHub we have a single secret, while for GitLab and Bitbucket a secret is generated for each Repository.\n\nAside from the initialization method, the class has a single public method, _authenticate_request!_ which does as it is named. It will raise an error if the authenticity of the request cannot be validated otherwise the call will return. The _expected_signature_ method follows the different providers implementations with GitHub needing to create a hash to compare, GitLab needing only the secret, and Bitbucket currently using a random string due to not offering an authentication method.\n\n```ruby\n\nmodule Webhooks\n  class Authenticator\n    class SignatureError < StandardError; end\n\n    def initialize(request:, vcs_type:, repository: nil)\n      @request = request\n      @vcs_type = vcs_type\n      @repository = repository\n    end\n\n    def authenticate_request!\n      secret = client_secret(@vcs_type, @repository)\n      request_signature = signature_header(@vcs_type, @request)\n      expected_signature = expected_signature(@vcs_type, secret, @request)\n\n      unless ActiveSupport::SecurityUtils.secure_compare(request_signature, expected_signature)\n        raise SignatureError\n      end\n    end\n\n    private\n\n    def request_body(request)\n      @request_body ||= (\n        request.body.rewind\n        request.body.read\n      )\n    end\n  \n    def signature_header(vcs_type, request)\n      @signature_header ||= (\n        case vcs_type\n        when :github\n          @request.headers['X-Hub-Signature-256']\n        when :gitlab\n          @request.headers['X-Gitlab-Token']\n        when :bitbucket\n          'bitbucket_cloud'\n        end\n      )\n    end\n\n    def expected_signature(vcs_type, secret, request)\n      digest = OpenSSL::Digest.new('sha256')\n\n      case vcs_type\n      when :github\n        \"sha256=#{OpenSSL::HMAC.hexdigest(digest, secret, request_body(request))}\"\n      when :gitlab\n        secret\n      when :bitbucket\n        'bitbucket_cloud'\n      end\n    end\n  \n    def client_secret(vcs_type, repository)\n      case vcs_type\n      when :github\n        Clients::Github.webhook_secret\n      when :gitlab, :bitbucket\n        repository.webhook_secret\n      end\n    end\n    \n  end\nend\n\n```\n\n### The Processor\n\nIf the request is authenticated, then we need to process the payload that comes with the request and the **_Processor_** class does just that. It will look through the payload and try to find the associated Repository in our database, if that Repository cannot be found, then an error occurs. To determine what event occurred, we look through the different headers in the request and parse the value into Ruby method declaration form by replacing any non-word character with an underscore. Based on the provider who sent the request, a service object is initialized and then we attempt to call a \\_process\\__ method. Some webhooks we receive are for things Release doesn't deal with, for example GitHub's \\_issues_ webhooks, so we safely _try_ the method as there may not be an implemented \\_process\\_\\_ method.\n\n```ruby\n\nmodule Webhooks\n  class Processor\n    def initialize(request, vcs_type)\n      @request = request\n      @payload = json_body(request)\n      @vcs_type = vcs_type\n      @repository = repository_from_payload(@vcs_type, @payload)\n      \n      @webhook_service = webhook_service(@vcs_type, @payload, @repository)\n    end\n\n    def repository\n      @repository\n    end\n\n    def process_webhook\n      process_method = \"process_#{event_method(@vcs_type, @request)}\"\n      @webhook_service.try(process_method)\n    end\n\n    private\n\n    def json_body(request)\n      payload = request.body.read\n      ActiveSupport::HashWithIndifferentAccess.new(JSON.load(payload))\n    end\n\n    def repository_from_payload(vcs_type, payload)\n      provider_repository_id = provider_repository_id(vcs_type, payload)\n      if provider_repository_id\n        Repository.find_by!(type: \"Repositories::#{vcs_type.capitalize}\", provider_repository_id: provider_repository_id)\n      end\n    rescue ActiveRecord::RecordNotFound => error\n      # Re-Raise the error with info from the payload so we know what the repository is\n      repository_info = payload.dig('repository', 'full_name')\n      new_error = ActiveRecord::RecordNotFound.new(error.message + \"Repository Info: #{repository_info}\")\n      new_error.set_backtrace(error.backtrace)\n      raise new_error\n    end\n\n    def provider_repository_id(vcs_type, payload)\n      case vcs_type\n      when :github\n        payload.dig('repository', 'id')\n      when :gitlab\n        payload.dig('project', 'id')\n      when :bitbucket\n        payload.dig('repository', 'uuid')\n      else\n        nil\n      end\n    end\n\n    def event_method(vcs_type, request)\n      @event_method ||=\n        (\n          case vcs_type\n          when :github\n            request.headers['X-GitHub-Event']\n          when :gitlab\n            request.headers['X-Gitlab-Event']\n          when :bitbucket\n            request.headers['X-Event-Key']\n          else\n            nil\n          end\n        )&.downcase&.gsub(/\\W/, '_')&.to_sym\n    end\n\n    def webhook_service(vcs_type, payload, repository)\n      service_class = \"Webhooks::#{vcs_type.to_s.capitalize}\"\n      service_class.constantize.new(payload, repository)\n    end\n  end\nend\n\n```\n\n### GitHub Webhook Service\n\nThe last method in **_Processor_**, _webhook_service_ returns a service class that goes through our internal business logic of what we want to do with the webhook. I'm going to provide a small snippet of the GitHub service when we receive a Pull Request webhook. If you recall, I mentioned this method in the \"The Action Is Separated From The Event\" section and how I liked this pattern of structuring the code. If someone else were to look at this code, I would hope they would find it easy to understand that anything to do with GitHub Pull Request webhooks happens inside of the _process_pull_request_ method and the _case_ statement handles all the different actions that can take place.\n\n```ruby\n\nmodule Webhooks\n  class Github\n    def initialize(payload, repository)\n      @payload = payload\n      @action = @payload.dig('action')\n\n      @repository = repository\n    end\n\n    def process_pull_request\n      if @action.nil?\n        error_message = \"ERROR: Pull Request no action received, payload : #{@payload}, do nothing\"\n        Rails.logger.error(error_message)\n      else            \n        message = \"Pull Request with action : *#{@action}*. Received Repository : #{@repository.name}.\"\n        Rails.logger.info(message)\n  \n        case @action\n        when 'opened', 'reopened'\n          pull_request_opened\n        when 'closed'\n          pull_request_closed\n        when 'labeled'\n          pull_request_labeled\n        else\n          message = \"Pull Request with action : *#{@action}*. Nothing to do for now.\"\n          Rails.logger.info(message)\n        end\n      end\n    end\n  end\nend\n\n```\n\n### The Controller\n\nThe final piece to tie everything together is the controller. **_WebhooksController_** is the base class and each subclass implements only the _vcs_type_ method. Our previous approach had custom code for each of the _Webhooks::GithubController_ and _Webhooks::BitbucketController_. This meant that each required a ton of specific tests to ensure that we were processing all the different webhooks correctly. My refactored approach moved all that logic out of the controller and aimed for the smallest footprint possible to make testing as simple as possible.\n\nThere is only one route in the controller, which is a _POST_ to _create_. I decided that since the Repository may be optional in the **_Authenticator_** that I will store it in the **_Processor_** and pass it into the **_Authenticator_**. Otherwise you can see that the public methods for each of the classes are called. If an error is raised by either, due to an unauthenticated webhook or possibly a webhook for a Repository we don't have in our database, we'll capture the error and log as much information as possible so that we can look into what went wrong.\n\n```ruby\n\nclass Webhooks::GithubController < WebhooksController\n  vcs_type(:github)\nend\n\n```\n\n```ruby\n\nclass WebhooksController < ActionController::Base\n  skip_before_action :verify_authenticity_token\n\n  def self.vcs_type(vcs_name)\n    define_method :vcs_type do\n      vcs_name\n    end\n  end\n\n  rescue_from StandardError do |error|\n    payload = @webhook_service&.payload\n\n    backtrace_cleaner = ActiveSupport::BacktraceCleaner.new\n    cleaned_backtrace = backtrace_cleaner.clean(error.backtrace)\n\n    error_message = \"Error in #{self}! Message : #{error.message}\\nPayload : #{payload}\\nBacktrace : #{cleaned_backtrace.join(\"\\n\")}\"\n    Rails.logger.error(error_message)\n    head :bad_request\n  end\n\n  def create\n    processor = Webhooks::Processor.new(request, vcs_type)\n    repository = processor.repository\n    \n    authenticator = Webhooks::Authenticator.new(request: request, vcs_type: vcs_type, repository: repository)\n    authenticator.authenticate_request!\n\n    processor.process_webhook\n\n    head :ok\n  end\nend\n\n```\n\n### Conclusion\n\nThat's a wrap on my stint in refactoring our webhook code to work with GitHub, Bitbucket, and GitLab. If we ever have to add another provider I think it will be quite straightforward and I hope you enjoyed taking a peek inside some development work at Release. If you're interested in having an ephemeral environment created whenever we receive a Pull Request webhook from your Repository, head on over to the [homepage](https://release.com) and sign up!\n\nPhoto by [Brook Anderson](https://unsplash.com/@brookanderson?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)\n",
    "code": "var Component=(()=>{var l=Object.create;var a=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var w=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),f=(n,e)=>{for(var o in e)a(n,o,{get:e[o],enumerable:!0})},i=(n,e,o,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of p(e))!b.call(n,r)&&r!==o&&a(n,r,{get:()=>e[r],enumerable:!(s=u(e,r))||s.enumerable});return n};var y=(n,e,o)=>(o=n!=null?l(m(n)):{},i(e||!n||!n.__esModule?a(o,\"default\",{value:n,enumerable:!0}):o,n)),g=n=>i(a({},\"__esModule\",{value:!0}),n);var c=w((R,h)=>{h.exports=_jsx_runtime});var q={};f(q,{default:()=>v,frontmatter:()=>_});var t=y(c()),_={title:\"Webhook Authentication Learnings for GitHub, GitLab, and Bitbucket\",summary:\"I was recently tasked with implementing GitLab support for Release and to complete that task I needed to implement authe\",publishDate:\"Wed Jun 02 2021 17:13:56 GMT+0000 (Coordinated Universal Time)\",author:\"jeremy-kreutzbender\",readingTime:9,categories:[\"platform-engineering\",\"product\"],mainImage:\"/blog-images/f640a5f16852b36e83669568508fa7c2.jpg\",imageAlt:\"Rope passing on rock climbing pitons conveying the idea of Webhook Authentication\",showCTA:!0,ctaCopy:\"Looking to streamline webhook authentication like in the blog post? Try Release for seamless environment management.\",ctaLink:\"https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=webhook-authentication-learnings\",relatedPosts:[\"\"],ogImage:\"/blog-images/f640a5f16852b36e83669568508fa7c2.jpg\",excerpt:\"I was recently tasked with implementing GitLab support for Release and to complete that task I needed to implement authe\",tags:[\"platform-engineering\",\"product\"],ctaButton:\"Try Release for Free\"};function d(n){let e=Object.assign({p:\"p\",a:\"a\",h3:\"h3\",span:\"span\",strong:\"strong\",em:\"em\",ul:\"ul\",li:\"li\",pre:\"pre\",code:\"code\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:\"I was recently tasked with implementing GitLab support for Release and to complete that task I needed to implement authentication for GitLab and a way to handle their webhooks. I completed the authentication first and left the webhook implementation for another pull request as I wanted to refactor the way we were handling all webhooks.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"As I started the webhook work, the state of how Release handled webhooks was that GitHub was using the \",(0,t.jsx)(e.a,{href:\"https://github.com/ssaunier/github_webhook\",children:\"github_webhook\"}),\" gem and Bitbucket was using some custom built code that lived in a Controller Concern. With the need to add a third client I wanted to align everything into a few classes that allow us to easily onboard more providers if the need ever arose.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"As I finished up the work I thought it would be useful to share some things I found about the differences between the three providers and share some of the code that I wrote in case anyone else is trying to do a similar implementation. First I'll talk about a few things I came across and later, in the Technical Details section, I'll go over a few classes we're using in our Ruby on Rails project for handling the webhooks.\"}),`\n`,(0,t.jsx)(e.p,{children:\"I enjoyed doing this work because it spanned a lot different aspects of our codebase, including designing a refactor that would allow for processing webhooks from three different sources, reading documentation and understanding three different APIs, and writing tests to ensure that as we move forward we shouldn't need to every worry about breaking our webhook processing.\"}),`\n`,(0,t.jsxs)(e.h3,{id:\"authentication-methods\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#authentication-methods\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"Authentication Methods\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Further down in the Technical Details section, I'll show some code for the \",(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.em,{children:\"Authenticator\"})}),\" class so you'll see the implementation around this topic, but I wanted to touch on how each of the three providers handles authenticating the webhooks. We'll start with GitHub.\"]}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"GitHub\"}),\" - With a GitHub App, when you create the App, you can supply a secret key which will be used as the basis for authenticating the webhooks for all repositories. Their approach is to combine the payload of the webhook and the secret to generate a hash. The generated hash will be passed as a header when the request is sent to you. The documentation gives an example in Ruby on how to generate your own version of the hash. Then, if the comparison of the two hashes matches, you know the authenticity of the request is valid. I would rate this as the most secure way of authenticating the webhooks because if the request were intercepted and decoded, the secret used to generate the hash is not present anywhere in the request. You can read GitHub's \",(0,t.jsx)(e.a,{href:\"https://docs.github.com/en/developers/webhooks-and-events/webhooks/securing-your-webhooks\",children:\"Securing your webhooks documentation\"}),\" for yourself if you want to learn more.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"GitLab\"}),\" - GitLab follows a similar approach to GitHub, except that a different webhook object must be created on GitLab for each Repository (as opposed to the singular GitHub App). Each webhook installation can take in a secret as it is being created and that secret is sent with the webhook request in the headers. There is no generating of a hash like GitHub, the secret is simply added to the request. Due to the secret being sent in the header, we decided to generate a different secret for every Repository as we save the Repository in the database. This means that if a request were to be intercepted and decoded, at most a single Repository would be compromised. You can read Gitlab's \",(0,t.jsx)(e.a,{href:\"https://docs.gitlab.com/ee/user/project/integrations/webhooks.html\",children:\"Webhook documentation\"}),\" for yourself if you want to learn more.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Bitbucket Cloud\"}),\" - Bitbucket is set up in a similar fashion to GitLab where we have to create a webhook object for each Repository. However, unlike Gitlab, Bitbucket Cloud does not offer a way to add a secret. I came across a \",(0,t.jsx)(e.a,{href:\"https://jira.atlassian.com/browse/BCLOUD-14683\",children:\"JIRA Ticket\"}),\" that was created in 2017 outlining this omission of a way to secure the requests but it is currently still open. It is unfortunate that Bitbucket doesn't offer a way to authenticate the webhook requests as it would allow someone to potentially send requests with bad information. They do offer an alternative solution in their documentation about whitelisting specific IPs that the requests could come from, but my opinion is that they should implement adding the secret and at least follow in GitLab's approach to send the secret in the headers. You can read Bitbucket Cloud's \",(0,t.jsx)(e.a,{href:\"https://support.atlassian.com/bitbucket-cloud/docs/manage-webhooks/\",children:\"Manage webhooks documentation\"}),\" for yourself if you want to learn more.\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.h3,{id:\"the-action-is-separated-from-the-event\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#the-action-is-separated-from-the-event\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"The Action Is Separated From The Event\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"One aspect I really like with Github and GitLab is that they differentiate their webhook request through an event and an action. The event is sent as a header in the request and an example would be \",(0,t.jsx)(e.em,{children:\"pull_request\"}),\" (on Github) or \",(0,t.jsx)(e.em,{children:\"merge_request\"}),\" (on GitLab). There are many different things that can happen with a Pull Request though: it might be one of opened, closed, merged, reopened, and so on. Those different actions that could happen on the Pull Request are sent over in the payload as the key \",(0,t.jsx)(e.em,{children:\"action\"}),\" with the value of the aforementioned states. From a coding perspective this event and action pattern allowed me to create a method, say \",(0,t.jsx)(e.em,{children:\"process_pull_request\"}),\" and inside of that method, handle the many different actions that could occur in another method, say \",(0,t.jsx)(e.em,{children:\"pull_request_opened\"}),\". I found that designing the code this way allowed for a good abstraction and thorough unit testing of all the different action methods.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The outlier is Bitbucket which added the event and the action together in the header. For example, when a Pull Request is created, the header contains \",(0,t.jsx)(e.em,{children:\"pullrequest:created\"}),\", when closed \",(0,t.jsx)(e.em,{children:\"pullrequest:rejected\"}),\", and when merged \",(0,t.jsx)(e.em,{children:\"pullrequest:fulfilled\"}),\". When using Release for ephemeral environments, closing and merging a Pull Request are considered the same type of action: we will destroy that ephemeral environment. But since the header contains two different values, I had to implement two different methods: \",(0,t.jsx)(e.em,{children:\"process_pullrequest_rejected\"}),\" and \",(0,t.jsx)(e.em,{children:\"process_pullrequest_fulfilled\"}),\" which simply call another method. While it is a pretty minor inconvenience, I like the code pattern of the action and event separated compared to having them combined.\"]}),`\n`,(0,t.jsxs)(e.h3,{id:\"technical-details\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#technical-details\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"Technical Details\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"First and foremost I want to acknowledge the great work on the \",(0,t.jsx)(e.a,{href:\"https://github.com/ssaunier/github_webhook\",children:\"github_webhook\"}),\" gem as I used a good amount of what they had done to create the foundation for the \",(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.em,{children:\"Authenticator\"})}),\" and \",(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.em,{children:\"Processor\"})}),\" classes. What follows is the Ruby code I wrote to manage the webhooks from the three providers that Release currently supports.\"]}),`\n`,(0,t.jsxs)(e.h3,{id:\"the-authenticator\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#the-authenticator\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"The Authenticator\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"First up, we'll look at the \",(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.em,{children:\"Authenticator\"})}),\" class. Its purpose is to authenticate the webhooks that we are receiving to ensure that they're valid. You'll see that there is an optional parameter for the Repository and it is optional because as I mentioned in the Authentication Methods above, for GitHub we have a single secret, while for GitLab and Bitbucket a secret is generated for each Repository.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Aside from the initialization method, the class has a single public method, \",(0,t.jsx)(e.em,{children:\"authenticate_request!\"}),\" which does as it is named. It will raise an error if the authenticity of the request cannot be validated otherwise the call will return. The \",(0,t.jsx)(e.em,{children:\"expected_signature\"}),\" method follows the different providers implementations with GitHub needing to create a hash to compare, GitLab needing only the secret, and Bitbucket currently using a random string due to not offering an authentication method.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-ruby\",children:`\nmodule Webhooks\n \\xA0class Authenticator\n \\xA0 \\xA0class SignatureError < StandardError; end\n\n \\xA0 \\xA0def initialize(request:, vcs_type:, repository: nil)\n \\xA0 \\xA0 \\xA0@request = request\n \\xA0 \\xA0 \\xA0@vcs_type = vcs_type\n \\xA0 \\xA0 \\xA0@repository = repository\n \\xA0 \\xA0end\n\n \\xA0 \\xA0def authenticate_request!\n \\xA0 \\xA0 \\xA0secret = client_secret(@vcs_type, @repository)\n \\xA0 \\xA0 \\xA0request_signature = signature_header(@vcs_type, @request)\n \\xA0 \\xA0 \\xA0expected_signature = expected_signature(@vcs_type, secret, @request)\n\n \\xA0 \\xA0 \\xA0unless ActiveSupport::SecurityUtils.secure_compare(request_signature, expected_signature)\n \\xA0 \\xA0 \\xA0 \\xA0raise SignatureError\n \\xA0 \\xA0 \\xA0end\n \\xA0 \\xA0end\n\n \\xA0 \\xA0private\n\n \\xA0 \\xA0def request_body(request)\n \\xA0 \\xA0 \\xA0@request_body ||= (\n \\xA0 \\xA0 \\xA0 \\xA0request.body.rewind\n \\xA0 \\xA0 \\xA0 \\xA0request.body.read\n \\xA0 \\xA0 \\xA0)\n \\xA0 \\xA0end\n \\xA0\n \\xA0 \\xA0def signature_header(vcs_type, request)\n \\xA0 \\xA0 \\xA0@signature_header ||= (\n \\xA0 \\xA0 \\xA0 \\xA0case vcs_type\n \\xA0 \\xA0 \\xA0 \\xA0when :github\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0@request.headers['X-Hub-Signature-256']\n \\xA0 \\xA0 \\xA0 \\xA0when :gitlab\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0@request.headers['X-Gitlab-Token']\n \\xA0 \\xA0 \\xA0 \\xA0when :bitbucket\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0'bitbucket_cloud'\n \\xA0 \\xA0 \\xA0 \\xA0end\n \\xA0 \\xA0 \\xA0)\n \\xA0 \\xA0end\n\n \\xA0 \\xA0def expected_signature(vcs_type, secret, request)\n \\xA0 \\xA0 \\xA0digest = OpenSSL::Digest.new('sha256')\n\n \\xA0 \\xA0 \\xA0case vcs_type\n \\xA0 \\xA0 \\xA0when :github\n \\xA0 \\xA0 \\xA0 \\xA0\"sha256=#{OpenSSL::HMAC.hexdigest(digest, secret, request_body(request))}\"\n \\xA0 \\xA0 \\xA0when :gitlab\n \\xA0 \\xA0 \\xA0 \\xA0secret\n \\xA0 \\xA0 \\xA0when :bitbucket\n \\xA0 \\xA0 \\xA0 \\xA0'bitbucket_cloud'\n \\xA0 \\xA0 \\xA0end\n \\xA0 \\xA0end\n \\xA0\n \\xA0 \\xA0def client_secret(vcs_type, repository)\n \\xA0 \\xA0 \\xA0case vcs_type\n \\xA0 \\xA0 \\xA0when :github\n \\xA0 \\xA0 \\xA0 \\xA0Clients::Github.webhook_secret\n \\xA0 \\xA0 \\xA0when :gitlab, :bitbucket\n \\xA0 \\xA0 \\xA0 \\xA0repository.webhook_secret\n \\xA0 \\xA0 \\xA0end\n \\xA0 \\xA0end\n \\xA0 \\xA0\n \\xA0end\nend\n\n`})}),`\n`,(0,t.jsxs)(e.h3,{id:\"the-processor\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#the-processor\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"The Processor\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"If the request is authenticated, then we need to process the payload that comes with the request and the \",(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.em,{children:\"Processor\"})}),\" class does just that. It will look through the payload and try to find the associated Repository in our database, if that Repository cannot be found, then an error occurs. To determine what event occurred, we look through the different headers in the request and parse the value into Ruby method declaration form by replacing any non-word character with an underscore. Based on the provider who sent the request, a service object is initialized and then we attempt to call a _process__ method. Some webhooks we receive are for things Release doesn't deal with, for example GitHub's _issues_ webhooks, so we safely \",(0,t.jsx)(e.em,{children:\"try\"}),\" the method as there may not be an implemented _process__ method.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-ruby\",children:`\nmodule Webhooks\n \\xA0class Processor\n \\xA0 \\xA0def initialize(request, vcs_type)\n \\xA0 \\xA0 \\xA0@request = request\n \\xA0 \\xA0 \\xA0@payload = json_body(request)\n \\xA0 \\xA0 \\xA0@vcs_type = vcs_type\n \\xA0 \\xA0 \\xA0@repository = repository_from_payload(@vcs_type, @payload)\n \\xA0 \\xA0 \\xA0\n \\xA0 \\xA0 \\xA0@webhook_service = webhook_service(@vcs_type, @payload, @repository)\n \\xA0 \\xA0end\n\n \\xA0 \\xA0def repository\n \\xA0 \\xA0 \\xA0@repository\n \\xA0 \\xA0end\n\n \\xA0 \\xA0def process_webhook\n \\xA0 \\xA0 \\xA0process_method = \"process_#{event_method(@vcs_type, @request)}\"\n \\xA0 \\xA0 \\xA0@webhook_service.try(process_method)\n \\xA0 \\xA0end\n\n \\xA0 \\xA0private\n\n \\xA0 \\xA0def json_body(request)\n \\xA0 \\xA0 \\xA0payload = request.body.read\n \\xA0 \\xA0 \\xA0ActiveSupport::HashWithIndifferentAccess.new(JSON.load(payload))\n \\xA0 \\xA0end\n\n \\xA0 \\xA0def repository_from_payload(vcs_type, payload)\n \\xA0 \\xA0 \\xA0provider_repository_id = provider_repository_id(vcs_type, payload)\n \\xA0 \\xA0 \\xA0if provider_repository_id\n \\xA0 \\xA0 \\xA0 \\xA0Repository.find_by!(type: \"Repositories::#{vcs_type.capitalize}\", provider_repository_id: provider_repository_id)\n \\xA0 \\xA0 \\xA0end\n \\xA0 \\xA0rescue ActiveRecord::RecordNotFound => error\n \\xA0 \\xA0 \\xA0# Re-Raise the error with info from the payload so we know what the repository is\n \\xA0 \\xA0 \\xA0repository_info = payload.dig('repository', 'full_name')\n \\xA0 \\xA0 \\xA0new_error = ActiveRecord::RecordNotFound.new(error.message + \"Repository Info: #{repository_info}\")\n \\xA0 \\xA0 \\xA0new_error.set_backtrace(error.backtrace)\n \\xA0 \\xA0 \\xA0raise new_error\n \\xA0 \\xA0end\n\n \\xA0 \\xA0def provider_repository_id(vcs_type, payload)\n \\xA0 \\xA0 \\xA0case vcs_type\n \\xA0 \\xA0 \\xA0when :github\n \\xA0 \\xA0 \\xA0 \\xA0payload.dig('repository', 'id')\n \\xA0 \\xA0 \\xA0when :gitlab\n \\xA0 \\xA0 \\xA0 \\xA0payload.dig('project', 'id')\n \\xA0 \\xA0 \\xA0when :bitbucket\n \\xA0 \\xA0 \\xA0 \\xA0payload.dig('repository', 'uuid')\n \\xA0 \\xA0 \\xA0else\n \\xA0 \\xA0 \\xA0 \\xA0nil\n \\xA0 \\xA0 \\xA0end\n \\xA0 \\xA0end\n\n \\xA0 \\xA0def event_method(vcs_type, request)\n \\xA0 \\xA0 \\xA0@event_method ||=\n \\xA0 \\xA0 \\xA0 \\xA0(\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0case vcs_type\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0when :github\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0request.headers['X-GitHub-Event']\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0when :gitlab\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0request.headers['X-Gitlab-Event']\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0when :bitbucket\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0request.headers['X-Event-Key']\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0else\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0nil\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0end\n \\xA0 \\xA0 \\xA0 \\xA0)&.downcase&.gsub(/\\\\W/, '_')&.to_sym\n \\xA0 \\xA0end\n\n \\xA0 \\xA0def webhook_service(vcs_type, payload, repository)\n \\xA0 \\xA0 \\xA0service_class = \"Webhooks::#{vcs_type.to_s.capitalize}\"\n \\xA0 \\xA0 \\xA0service_class.constantize.new(payload, repository)\n \\xA0 \\xA0end\n \\xA0end\nend\n\n`})}),`\n`,(0,t.jsxs)(e.h3,{id:\"github-webhook-service\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#github-webhook-service\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"GitHub Webhook Service\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The last method in \",(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.em,{children:\"Processor\"})}),\", \",(0,t.jsx)(e.em,{children:\"webhook_service\"}),` returns a service class that goes through our internal business logic of what we want to do with the webhook. I'm going to provide a small snippet of the GitHub service when we receive a Pull Request webhook. If you recall, I mentioned this method in the \"The Action Is Separated From The Event\" section and how I liked this pattern of structuring the code. If someone else were to look at this code, I would hope they would find it easy to understand that anything to do with GitHub Pull Request webhooks happens inside of the `,(0,t.jsx)(e.em,{children:\"process_pull_request\"}),\" method and the \",(0,t.jsx)(e.em,{children:\"case\"}),\" statement handles all the different actions that can take place.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-ruby\",children:`\nmodule Webhooks\n \\xA0class Github\n \\xA0 \\xA0def initialize(payload, repository)\n \\xA0 \\xA0 \\xA0@payload = payload\n \\xA0 \\xA0 \\xA0@action = @payload.dig('action')\n\n \\xA0 \\xA0 \\xA0@repository = repository\n \\xA0 \\xA0end\n\n \\xA0 \\xA0def process_pull_request\n \\xA0 \\xA0 \\xA0if @action.nil?\n \\xA0 \\xA0 \\xA0 \\xA0error_message = \"ERROR: Pull Request no action received, payload : #{@payload}, do nothing\"\n \\xA0 \\xA0 \\xA0 \\xA0Rails.logger.error(error_message)\n \\xA0 \\xA0 \\xA0else \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\n \\xA0 \\xA0 \\xA0 \\xA0message = \"Pull Request with action : *#{@action}*. Received Repository : #{@repository.name}.\"\n \\xA0 \\xA0 \\xA0 \\xA0Rails.logger.info(message)\n \\xA0\n \\xA0 \\xA0 \\xA0 \\xA0case @action\n \\xA0 \\xA0 \\xA0 \\xA0when 'opened', 'reopened'\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0pull_request_opened\n \\xA0 \\xA0 \\xA0 \\xA0when 'closed'\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0pull_request_closed\n \\xA0 \\xA0 \\xA0 \\xA0when 'labeled'\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0pull_request_labeled\n \\xA0 \\xA0 \\xA0 \\xA0else\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0message = \"Pull Request with action : *#{@action}*. Nothing to do for now.\"\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0Rails.logger.info(message)\n \\xA0 \\xA0 \\xA0 \\xA0end\n \\xA0 \\xA0 \\xA0end\n \\xA0 \\xA0end\n \\xA0end\nend\n\n`})}),`\n`,(0,t.jsxs)(e.h3,{id:\"the-controller\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#the-controller\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"The Controller\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The final piece to tie everything together is the controller. \",(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.em,{children:\"WebhooksController\"})}),\" is the base class and each subclass implements only the \",(0,t.jsx)(e.em,{children:\"vcs_type\"}),\" method. Our previous approach had custom code for each of the \",(0,t.jsx)(e.em,{children:\"Webhooks::GithubController\"}),\" and \",(0,t.jsx)(e.em,{children:\"Webhooks::BitbucketController\"}),\". This meant that each required a ton of specific tests to ensure that we were processing all the different webhooks correctly. My refactored approach moved all that logic out of the controller and aimed for the smallest footprint possible to make testing as simple as possible.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"There is only one route in the controller, which is a \",(0,t.jsx)(e.em,{children:\"POST\"}),\" to \",(0,t.jsx)(e.em,{children:\"create\"}),\". I decided that since the Repository may be optional in the \",(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.em,{children:\"Authenticator\"})}),\" that I will store it in the \",(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.em,{children:\"Processor\"})}),\" and pass it into the \",(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.em,{children:\"Authenticator\"})}),\". Otherwise you can see that the public methods for each of the classes are called. If an error is raised by either, due to an unauthenticated webhook or possibly a webhook for a Repository we don't have in our database, we'll capture the error and log as much information as possible so that we can look into what went wrong.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-ruby\",children:`\nclass Webhooks::GithubController < WebhooksController\n \\xA0vcs_type(:github)\nend\n\n`})}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-ruby\",children:`\nclass WebhooksController < ActionController::Base\n \\xA0skip_before_action :verify_authenticity_token\n\n \\xA0def self.vcs_type(vcs_name)\n \\xA0 \\xA0define_method :vcs_type do\n \\xA0 \\xA0 \\xA0vcs_name\n \\xA0 \\xA0end\n \\xA0end\n\n \\xA0rescue_from StandardError do |error|\n \\xA0 \\xA0payload = @webhook_service&.payload\n\n \\xA0 \\xA0backtrace_cleaner = ActiveSupport::BacktraceCleaner.new\n \\xA0 \\xA0cleaned_backtrace = backtrace_cleaner.clean(error.backtrace)\n\n \\xA0 \\xA0error_message = \"Error in #{self}! Message : #{error.message}\\\\nPayload : #{payload}\\\\nBacktrace : #{cleaned_backtrace.join(\"\\\\n\")}\"\n \\xA0 \\xA0Rails.logger.error(error_message)\n \\xA0 \\xA0head :bad_request\n \\xA0end\n\n \\xA0def create\n \\xA0 \\xA0processor = Webhooks::Processor.new(request, vcs_type)\n \\xA0 \\xA0repository = processor.repository\n \\xA0 \\xA0\n \\xA0 \\xA0authenticator = Webhooks::Authenticator.new(request: request, vcs_type: vcs_type, repository: repository)\n \\xA0 \\xA0authenticator.authenticate_request!\n\n \\xA0 \\xA0processor.process_webhook\n\n \\xA0 \\xA0head :ok\n \\xA0end\nend\n\n`})}),`\n`,(0,t.jsxs)(e.h3,{id:\"conclusion\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#conclusion\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"Conclusion\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"That's a wrap on my stint in refactoring our webhook code to work with GitHub, Bitbucket, and GitLab. If we ever have to add another provider I think it will be quite straightforward and I hope you enjoyed taking a peek inside some development work at Release. If you're interested in having an ephemeral environment created whenever we receive a Pull Request webhook from your Repository, head on over to the \",(0,t.jsx)(e.a,{href:\"https://release.com\",children:\"homepage\"}),\" and sign up!\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Photo by \",(0,t.jsx)(e.a,{href:\"https://unsplash.com/@brookanderson?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\",children:\"Brook Anderson\"}),\" on \",(0,t.jsx)(e.a,{href:\"https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\",children:\"Unsplash\"})]})]})}function k(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(d,n)})):d(n)}var v=k;return g(q);})();\n;return Component;"
  },
  "_id": "blog/posts/webhook-authentication-learnings.mdx",
  "_raw": {
    "sourceFilePath": "blog/posts/webhook-authentication-learnings.mdx",
    "sourceFileName": "webhook-authentication-learnings.mdx",
    "sourceFileDir": "blog/posts",
    "contentType": "mdx",
    "flattenedPath": "blog/posts/webhook-authentication-learnings"
  },
  "type": "BlogPost",
  "computedSlug": "webhook-authentication-learnings"
}