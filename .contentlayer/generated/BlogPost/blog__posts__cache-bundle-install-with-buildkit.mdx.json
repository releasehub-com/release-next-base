{
  "title": "Cache Bundle Install with BuildKit",
  "summary": "",
  "publishDate": "Mon May 01 2023 20:56:45 GMT+0000 (Coordinated Universal Time)",
  "author": "jeremy-kreutzbender",
  "readingTime": 4,
  "categories": [
    "platform-engineering",
    "product"
  ],
  "mainImage": "/blog-images/54f242bfc5acedea0993fbf3735bc4af.png",
  "imageAlt": "Cache Bundle Install with BuildKit",
  "showCTA": true,
  "ctaCopy": "Discover how Release's ephemeral environments streamline caching for faster builds and efficient testing.",
  "ctaLink": "https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=cache-bundle-install-with-buildkit",
  "relatedPosts": [
    ""
  ],
  "ogImage": "/blog-images/54f242bfc5acedea0993fbf3735bc4af.png",
  "excerpt": "At Release, we've been using BuildKit to do our own builds for some time now and BuildKit does an awesome job of caching Docker image layers! But one thing t...",
  "tags": [
    "platform-engineering",
    "product"
  ],
  "ctaButton": "Try Release for Free",
  "body": {
    "raw": "\nAt Release, we've been using BuildKit to do our own builds for some time now and BuildKit does an awesome job of caching Docker image layers! But one thing that continued to slow down our builds was running `bundle install` when upgrading gems in our Rails application. I decided to start researching if there was any way that we could **cache our `bundle install` commands over many builds** because a cold `bundle install` is very slow, but **incremental changes are quite fast**. In my search, I came across a KubeCon video about BuildKit, [\"Running Cache-Efficient Builds at Scale on Kubernetes with BuildKit - Gautier Delorme, Apple Inc.\"](https://www.youtube.com/watch?v=wTENRhYt3mw) which had a very interesting slide.\n\n![](/blog-images/271d7cec8f533d977b812f76403497cd.png)\n\nThis is exactly the type of solution I was looking for and it comes built in with BuildKit!\n\nLet's take a look at an example from the [mount cache documentation](https://docs.docker.com/engine/reference/builder/#run---mounttypecache) to start.\n\nExample: cache Go packages\n\n```ruby line-numbers\n\n# syntax=docker/dockerfile:1\n\nFROM golang\nRUN --mount=type=cache,target=/root/.cache/go-build \\\n  go build ...\n\n```\n\nIn this example, the `go build` command uses the `/root/.cache/go-build` directory to store the packages in between builds. Because the output of `go build` is a binary and does not require anything to run besides that binary, this example makes correct use of the cache. If we think of the cache directory as a named volume from the host server into the container we can create a picture of how this example works. When `go build` is run, the cache directory is populated on the host server and the resulting binary ends up in the container. The problem is that this mount cache functionality wasn't built with the idea that the packages in the cache needed to be pulled into the resulting image.\n\nTo solve this problem I continued my search and came across this issue on the BuildKit repository, \"[Am I misunderstanding RUN mount=type=cache?](https://github.com/moby/buildkit/issues/1173)\". The writer of the issue explains how this functionality isn't working with `bundle install` and is trying to figure out what to do. In one of the answers a link to blog post in Japanese is provided, \"[Dockerfile for Rails6のベストプラクティスを解説](https://qiita.com/k_kind/items/836bc7ba2e33dc2ed3e7)\". A Dockerfile is provided in the post, which has the solution we've been searching for.\n\n```ruby line-numbers\n\nWORKDIR /app\n…\nRUN bundle config set app_config .bundle\nRUN bundle config set path .cache/bundle\n\n# mount cacheを利用する\n\nRUN --mount=type=cache,uid=1000,target=/app/.cache/bundle \\\n    bundle install && \\\n    mkdir -p vendor && \\\n    cp -ar .cache/bundle vendor/bundle\nRUN bundle config set path vendor/bundle\n\n```\n\nNow that we know what the solution is, let's go through it line by line to make sure we fully understand what is happening.\n\n```ruby line-numbers\n\nWORKDIR /app\n\n```\n\nFirst, we set the working directory for the Dockerfile to app\n\n```ruby line-numbers\n\nRUN bundle config set app_config .bundle\n\n```\n\nNext, we set Bundler's config to the `.bundle` directory.\n\n```ruby line-numbers\n\nRUN bundle config set path .cache/bundle\n\n```\n\nThen, we set Bundler's path `.cache/bundle` which is the directory the gems will be installed into.\n\n```ruby line-numbers\n\nRUN --mount=type=cache,uid=1000,target=/app/.cache/bundle \\\n    bundle install && \\\n    mkdir -p vendor && \\\n    cp -ar .cache/bundle vendor/bundle\n\n```\n\nNow the important part! We use the `--mount=type=cache` and set the cache to be the same location as Bundler's path. But a key here is to include the `WORKDIR` path so it becomes `target=/app/.cache/bundler`. This means our directory of installed gems will be persisted from build to build. We run `bundle install` to install the gems and then create a vendor directory. The last step here is to copy `.cache/bundle` into `vendor/bundle` because, if you recall from the Go example, the contents of the cache are not included in the layer.\n\n```ruby line-numbers\n\nRUN bundle config set path vendor/bundle\n\n```\n\nFinally we set Bundler's path to the directory we copied the files into and we're good to go.\n\nAnd now we fully understand what is happening! To wrap up, there are a few final points to cover. The first is that the code above is not quite ideal. It works, but it is missing a few options to add some safety and reliability. There will be a full example shown below.\n\nThe mount cache accepts an `id` as a parameter. The [documentation](https://docs.docker.com/engine/reference/builder/#run---mounttypecache) says:\n\n> Optional ID to identify separate/different caches. Defaults to the value of the target.\n\nSetting an ID is valuable if there are potentially lots of Dockerfiles running on the same BuildKit server who might be attempting to use the same cache location; imagine if two different Rails projects started sharing the same directory!\n\nWhich leads us to the second parameter of `sharing`. The [documentation](https://docs.docker.com/engine/reference/builder/#run---mounttypecache) says:\n\n> One of shared, private, or locked. Defaults to shared. A shared cache mount can be used concurrently by multiple writers. private creates a new mount if there are multiple writers. locked pauses the second writer until the first one releases the mount.\n\nWe want to opt for `sharing=locked` meaning that if two builds of the same Dockerfile are running at the same time, only one can access the cache at a time. This ensures that the output of `bundle install` won't be mangled when the `cp` command is issued.\n\nThis is our suggestion for a full solution.\n\n```ruby line-numbers\n\nWORKDIR /app/\nRUN gem install Bundler\nRUN bundle config set app_config .bundle\nRUN bundle config set path .cache/bundle\nCOPY Gemfile Gemfile.lock ./\nRUN --mount=type=cache,id=-gem-cache,sharing=locked,target=/app/.cache/bundle \\\nbundle install && \\\n  mkdir -p vendor && \\\n  cp -ar .cache/bundle vendor/bundle\nRUN bundle config set path vendor/bundle\n\n```\n\nIf you would like to read more about how the caching works, there is an issue on the BuildKit repository, \"[mount=type=cache more in-depth explanation?](https://github.com/moby/buildkit/issues/1673)\" that has a great discussion on how this functionality actually works.\n\nAnd if you would like to apply this caching mechanism to your build process, sign-up for Release and take advantage of our BuildKit servers!\n\n```css\nblockquote {\n  font-size: 1.25rem;\n}\n\n@media screen and (max-width: 479px) {\n  blockquote {\n    font-size: 1rem;\n  }\n}\n```\n",
    "code": "var Component=(()=>{var h=Object.create;var o=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),f=(t,e)=>{for(var i in e)o(t,i,{get:e[i],enumerable:!0})},r=(t,e,i,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of p(e))!g.call(t,a)&&a!==i&&o(t,a,{get:()=>e[a],enumerable:!(c=u(e,a))||c.enumerable});return t};var w=(t,e,i)=>(i=t!=null?h(m(t)):{},r(e||!t||!t.__esModule?o(i,\"default\",{value:t,enumerable:!0}):i,t)),y=t=>r(o({},\"__esModule\",{value:!0}),t);var d=b((x,l)=>{l.exports=_jsx_runtime});var N={};f(N,{default:()=>R,frontmatter:()=>k});var n=w(d()),k={title:\"Cache Bundle Install with BuildKit\",summary:\"\",publishDate:\"Mon May 01 2023 20:56:45 GMT+0000 (Coordinated Universal Time)\",author:\"jeremy-kreutzbender\",readingTime:4,categories:[\"platform-engineering\",\"product\"],mainImage:\"/blog-images/54f242bfc5acedea0993fbf3735bc4af.png\",imageAlt:\"Cache Bundle Install with BuildKit\",showCTA:!0,ctaCopy:\"Discover how Release's ephemeral environments streamline caching for faster builds and efficient testing.\",ctaLink:\"https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=cache-bundle-install-with-buildkit\",relatedPosts:[\"\"],ogImage:\"/blog-images/54f242bfc5acedea0993fbf3735bc4af.png\",excerpt:\"At Release, we've been using BuildKit to do our own builds for some time now and BuildKit does an awesome job of caching Docker image layers! But one thing t...\",tags:[\"platform-engineering\",\"product\"],ctaButton:\"Try Release for Free\"};function s(t){let e=Object.assign({p:\"p\",code:\"code\",strong:\"strong\",a:\"a\",img:\"img\",pre:\"pre\",blockquote:\"blockquote\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"At Release, we've been using BuildKit to do our own builds for some time now and BuildKit does an awesome job of caching Docker image layers! But one thing that continued to slow down our builds was running \",(0,n.jsx)(e.code,{children:\"bundle install\"}),\" when upgrading gems in our Rails application. I decided to start researching if there was any way that we could \",(0,n.jsxs)(e.strong,{children:[\"cache our \",(0,n.jsx)(e.code,{children:\"bundle install\"}),\" commands over many builds\"]}),\" because a cold \",(0,n.jsx)(e.code,{children:\"bundle install\"}),\" is very slow, but \",(0,n.jsx)(e.strong,{children:\"incremental changes are quite fast\"}),\". In my search, I came across a KubeCon video about BuildKit, \",(0,n.jsx)(e.a,{href:\"https://www.youtube.com/watch?v=wTENRhYt3mw\",children:'\"Running Cache-Efficient Builds at Scale on Kubernetes with BuildKit - Gautier Delorme, Apple Inc.\"'}),\" which had a very interesting slide.\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/271d7cec8f533d977b812f76403497cd.png\",alt:\"\"})}),`\n`,(0,n.jsx)(e.p,{children:\"This is exactly the type of solution I was looking for and it comes built in with BuildKit!\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Let's take a look at an example from the \",(0,n.jsx)(e.a,{href:\"https://docs.docker.com/engine/reference/builder/#run---mounttypecache\",children:\"mount cache documentation\"}),\" to start.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Example: cache Go packages\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ruby\",children:`\n# syntax=docker/dockerfile:1\n\nFROM golang\nRUN --mount=type=cache,target=/root/.cache/go-build \\\\\n  go build ...\n\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"In this example, the \",(0,n.jsx)(e.code,{children:\"go build\"}),\" command uses the \",(0,n.jsx)(e.code,{children:\"/root/.cache/go-build\"}),\" directory to store the packages in between builds. Because the output of \",(0,n.jsx)(e.code,{children:\"go build\"}),\" is a binary and does not require anything to run besides that binary, this example makes correct use of the cache. If we think of the cache directory as a named volume from the host server into the container we can create a picture of how this example works. When \",(0,n.jsx)(e.code,{children:\"go build\"}),\" is run, the cache directory is populated on the host server and the resulting binary ends up in the container. The problem is that this mount cache functionality wasn't built with the idea that the packages in the cache needed to be pulled into the resulting image.\"]}),`\n`,(0,n.jsxs)(e.p,{children:['To solve this problem I continued my search and came across this issue on the BuildKit repository, \"',(0,n.jsx)(e.a,{href:\"https://github.com/moby/buildkit/issues/1173\",children:\"Am I misunderstanding RUN mount=type=cache?\"}),`\". The writer of the issue explains how this functionality isn't working with `,(0,n.jsx)(e.code,{children:\"bundle install\"}),' and is trying to figure out what to do. In one of the answers a link to blog post in Japanese is provided, \"',(0,n.jsx)(e.a,{href:\"https://qiita.com/k_kind/items/836bc7ba2e33dc2ed3e7\",children:\"Dockerfile for Rails6\\u306E\\u30D9\\u30B9\\u30C8\\u30D7\\u30E9\\u30AF\\u30C6\\u30A3\\u30B9\\u3092\\u89E3\\u8AAC\"}),`\". A Dockerfile is provided in the post, which has the solution we've been searching for.`]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ruby\",children:`\nWORKDIR /app\n\\u2026\nRUN bundle config set app_config .bundle\nRUN bundle config set path .cache/bundle\n\n# mount cache\\u3092\\u5229\\u7528\\u3059\\u308B\n\nRUN --mount=type=cache,uid=1000,target=/app/.cache/bundle \\\\\n    bundle install && \\\\\n    mkdir -p vendor && \\\\\n    cp -ar .cache/bundle vendor/bundle\nRUN bundle config set path vendor/bundle\n\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Now that we know what the solution is, let's go through it line by line to make sure we fully understand what is happening.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ruby\",children:`\nWORKDIR /app\n\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"First, we set the working directory for the Dockerfile to app\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ruby\",children:`\nRUN bundle config set app_config .bundle\n\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Next, we set Bundler's config to the \",(0,n.jsx)(e.code,{children:\".bundle\"}),\" directory.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ruby\",children:`\nRUN bundle config set path .cache/bundle\n\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Then, we set Bundler's path \",(0,n.jsx)(e.code,{children:\".cache/bundle\"}),\" which is the directory the gems will be installed into.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ruby\",children:`\nRUN --mount=type=cache,uid=1000,target=/app/.cache/bundle \\\\\n    bundle install && \\\\\n    mkdir -p vendor && \\\\\n    cp -ar .cache/bundle vendor/bundle\n\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Now the important part! We use the \",(0,n.jsx)(e.code,{children:\"--mount=type=cache\"}),\" and set the cache to be the same location as Bundler's path. But a key here is to include the \",(0,n.jsx)(e.code,{children:\"WORKDIR\"}),\" path so it becomes \",(0,n.jsx)(e.code,{children:\"target=/app/.cache/bundler\"}),\". This means our directory of installed gems will be persisted from build to build. We run \",(0,n.jsx)(e.code,{children:\"bundle install\"}),\" to install the gems and then create a vendor directory. The last step here is to copy \",(0,n.jsx)(e.code,{children:\".cache/bundle\"}),\" into \",(0,n.jsx)(e.code,{children:\"vendor/bundle\"}),\" because, if you recall from the Go example, the contents of the cache are not included in the layer.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ruby\",children:`\nRUN bundle config set path vendor/bundle\n\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Finally we set Bundler's path to the directory we copied the files into and we're good to go.\"}),`\n`,(0,n.jsx)(e.p,{children:\"And now we fully understand what is happening! To wrap up, there are a few final points to cover. The first is that the code above is not quite ideal. It works, but it is missing a few options to add some safety and reliability. There will be a full example shown below.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The mount cache accepts an \",(0,n.jsx)(e.code,{children:\"id\"}),\" as a parameter. The \",(0,n.jsx)(e.a,{href:\"https://docs.docker.com/engine/reference/builder/#run---mounttypecache\",children:\"documentation\"}),\" says:\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"Optional ID to identify separate/different caches. Defaults to the value of the target.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Setting an ID is valuable if there are potentially lots of Dockerfiles running on the same BuildKit server who might be attempting to use the same cache location; imagine if two different Rails projects started sharing the same directory!\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Which leads us to the second parameter of \",(0,n.jsx)(e.code,{children:\"sharing\"}),\". The \",(0,n.jsx)(e.a,{href:\"https://docs.docker.com/engine/reference/builder/#run---mounttypecache\",children:\"documentation\"}),\" says:\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"One of shared, private, or locked. Defaults to shared. A shared cache mount can be used concurrently by multiple writers. private creates a new mount if there are multiple writers. locked pauses the second writer until the first one releases the mount.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"We want to opt for \",(0,n.jsx)(e.code,{children:\"sharing=locked\"}),\" meaning that if two builds of the same Dockerfile are running at the same time, only one can access the cache at a time. This ensures that the output of \",(0,n.jsx)(e.code,{children:\"bundle install\"}),\" won't be mangled when the \",(0,n.jsx)(e.code,{children:\"cp\"}),\" command is issued.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"This is our suggestion for a full solution.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ruby\",children:`\nWORKDIR /app/\nRUN gem install Bundler\nRUN bundle config set app_config .bundle\nRUN bundle config set path .cache/bundle\nCOPY Gemfile Gemfile.lock ./\nRUN --mount=type=cache,id=-gem-cache,sharing=locked,target=/app/.cache/bundle \\\\\nbundle install && \\\\\n  mkdir -p vendor && \\\\\n  cp -ar .cache/bundle vendor/bundle\nRUN bundle config set path vendor/bundle\n\n`})}),`\n`,(0,n.jsxs)(e.p,{children:['If you would like to read more about how the caching works, there is an issue on the BuildKit repository, \"',(0,n.jsx)(e.a,{href:\"https://github.com/moby/buildkit/issues/1673\",children:\"mount=type=cache more in-depth explanation?\"}),'\" that has a great discussion on how this functionality actually works.']}),`\n`,(0,n.jsx)(e.p,{children:\"And if you would like to apply this caching mechanism to your build process, sign-up for Release and take advantage of our BuildKit servers!\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-css\",children:`blockquote {\n  font-size: 1.25rem;\n}\n\n@media screen and (max-width: 479px) {\n  blockquote {\n    font-size: 1rem;\n  }\n}\n`})})]})}function v(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(s,t)})):s(t)}var R=v;return y(N);})();\n;return Component;"
  },
  "_id": "blog/posts/cache-bundle-install-with-buildkit.mdx",
  "_raw": {
    "sourceFilePath": "blog/posts/cache-bundle-install-with-buildkit.mdx",
    "sourceFileName": "cache-bundle-install-with-buildkit.mdx",
    "sourceFileDir": "blog/posts",
    "contentType": "mdx",
    "flattenedPath": "blog/posts/cache-bundle-install-with-buildkit"
  },
  "type": "BlogPost",
  "computedSlug": "cache-bundle-install-with-buildkit"
}