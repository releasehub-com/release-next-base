{
  "title": "Kubernetes Namespaces: The Ultimate Guide",
  "summary": "In this post we talk about kubernetes namespaces. We discuss what are they, how they work and what they're useful for",
  "publishDate": "Sun Jul 24 2022 23:38:21 GMT+0000 (Coordinated Universal Time)",
  "author": "ashley-penney",
  "readingTime": 7,
  "categories": [
    "kubernetes",
    "platform-engineering"
  ],
  "mainImage": "/blog-images/2266b02b751a19c98eb0df977859ad01.jpg",
  "imageAlt": "a laptop on a desk",
  "showCTA": true,
  "ctaCopy": "Experience seamless namespace isolation with Release.com's ephemeral environments for efficient Kubernetes resource management.",
  "ctaLink": "https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=kubernetes-namespaces-the-ultimate-guide",
  "relatedPosts": [
    ""
  ],
  "ogImage": "/blog-images/2266b02b751a19c98eb0df977859ad01.jpg",
  "excerpt": "In this post we talk about kubernetes namespaces. We discuss what are they, how they work and what they're useful for",
  "tags": [
    "kubernetes",
    "platform-engineering"
  ],
  "ctaButton": "Try Release for Free",
  "body": {
    "raw": "\nThe Kubernetes learning curve can be quite steep, but it's relatively easy to get started, especially today since many cloud providers offer easy-to-deploy, managed Kubernetes solutions. Therefore, you can run your application on a Kubernetes cluster in a few minutes. One of the things you'll probably discover after taking your first steps are Kubernetes namespaces. They're fundamental to Kubernetes, and you'll be using them extensively. But what are they actually, how do they work, and how are they useful? This post will give you the answers.\n\n![](/blog-images/32166a1642fb39bc4d1f7e023a0bd7d6.png)\n\n### What Are Kubernetes Namespaces?\n\nThe official Kubernetes documentation says that namespaces \"provide a mechanism for isolating groups of resources within a single cluster.\" The word \"grouping\" is key here. Namespaces are simple Kubernetes resources (just like deployments and pods) that can be used to create groups of resources. You can think of them as mini virtual clusters within your cluster. If you just started with Kubernetes and have been deploying things on it without specifying a namespace (we'll talk about how to do that later), you were still using a namespace. Every Kubernetes cluster comes with a few namespaces, one of which is called the \"default\". And that's where your deployment will end up if you don't specify otherwise.\n\n### How Are Kubernetes Namespaces Useful?\n\nNow that you know what Kubernetes namespaces are, let's talk about what they can be used for. The main purpose is isolation in multi-tenant environments. Imagine you have two separate teams using the same Kubernetes cluster. Both teams want to deploy, for example, an nginx server. Let's say both teams try to create a deployment as follows:\n\nOnly one team will succeed. The other will get an error message saying that an nginx deployment already exists. A simple solution for that could be to make the names of the deployments unique by, for example, adding a number or the name of the team to the deployment name.\n\n```yaml\nkubectl run nginx-teamA --image=nginx\nkubectl run nginx-teamB --image=nginx\n```\n\nThis would work, but it would be prone to errors, and it requires extra overhead. You won't be able to simply follow a tutorial on the internet about Kubernetes and copy and paste the commands from there because you'd have to adjust the names of resources every single time. Not great. That's exactly why namespaces exist. They isolate resources. This means you can have two nginx deployments running with the same name but in two separate namespaces. From each team's perspective, it would look like they have their own clusters. They won't have to worry about the other team's deployments.\n\n#### Keeping Your Cluster Tidy\n\nAnother good thing about using namespaces is that it's easier to keep your Kubernetes cluster clean. For example, if you're doing a lot of tests on your cluster or creating a lot of proof-of-concept deployments, it may be complicated to clean up afterward. If, for example, you have a hundred deployments running on your cluster, making sure that you delete the old ones used only for some tests can be not only time-consuming but even dangerous. Imagine deleting the production application by mistake when you just wanted to delete its test version. Namespaces can solve that problem too. Simply create a new namespace for each test or POC you want to run, and once you're done, you only need to delete that namespace. All resources within the namespace will be deleted automatically with it.\n\n#### Environment Separation\n\nSome people even use namespaces for separating environments. For example, you could have your application's development and production instances running on the same Kubernetes cluster separated by namespaces. It's cheaper and easier than running two separate clusters. However, it comes with its own disadvantages, so make sure you understand all the implications of doing so.\n\n![](/blog-images/29a9cf0aa0b92de29a291842d4df4661.png)\n\n#### Logical, Not Physical, Separation\n\nThere are many use cases for namespaces, and you can use them however you like as long as it makes sense for your organization. However, you should remember that namespaces provide only a logical and not a physical separation of resources. This means that isolation provided by namespaces is not the same as separation provided by separate clusters. In fact, you should think of namespaces more in terms of grouping capabilities than isolation.\n\nThis is especially important when using namespaces, for example, to separate environments for your application. You should know that your development instance can break your entire cluster, for example, due to too aggressive performance testing or even simple misconfiguration. So, if you run development and production instances in separate namespaces but on the same cluster, breaking the development environment could also bring your production instance down.\n\nYou also should be aware that there is no network isolation between namespaces by default. This means that pods in one namespace can freely talk to pods in any other namespace. This can be an advantage or disadvantage, depending on your needs. The good news is that it's relatively easy to implement namespace-based network isolation for your cluster. You just need to be aware that it doesn't happen automatically.\n\n### How Do Namespaces Work in Kubernetes?\n\nEnough of theory. Let's see namespaces in action. The basic usage of namespaces is the same as with any other objects in Kubernetes. It means you can execute commands like **kubectl create** or **kubectl get** for namespaces. Let's try that.\n\n#### kubectl get namespaces\n\nWe mentioned before that Kubernetes comes with a namespace called \"default\". In fact, there may be more namespaces on your brand-new cluster, depending on how it was deployed and which version of Kubernetes you're using. Let's validate that. To see the list of namespaces on your cluster, you can execute **kubectl get namespaces:**\n\n```yaml\n$ kubectl get namespaces\nNAME              STATUS   AGE\ndefault           Active   69s\nkube-system       Active   69s\nkube-public       Active   69s\nkube-node-lease   Active   69s\n```\n\nAs you can see, my cluster comes with four namespaces. Those named with prefix **kube-** are Kubernetes's own namespaces. **kube-system** holds Kubernetes components, so you definitely don't want to delete anything there. In fact, if you're a beginner, you should not touch any **kube-** prefixed namespaces. For you, there is the **default** namespace created. As mentioned before, this is the namespace where all your resources will be deployed if you don't specify otherwise. For example, if I execute **kubectl get pods** on an empty cluster, I'll see the following message:\n\n```yaml\n$ kubectl get pods\nNo resources found in default namespace.\n```\n\nFollowing the same logic, if I create a pod without specifying a namespace, it will be created in a default namespace:\n\n```yaml\n\n$ kubectl run nginx --image=nginx --restart=Never\npod/nginx created\n\n$ kubectl describe pod nginx\nName:         nginx\nNamespace:    default\n(...)\n\n```\n\nAs with many other Kubernetes objects, you can also use a shortcut, in this case **ns**, instead of typing **namespace** every time, so executing **kubectl get ns** will have the same effect as **kubectl get namespaces:**\n\n```yaml\n$ kubectl get ns\nNAME              STATUS        AGE\ndefault           Active        25m\nkube-system       Active        25m\nkube-public       Active        25m\nkube-node-lease   Active        25m\n```\n\n#### kubectl create namespace\n\nNow that you know how to see which namespaces you have in your cluster, let's add some more. For this, you can execute **kubectl create namespace** followed by the name of the desired namespace:\n\n```yaml\n$ kubectl create namespace frontend\nnamespace/frontend created\n```\n\nIf you execute **kubectl get namespaces** again, you should see your new namespace in the list now:\n\n```yaml\n$ kubectl get namespaces\nNAME              STATUS   AGE\ndefault           Active   14m\nkube-system       Active   14m\nkube-public       Active   14m\nkube-node-lease   Active   14m\nfrontend          Active   8s\n```\n\nNow that you have a new namespace, you can append **\\--namespace=frontend** to any other **kubectl** action to specify that you want to use that specific namespace. So, for example, to deploy your nginx deployment in that namespace, you can run the following:\n\n```yaml\n$ kubectl run nginx --image=nginx --restart=Never --namespace=frontend\npod/nginx created\n```\n\nIf you check the pods on your cluster now, you'll see no running pods.\n\n```yaml\n$ kubectl get pods\nNo resources found in default namespace.\n```\n\nWait, what? Well, read the message again. It says that there are no resources in the **default** namespace. This is expected since we just deployed nginx in the **frontend** namespace. Therefore, you need to append **\\--namespace=frontend** to the **kubectl get pods** command:\n\n```yaml\n$ kubectl get pods --namespace=frontend\nNAME    READY   STATUS    RESTARTS   AGE\nnginx   1/1     Running   0          3m7s\n```\n\nIf you get tired of adding the long **\\--namespace=frontend** parameter every time, you can also force your **kubectl** to use a specific namespace by default instead of the default \"default\" namespace. You can do that by executing the following:\n\n```yaml\nkubectl config set-context --current --namespace=frontend\n```\n\nYou just need to remember that all your commands will now be executed against the **frontend** namespace and not the **default** namespace.\n\n#### kubectl delete namespace\n\nDeleting a namespace is as straightforward as creating one. You can do it by executing the **kubectl delete namespace** followed by the name of the namespace you want to delete. Here's an example:\n\n```yaml\n$ kubectl get namespaces\nNAME STATUS AGE\ndefault Active 22m\nkube-system Active 22m\nkube-public Active 22m\nkube-node-lease Active 22m\nfrontend Active 8m16s\n\n$ kubectl delete namespace frontend\nnamespace \"frontend\" deleted\n\n$ kubectl get namespaces\nNAME STATUS AGE\ndefault Active 22m\nkube-system Active 22m\nkube-public Active 22m\nkube-node-lease Active 22m\n```\n\nKeep in mind that this will delete all resources within the namespace too. Your pods won't automatically move to another namespace. Also keep in mind that for the same reason, deleting the namespace can sometimes take a long time. If you have a lot of resources running in the namespace, Kubernetes will first try to delete all of them before deleting the namespace itself. For example, deleting pods can take some time, depending on their configuration.\n\n#### kubectl describe namespace\n\nAgain, as with any other Kubernetes object, you can execute **kubectl describe** for namespaces, which should give you more detailed information about the namespace. Unlike most resources, however, namespaces are simple objects, therefore there isn't usually much information:\n\n```yaml\n\n$ kubectl describe namespace default\nName:         default\nLabels:       kubernetes.io/metadata.name=default\nAnnotations:  \nStatus:       Active\nNo resource quota.\nNo resource limits.\n\n```\n\n### Namespaces in YAML\n\nIt's great to know how to use namespaces with **kubectl,** but in the real world, you'll probably manage all your Kubernetes resources with YAML files. You'll then need to specify which namespace to use in that YAML file. How do you do that? It's straightforward. Just add **namespace: \\[namespace_name\\]** in the **metadata** section of your Kubernetes definition file.\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n   name: nginx\n   namespace: frontend\n   labels:\n     name: nginx\nspec:\n   containers:\n   - name: nginx\n     image: nginx\n```\n\nYou can also create a namespace from a YAML file. It follows the same structure as your other Kubernetes YAML files, so you need to specify **apiVersion**, which in the case of namespaces is **v1**, then **kind**, which—you guessed it—is **namespace**. Then just define its name in the metadata section.\n\n```yaml\napiVersion: v1\nkind: Namespace\nmetadata:\n   name: backend\n```\n\nIt's the simplest Kubernetes file you've ever seen, isn't it? You can apply it like any other Kubernetes file using **kubectl apply -f namespace.yaml**.\n\n```yaml\n$ kubectl apply -f namespace.yaml\nnamespace/backend created\n```\n\n![](/blog-images/e2cbeea2c29032aa4a90c0b6ff3d428a.png)\n\n### Summary\n\nKubernetes namespaces are extremely useful. In this post, you learned what they are and how to use them. Now it's up to you and your company how to use them. Just remember that because namespaces can't be nested, it's also possible to overuse them. Namespaces should bring you grouping capabilities, making it easier for you to manage your resources. But if you create too many unnecessary namespaces, you won't make anything easier. But these are extreme cases, and namespaces are usually easy to get right.\n\nIf you want to learn more about Kubernetes, check out other articles on [our blog](https://release.com/blog).\n",
    "code": "var Component=(()=>{var d=Object.create;var o=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var y=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),b=(a,e)=>{for(var t in e)o(a,t,{get:e[t],enumerable:!0})},i=(a,e,t,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of m(e))!g.call(a,s)&&s!==t&&o(a,s,{get:()=>e[s],enumerable:!(r=h(e,s))||r.enumerable});return a};var f=(a,e,t)=>(t=a!=null?d(p(a)):{},i(e||!a||!a.__esModule?o(t,\"default\",{value:a,enumerable:!0}):t,a)),w=a=>i(o({},\"__esModule\",{value:!0}),a);var l=y((T,c)=>{c.exports=_jsx_runtime});var x={};b(x,{default:()=>N,frontmatter:()=>k});var n=f(l()),k={title:\"Kubernetes Namespaces: The Ultimate Guide\",summary:\"In this post we talk about kubernetes namespaces. We discuss what are they, how they work and what they're useful for\",publishDate:\"Sun Jul 24 2022 23:38:21 GMT+0000 (Coordinated Universal Time)\",author:\"ashley-penney\",readingTime:7,categories:[\"kubernetes\",\"platform-engineering\"],mainImage:\"/blog-images/2266b02b751a19c98eb0df977859ad01.jpg\",imageAlt:\"a laptop on a desk\",showCTA:!0,ctaCopy:\"Experience seamless namespace isolation with Release.com's ephemeral environments for efficient Kubernetes resource management.\",ctaLink:\"https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=kubernetes-namespaces-the-ultimate-guide\",relatedPosts:[\"\"],ogImage:\"/blog-images/2266b02b751a19c98eb0df977859ad01.jpg\",excerpt:\"In this post we talk about kubernetes namespaces. We discuss what are they, how they work and what they're useful for\",tags:[\"kubernetes\",\"platform-engineering\"],ctaButton:\"Try Release for Free\"};function u(a){let e=Object.assign({p:\"p\",img:\"img\",h3:\"h3\",a:\"a\",span:\"span\",pre:\"pre\",code:\"code\",h4:\"h4\",strong:\"strong\"},a.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"The Kubernetes learning curve can be quite steep, but it's relatively easy to get started, especially today since many cloud providers offer easy-to-deploy, managed Kubernetes solutions. Therefore, you can run your application on a Kubernetes cluster in a few minutes. One of the things you'll probably discover after taking your first steps are Kubernetes namespaces. They're fundamental to Kubernetes, and you'll be using them extensively. But what are they actually, how do they work, and how are they useful? This post will give you the answers.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/32166a1642fb39bc4d1f7e023a0bd7d6.png\",alt:\"\"})}),`\n`,(0,n.jsxs)(e.h3,{id:\"what-are-kubernetes-namespaces\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#what-are-kubernetes-namespaces\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"What Are Kubernetes Namespaces?\"]}),`\n`,(0,n.jsx)(e.p,{children:`The official Kubernetes documentation says that namespaces \"provide a mechanism for isolating groups of resources within a single cluster.\" The word \"grouping\" is key here. Namespaces are simple Kubernetes resources (just like deployments and pods) that can be used to create groups of resources. You can think of them as mini virtual clusters within your cluster. If you just started with Kubernetes and have been deploying things on it without specifying a namespace (we'll talk about how to do that later), you were still using a namespace. Every Kubernetes cluster comes with a few namespaces, one of which is called the \"default\". And that's where your deployment will end up if you don't specify otherwise.`}),`\n`,(0,n.jsxs)(e.h3,{id:\"how-are-kubernetes-namespaces-useful\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#how-are-kubernetes-namespaces-useful\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"How Are Kubernetes Namespaces Useful?\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Now that you know what Kubernetes namespaces are, let's talk about what they can be used for. The main purpose is isolation in multi-tenant environments. Imagine you have two separate teams using the same Kubernetes cluster. Both teams want to deploy, for example, an nginx server. Let's say both teams try to create a deployment as follows:\"}),`\n`,(0,n.jsx)(e.p,{children:\"Only one team will succeed. The other will get an error message saying that an nginx deployment already exists. A simple solution for that could be to make the names of the deployments unique by, for example, adding a number or the name of the team to the deployment name.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`kubectl run nginx-teamA --image=nginx\nkubectl run nginx-teamB --image=nginx\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"This would work, but it would be prone to errors, and it requires extra overhead. You won't be able to simply follow a tutorial on the internet about Kubernetes and copy and paste the commands from there because you'd have to adjust the names of resources every single time. Not great. That's exactly why namespaces exist. They isolate resources. This means you can have two nginx deployments running with the same name but in two separate namespaces. From each team's perspective, it would look like they have their own clusters. They won't have to worry about the other team's deployments.\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"keeping-your-cluster-tidy\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#keeping-your-cluster-tidy\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Keeping Your Cluster Tidy\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Another good thing about using namespaces is that it's easier to keep your Kubernetes cluster clean. For example, if you're doing a lot of tests on your cluster or creating a lot of proof-of-concept deployments, it may be complicated to clean up afterward. If, for example, you have a hundred deployments running on your cluster, making sure that you delete the old ones used only for some tests can be not only time-consuming but even dangerous. Imagine deleting the production application by mistake when you just wanted to delete its test version. Namespaces can solve that problem too. Simply create a new namespace for each test or POC you want to run, and once you're done, you only need to delete that namespace. All resources within the namespace will be deleted automatically with it.\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"environment-separation\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#environment-separation\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Environment Separation\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Some people even use namespaces for separating environments. For example, you could have your application's development and production instances running on the same Kubernetes cluster separated by namespaces. It's cheaper and easier than running two separate clusters. However, it comes with its own disadvantages, so make sure you understand all the implications of doing so.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/29a9cf0aa0b92de29a291842d4df4661.png\",alt:\"\"})}),`\n`,(0,n.jsxs)(e.h4,{id:\"logical-not-physical-separation\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#logical-not-physical-separation\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Logical, Not Physical, Separation\"]}),`\n`,(0,n.jsx)(e.p,{children:\"There are many use cases for namespaces, and you can use them however you like as long as it makes sense for your organization. However, you should remember that namespaces provide only a logical and not a physical separation of resources. This means that isolation provided by namespaces is not the same as separation provided by separate clusters. In fact, you should think of namespaces more in terms of grouping capabilities than isolation.\"}),`\n`,(0,n.jsx)(e.p,{children:\"This is especially important when using namespaces, for example, to separate environments for your application. You should know that your development instance can break your entire cluster, for example, due to too aggressive performance testing or even simple misconfiguration. So, if you run development and production instances in separate namespaces but on the same cluster, breaking the development environment could also bring your production instance down.\"}),`\n`,(0,n.jsx)(e.p,{children:\"You also should be aware that there is no network isolation between namespaces by default. This means that pods in one namespace can freely talk to pods in any other namespace. This can be an advantage or disadvantage, depending on your needs. The good news is that it's relatively easy to implement namespace-based network isolation for your cluster. You just need to be aware that it doesn't happen automatically.\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"how-do-namespaces-work-in-kubernetes\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#how-do-namespaces-work-in-kubernetes\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"How Do Namespaces Work in Kubernetes?\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Enough of theory. Let's see namespaces in action. The basic usage of namespaces is the same as with any other objects in Kubernetes. It means you can execute commands like \",(0,n.jsx)(e.strong,{children:\"kubectl create\"}),\" or \",(0,n.jsx)(e.strong,{children:\"kubectl get\"}),\" for namespaces. Let's try that.\"]}),`\n`,(0,n.jsxs)(e.h4,{id:\"kubectl-get-namespaces\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#kubectl-get-namespaces\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"kubectl get namespaces\"]}),`\n`,(0,n.jsxs)(e.p,{children:[`We mentioned before that Kubernetes comes with a namespace called \"default\". In fact, there may be more namespaces on your brand-new cluster, depending on how it was deployed and which version of Kubernetes you're using. Let's validate that. To see the list of namespaces on your cluster, you can execute `,(0,n.jsx)(e.strong,{children:\"kubectl get namespaces:\"})]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`$ kubectl get namespaces\nNAME \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0STATUS \\xA0 AGE\ndefault \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 Active \\xA0 69s\nkube-system \\xA0 \\xA0 \\xA0 Active \\xA0 69s\nkube-public \\xA0 \\xA0 \\xA0 Active \\xA0 69s\nkube-node-lease \\xA0 Active \\xA0 69s\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"As you can see, my cluster comes with four namespaces. Those named with prefix \",(0,n.jsx)(e.strong,{children:\"kube-\"}),\" are Kubernetes's own namespaces. \",(0,n.jsx)(e.strong,{children:\"kube-system\"}),\" holds Kubernetes components, so you definitely don't want to delete anything there. In fact, if you're a beginner, you should not touch any \",(0,n.jsx)(e.strong,{children:\"kube-\"}),\" prefixed namespaces. For you, there is the \",(0,n.jsx)(e.strong,{children:\"default\"}),\" namespace created. As mentioned before, this is the namespace where all your resources will be deployed if you don't specify otherwise. For example, if I execute \",(0,n.jsx)(e.strong,{children:\"kubectl get pods\"}),\" on an empty cluster, I'll see the following message:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`$ kubectl get pods\nNo resources found in default namespace.\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Following the same logic, if I create a pod without specifying a namespace, it will be created in a default namespace:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`\n$ kubectl run nginx --image=nginx --restart=Never\npod/nginx created\n\n$ kubectl describe pod nginx\nName: \\xA0 \\xA0 \\xA0 \\xA0 nginx\nNamespace: \\xA0 \\xA0default\n(...)\n\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"As with many other Kubernetes objects, you can also use a shortcut, in this case \",(0,n.jsx)(e.strong,{children:\"ns\"}),\", instead of typing \",(0,n.jsx)(e.strong,{children:\"namespace\"}),\" every time, so executing \",(0,n.jsx)(e.strong,{children:\"kubectl get ns\"}),\" will have the same effect as \",(0,n.jsx)(e.strong,{children:\"kubectl get namespaces:\"})]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`$ kubectl get ns\nNAME \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0STATUS \\xA0 \\xA0 \\xA0 \\xA0AGE\ndefault \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 Active \\xA0 \\xA0 \\xA0 \\xA025m\nkube-system \\xA0 \\xA0 \\xA0 Active \\xA0 \\xA0 \\xA0 \\xA025m\nkube-public \\xA0 \\xA0 \\xA0 Active \\xA0 \\xA0 \\xA0 \\xA025m\nkube-node-lease \\xA0 Active \\xA0 \\xA0 \\xA0 \\xA025m\n`})}),`\n`,(0,n.jsxs)(e.h4,{id:\"kubectl-create-namespace\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#kubectl-create-namespace\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"kubectl create namespace\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Now that you know how to see which namespaces you have in your cluster, let's add some more. For this, you can execute \",(0,n.jsx)(e.strong,{children:\"kubectl create namespace\"}),\" followed by the name of the desired namespace:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`$ kubectl create namespace frontend\nnamespace/frontend created\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"If you execute \",(0,n.jsx)(e.strong,{children:\"kubectl get namespaces\"}),\" again, you should see your new namespace in the list now:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`$ kubectl get namespaces\nNAME \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0STATUS \\xA0 AGE\ndefault \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 Active \\xA0 14m\nkube-system \\xA0 \\xA0 \\xA0 Active \\xA0 14m\nkube-public \\xA0 \\xA0 \\xA0 Active \\xA0 14m\nkube-node-lease \\xA0 Active \\xA0 14m\nfrontend \\xA0 \\xA0 \\xA0 \\xA0 \\xA0Active \\xA0 8s\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Now that you have a new namespace, you can append \",(0,n.jsx)(e.strong,{children:\"--namespace=frontend\"}),\" to any other \",(0,n.jsx)(e.strong,{children:\"kubectl\"}),\" action to specify that you want to use that specific namespace. So, for example, to deploy your nginx deployment in that namespace, you can run the following:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`$ kubectl run nginx --image=nginx --restart=Never --namespace=frontend\npod/nginx created\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"If you check the pods on your cluster now, you'll see no running pods.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`$ kubectl get pods\nNo resources found in default namespace.\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Wait, what? Well, read the message again. It says that there are no resources in the \",(0,n.jsx)(e.strong,{children:\"default\"}),\" namespace. This is expected since we just deployed nginx in the \",(0,n.jsx)(e.strong,{children:\"frontend\"}),\" namespace. Therefore, you need to append \",(0,n.jsx)(e.strong,{children:\"--namespace=frontend\"}),\" to the \",(0,n.jsx)(e.strong,{children:\"kubectl get pods\"}),\" command:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`$ kubectl get pods --namespace=frontend\nNAME \\xA0 \\xA0READY \\xA0 STATUS \\xA0 \\xA0RESTARTS \\xA0 AGE\nnginx \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA03m7s\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"If you get tired of adding the long \",(0,n.jsx)(e.strong,{children:\"--namespace=frontend\"}),\" parameter every time, you can also force your \",(0,n.jsx)(e.strong,{children:\"kubectl\"}),' to use a specific namespace by default instead of the default \"default\" namespace. You can do that by executing the following:']}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`kubectl config set-context --current --namespace=frontend\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"You just need to remember that all your commands will now be executed against the \",(0,n.jsx)(e.strong,{children:\"frontend\"}),\" namespace and not the \",(0,n.jsx)(e.strong,{children:\"default\"}),\" namespace.\"]}),`\n`,(0,n.jsxs)(e.h4,{id:\"kubectl-delete-namespace\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#kubectl-delete-namespace\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"kubectl delete namespace\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Deleting a namespace is as straightforward as creating one. You can do it by executing the \",(0,n.jsx)(e.strong,{children:\"kubectl delete namespace\"}),\" followed by the name of the namespace you want to delete. Here's an example:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`$ kubectl get namespaces\nNAME STATUS AGE\ndefault Active 22m\nkube-system Active 22m\nkube-public Active 22m\nkube-node-lease Active 22m\nfrontend Active 8m16s\n\n$ kubectl delete namespace frontend\nnamespace \"frontend\" deleted\n\n$ kubectl get namespaces\nNAME STATUS AGE\ndefault Active 22m\nkube-system Active 22m\nkube-public Active 22m\nkube-node-lease Active 22m\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Keep in mind that this will delete all resources within the namespace too. Your pods won't automatically move to another namespace. Also keep in mind that for the same reason, deleting the namespace can sometimes take a long time. If you have a lot of resources running in the namespace, Kubernetes will first try to delete all of them before deleting the namespace itself. For example, deleting pods can take some time, depending on their configuration.\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"kubectl-describe-namespace\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#kubectl-describe-namespace\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"kubectl describe namespace\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Again, as with any other Kubernetes object, you can execute \",(0,n.jsx)(e.strong,{children:\"kubectl describe\"}),\" for namespaces, which should give you more detailed information about the namespace. Unlike most resources, however, namespaces are simple objects, therefore there isn't usually much information:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`\n$ kubectl describe namespace default\nName: \\xA0 \\xA0 \\xA0 \\xA0 default\nLabels: \\xA0 \\xA0 \\xA0 kubernetes.io/metadata.name=default\nAnnotations: \\xA0\nStatus: \\xA0 \\xA0 \\xA0 Active\nNo resource quota.\nNo resource limits.\n\n`})}),`\n`,(0,n.jsxs)(e.h3,{id:\"namespaces-in-yaml\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#namespaces-in-yaml\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Namespaces in YAML\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"It's great to know how to use namespaces with \",(0,n.jsx)(e.strong,{children:\"kubectl,\"}),\" but in the real world, you'll probably manage all your Kubernetes resources with YAML files. You'll then need to specify which namespace to use in that YAML file. How do you do that? It's straightforward. Just add \",(0,n.jsx)(e.strong,{children:\"namespace: [namespace_name]\"}),\" in the \",(0,n.jsx)(e.strong,{children:\"metadata\"}),\" section of your Kubernetes definition file.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`apiVersion: v1\nkind: Pod\nmetadata:\n  \\xA0name: nginx\n  \\xA0namespace: frontend\n  \\xA0labels:\n  \\xA0 \\xA0name: nginx\nspec:\n  \\xA0containers:\n  \\xA0- name: nginx\n  \\xA0 \\xA0image: nginx\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"You can also create a namespace from a YAML file. It follows the same structure as your other Kubernetes YAML files, so you need to specify \",(0,n.jsx)(e.strong,{children:\"apiVersion\"}),\", which in the case of namespaces is \",(0,n.jsx)(e.strong,{children:\"v1\"}),\", then \",(0,n.jsx)(e.strong,{children:\"kind\"}),\", which\\u2014you guessed it\\u2014is \",(0,n.jsx)(e.strong,{children:\"namespace\"}),\". Then just define its name in the metadata section.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`apiVersion: v1\nkind: Namespace\nmetadata:\n  \\xA0name: backend\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"It's the simplest Kubernetes file you've ever seen, isn't it? You can apply it like any other Kubernetes file using \",(0,n.jsx)(e.strong,{children:\"kubectl apply -f namespace.yaml\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`$ kubectl apply -f namespace.yaml\nnamespace/backend created\n`})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/e2cbeea2c29032aa4a90c0b6ff3d428a.png\",alt:\"\"})}),`\n`,(0,n.jsxs)(e.h3,{id:\"summary\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#summary\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Summary\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Kubernetes namespaces are extremely useful. In this post, you learned what they are and how to use them. Now it's up to you and your company how to use them. Just remember that because namespaces can't be nested, it's also possible to overuse them. Namespaces should bring you grouping capabilities, making it easier for you to manage your resources. But if you create too many unnecessary namespaces, you won't make anything easier. But these are extreme cases, and namespaces are usually easy to get right.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"If you want to learn more about Kubernetes, check out other articles on \",(0,n.jsx)(e.a,{href:\"https://release.com/blog\",children:\"our blog\"}),\".\"]})]})}function v(a={}){let{wrapper:e}=a.components||{};return e?(0,n.jsx)(e,Object.assign({},a,{children:(0,n.jsx)(u,a)})):u(a)}var N=v;return w(x);})();\n;return Component;"
  },
  "_id": "blog/posts/kubernetes-namespaces-the-ultimate-guide.mdx",
  "_raw": {
    "sourceFilePath": "blog/posts/kubernetes-namespaces-the-ultimate-guide.mdx",
    "sourceFileName": "kubernetes-namespaces-the-ultimate-guide.mdx",
    "sourceFileDir": "blog/posts",
    "contentType": "mdx",
    "flattenedPath": "blog/posts/kubernetes-namespaces-the-ultimate-guide"
  },
  "type": "BlogPost",
  "computedSlug": "kubernetes-namespaces-the-ultimate-guide"
}