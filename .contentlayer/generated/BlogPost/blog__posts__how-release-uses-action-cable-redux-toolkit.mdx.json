{
  "title": "How Release Uses Action Cable and Redux Toolkit",
  "summary": "Walk through setting up Action Cable messages that are received by a React Component hooked up to Redux Toolkit.",
  "publishDate": "Wed Jul 14 2021 14:45:06 GMT+0000 (Coordinated Universal Time)",
  "author": "jeremy-kreutzbender",
  "readingTime": 8,
  "categories": [
    "platform-engineering",
    "product"
  ],
  "mainImage": "/blog-images/4a62d2a6629b891fdae6ce6926d1fb05.jpg",
  "imageAlt": "A toolkit that includes several tools such as hammer, saw and file",
  "showCTA": true,
  "ctaCopy": "Enhance your Redux setup with Release's ephemeral environments for seamless collaboration and efficient testing.",
  "ctaLink": "https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=how-release-uses-action-cable-redux-toolkit",
  "relatedPosts": [
    ""
  ],
  "ogImage": "/blog-images/4a62d2a6629b891fdae6ce6926d1fb05.jpg",
  "excerpt": "Walk through setting up Action Cable messages that are received by a React Component hooked up to Redux Toolkit.",
  "tags": [
    "platform-engineering",
    "product"
  ],
  "ctaButton": "Try Release for Free",
  "body": {
    "raw": "\nOver the past few weeks at [Release](https://releasehub.com) the Frontend Engineering team has started working on adding Redux to Release. We had been making use of [React Context](https://reactjs.org/docs/context.html) but felt that we were starting to stretch its capabilities. In some places we were having to add multiple providers to implement new features. After some research on the current state of Redux, we decided to go with [Redux Toolkit](https://redux-toolkit.js.org/) and [Redux Saga](https://redux-saga.js.org/). Moving all our data into the Redux store and out of local state meant that we were going to have to change our approach with [Action Cable](https://guides.rubyonrails.org/action_cable_overview.html) and how we were going to receive the messages, store them, and display changes for the user.\n\n### Action Cable, Redux, and Release\n\nRelease uses Action Cable in a single direction, which is from the backend to the frontend. The frontend is a separate React application running as a [Static Service Application](https://docs.releasehub.com/reference-guide/static-service-deployment), not a part of Rails. The backend will send messages to the frontend when the state of objects change or to stream logs of deployments and builds. Today we're going to go through the thought process, including code snippets, of how we set up our Redux implementation for Action Cable when Release builds a Docker image. If you’re curious about how Release builds Docker images, read about we [Cut Build Time In Half with Docker’s Buildx Kubernetes Driver](https://releasehub.com/blog/cutting-build-time-in-half-docker-buildx-kubernetes).\n\n### Action Cable Setup\n\nLet’s start off with how we set up the backend to send updates as a **_Build_** object progresses. We have two **_ActiveRecord_** models to consider in this scenario, **_Build_**, and **_Log_**. The **_Build_** class includes the [aasm](https://github.com/aasm/aasm) gem functionality to progress it through the lifecycle of actually creating a Docker build. The following is an extremely pared down version of our **_Build_** class, but has enough information to explain how we’re sending the Action Cable messages.\n\n```ruby line-numbers\n\nclass Build < ApplicationRecord\n  include AASM\n  include Logging\n\n  has_many :logs\n\n  aasm use_transactions: false do\n    state :ready, initial: true\n    state :running, after_enter: Proc.new { update_started_at; log_start }\n    state :done, after_enter: Proc.new { set_duration; log_done }\n    state :errored, after_enter: Proc.new { set_duration; log_error }\n\n    event :start do\n      transitions from: [:ready], to: :running\n    end\n\n    event :finish do\n      transitions from: [:running], to: :done\n    end\n\n    event :error do\n      transitions from: [:running], to: :errored\n    end\n\n  def log_start\n    message = \"Build starting for #{repository.name}!\"\n    log_it(:info, message, metadata: log_metadata)\n  end\n\n  def log_done\n    message = \"Build finished for #{repository.name}!\"\n    log_it(:info, message, metadata: log_metadata)\n  end\n\n  def log_error\n    message = \"Build errored for #{repository.name}!\"\n    log_it(:error, message, metadata: log_metadata)\n  end\n\n  def log_metadata\n    {\n      build_id: self.id,\n      aasm_state: self.aasm_state,\n      started_at: self.started_at,\n      duration: self.total_duration\n    }\n  end\n\n  def logs_channel\n    \"build_channel_#{self.id}\"\n  end\nend\n\n```\n\nWhenever the **_Build_** transitions its state, we create a **_Log_** record through the _log_it_ method. A log level is supplied, along with the message, and metadata about the **_Build_** itself. That metadata is used by the frontend to make changes for the user as you’ll see when we go through the Redux code. _log_it_ also sends the message to the _logs_channel_ through Action Cable. Since that wasn’t defined above, let’s look at that now.\n\n```ruby\n\nmodule Logging\n  module Log\n    def log_it(level, message, metadata: {})\n      log_hash = {\n        level: level,\n        message: message.dup.force_encoding('UTF-8')\n      }\n\n      self.logs << ::Log.new(log_hash)\n\n      payload = log_hash.merge(metadata)\n      ActionCable.server.broadcast(logs_channel, payload)\n    end\n  end\nend\n\n```\n\nThere is not too much to it. We create the **_Log_** record and ensure the message is properly encoded. Then we combine the level, message, and supplied metadata to Action Cable and broadcast it. We use the _log_it_ method with more classes than just **_Build_** and have found it makes for an easy and reliable way to store and send messages.\n\nThat takes care of our state transitions. The last piece needed to wrap up our backend setup is to create the **_BuildChannel_**.\n\n```ruby\n\nclass BuildChannel < ApplicationCable::Channel\n  def subscribed\n    Rails.logger.info \"Subscribing to: build_channel_#{params['room']}\"\n    stream_from \"build_channel_#{params['room']}\"\n  end\nend\n\n```\n\nThe method receives a room parameter to ensure we are sending messages about a specific **_Build_** and does not go to everyone. I like to have the logging message in there so that it is easy to tell in the Rails logs if the frontend has successfully connected to the channel. With all that covered, we’re ready to dive into the setup on the frontend to receive those messages!\n\n### Redux Setup\n\n![](/blog-images/68dcb6fe704aa06c5c855ffbdcf25ff8.png)\n\nRelease Build Screen with Logs\n\nAs you’ll recall we’re using Redux Toolkit and we’re not going to cover our entire setup with Toolkit, instead focusing only on the portions relevant to updating the **_Build_** when we receive an Action Cable message. From there we’ll go over a small wrapper component we made to handle receiving the Action Cable messages and tie it all together with a small demo component.\n\nWe’ll start off with the **_BuildsSlice_**.\n\n```javascript\nimport { createSlice } from \"@reduxjs/toolkit\";\n\nimport { handleBuildMessageReceived } from \"./helpers/actionCable/builds\";\n\nconst initialState = {\n  activeBuild: undefined, // object\n};\n\nexport const buildsSlice = createSlice({\n  updateBuildFromMessage(state, action) {\n    const message = action.payload;\n\n    const build = state.activeBuild;\n    const newBuild = handleBuildMessageReceived(build, message);\n\n    return {\n      ...state,\n      activeBuild: newBuild,\n    };\n  },\n});\n\nexport const { updateBuildFromMessage } = buildsSlice.actions;\n\nexport default buildsSlice.reducer;\n```\n\nYou’ll notice that we import _handleBuildMessageReceived_ from a file under _helpers/actionCable_. We wanted to separate out the code for the logic of updating the build from the slice itself so that our slice file does not grow too enormous. Other than that, the slice itself follows the suggested setup of a slice from the [createSlice](https://redux-toolkit.js.org/api/createslice) documentation.\n\nNow we need to look at our _handleBuildMessageReceived_ function.\n\n```javascript\nconst handleBuildMessageReceived = (build, message) => {\n  const buildId = message[\"build_id\"];\n  const aasmState = message[\"aasm_state\"];\n  const duration = message[\"duration\"];\n  const startedAt = message[\"started_at\"];\n  const level = message[\"level\"];\n  const messageLog = message[\"message\"];\n  const logs = build.logs;\n\n  if (build.id !== buildId) {\n    return build;\n  } else {\n    const newLogLine = { level: level, message: messageLog };\n    const newBuild = {\n      ...build,\n      logs: [...logs, newLogLine],\n      aasm_state: aasmState || build.aasm_state,\n      total_duration: duration || build.total_duration,\n      started_at: startedAt || build.started_at,\n    };\n    return newBuild;\n  }\n};\n\nexport { handleBuildMessageReceived };\n```\n\nFirst a sanity check is done to ensure we didn’t somehow receive a message for a **_Build_** that we aren’t viewing. This shouldn’t happen because we open and close our Action Cable subscriptions when we enter and leave a page, but an extra check never hurts. Then we construct a new **_Build_** object by appending the new log line and adding the metadata. If the metadata fields are _undefined_, we’ll retain what the _build_ variable already had.\n\nWe’re ready to receive messages so we need a component that will handle that for us. The **_ActionCableWrapper_** component is just that.\n\n```javascript\nimport React, { useEffect, useState } from \"react\";\nimport actionCable from \"actioncable\";\n\nexport default function ActionCableWrapper({ channel, room, onReceived }) {\n  const [actionCableConsumer, setActionCableConsumer] = useState(undefined);\n\n  useEffect(() => {\n    if (!actionCableConsumer) {\n      setActionCableConsumer(\n        actionCable.createConsumer(\"ws://localhost:3000/cable\"),\n      );\n    } else {\n      actionCableConsumer.subscriptions.create(\n        { channel, room },\n        {\n          received: onReceived,\n        },\n      );\n    }\n\n    return () => {\n      if (actionCableConsumer) {\n        actionCableConsumer.disconnect();\n      }\n    };\n  }, [actionCableConsumer]);\n\n  return <></>;\n}\n```\n\nThis component will mount and check to see if _actionCableConsumer_ is not _undefined_. However, if it is _undefined_, which it will be on the first pass through the _useEffect_, we will create a consumer through _actionCable.createConsumer_ connecting to a _/cable_ endpoint. _\"ws://localhost:3000/cable\"_ is hard coded but the URL should come from an environment variable so the component works locally or in production. That consumer is set into the local state _actionCableConsumer_ and the _useEffect_ will trigger a second time.\n\nIn the second pass through, the _else_ block is entered and a subscription is created with the passed in _channel_, _room_, and _onReceived_ properties. The _return_ function is set to call _disconnect()_ if we have an _actionCableConsumer_ set and will ensure that no web socket connections are left open if a user navigates away from the page. With that, we have a reusable component that will take care of our Action Cable needs throughout the application.\n\nPulling it all together, we can create a demo component that will display the state and logs and update whenever it receives a message.\n\n```javascript\nimport React from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\n\nimport { Grid } from \"@material-ui/core\";\n\nimport ActionCableWrapper from \"../ActionCableWrapper\";\n\nimport { updateBuildFromMessage } from \"redux/slices/builds\";\n\nexport default function BuildDetailsCard(props) {\n  const dispatch = useDispatch();\n  const build = useSelector((state) => state.builds.activeBuild);\n\n  const handleMessageReceived = (message) =>\n    dispatch(updateBuildFromMessage(message));\n\n  return (\n    <>\n           {\" \"}\n      <ActionCableWrapper\n        channel=\"BuildChannel\"\n        room={build.id}\n        onReceived={handleMessageReceived}\n      />\n      >      {\" \"}\n      <Grid container>\n               {\" \"}\n        <Grid item xs={3}>\n                   {\" \"}\n          <div>\n                        <b>Repository Name: </b> {build.repository.name}       \n             {\" \"}\n          </div>\n                   {\" \"}\n          <div>\n                        <b>Commit Message: </b> {build.commit_message}         {\" \"}\n          </div>\n                   {\" \"}\n          <div>\n                        <b>Commit SHA: </b> {build.commit_short}         {\" \"}\n          </div>\n                   {\" \"}\n          <div>\n                        <b>State: </b> {build.aasm_state}         {\" \"}\n          </div>\n                 {\" \"}\n        </Grid>\n               {\" \"}\n        <Grid\n          item\n          xs={9}\n          style={{\n            border: \"2px\",\n            backgroundColor: \"#343a40\",\n            fontSize: \"0.9rem\",\n            fontFamily: \"Monaco\",\n            color: \"white\",\n            padding: 10,\n          }}\n        >\n                   \n          {build.logs.map((log) => (\n            <div>{log.message} </div>\n          ))}\n                 {\" \"}\n        </Grid>\n             {\" \"}\n      </Grid>\n         \n    </>\n  );\n}\n```\n\nFor demo purposes I probably went a little overboard with the styling, but I wanted to create something that resembles our actual application which you saw at the start of this post. The two things needed to power the page are the _build_, which is retrieved with _useSelector_ and the _handleMessageReceived_ function, which dispatches _updateBuildFromMessage_ every time we receive a message through Action Cable. We supply the _”BuildChannel”_ and _build.id_ as the channel and room to _ActionCableWrapper_ along with _handleMessageReceived_ as the _onReceived_ function.\n\nIn the video below I’ll move the build through its different states and we’ll be able to see the frontend receive the messages, update the state, and add the logs to the screen.\n\n![](/blog-images/57d547202f306ddf41f2b8df93ed8650.gif)\n\n### Conclusion\n\nThat's a wrap on my adventure into how we set up our Action Cable integration with Redux Toolkit. There are tons of places in the application we’re going to be adding live updates too so that our users will always be up to date on the state of their application. I hope you enjoyed taking a peek inside some development work at Release. If you're interested in having an ephemeral environment created whenever we receive a Pull Request webhook from your Repository, head on over to the [homepage](https://release.com) and sign up! If you’d like to join our awesome team, check out our [job listings](https://releasehub.com/company).\n",
    "code": "var Component=(()=>{var h=Object.create;var i=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),f=(t,e)=>{for(var a in e)i(t,a,{get:e[a],enumerable:!0})},r=(t,e,a,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of m(e))!p.call(t,o)&&o!==a&&i(t,o,{get:()=>e[o],enumerable:!(s=u(e,o))||s.enumerable});return t};var w=(t,e,a)=>(a=t!=null?h(g(t)):{},r(e||!t||!t.__esModule?i(a,\"default\",{value:t,enumerable:!0}):a,t)),v=t=>r(i({},\"__esModule\",{value:!0}),t);var d=b((x,l)=>{l.exports=_jsx_runtime});var R={};f(R,{default:()=>y,frontmatter:()=>C});var n=w(d()),C={title:\"How Release Uses Action Cable and Redux Toolkit\",summary:\"Walk through setting up Action Cable messages that are received by a React Component hooked up to Redux Toolkit.\",publishDate:\"Wed Jul 14 2021 14:45:06 GMT+0000 (Coordinated Universal Time)\",author:\"jeremy-kreutzbender\",readingTime:8,categories:[\"platform-engineering\",\"product\"],mainImage:\"/blog-images/4a62d2a6629b891fdae6ce6926d1fb05.jpg\",imageAlt:\"A toolkit that includes several tools such as hammer, saw and file\",showCTA:!0,ctaCopy:\"Enhance your Redux setup with Release's ephemeral environments for seamless collaboration and efficient testing.\",ctaLink:\"https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=how-release-uses-action-cable-redux-toolkit\",relatedPosts:[\"\"],ogImage:\"/blog-images/4a62d2a6629b891fdae6ce6926d1fb05.jpg\",excerpt:\"Walk through setting up Action Cable messages that are received by a React Component hooked up to Redux Toolkit.\",tags:[\"platform-engineering\",\"product\"],ctaButton:\"Try Release for Free\"};function c(t){let e=Object.assign({p:\"p\",a:\"a\",h3:\"h3\",span:\"span\",strong:\"strong\",em:\"em\",pre:\"pre\",code:\"code\",img:\"img\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Over the past few weeks at \",(0,n.jsx)(e.a,{href:\"https://releasehub.com\",children:\"Release\"}),\" the Frontend Engineering team has started working on adding Redux to Release. We had been making use of \",(0,n.jsx)(e.a,{href:\"https://reactjs.org/docs/context.html\",children:\"React Context\"}),\" but felt that we were starting to stretch its capabilities. In some places we were having to add multiple providers to implement new features. After some research on the current state of Redux, we decided to go with \",(0,n.jsx)(e.a,{href:\"https://redux-toolkit.js.org/\",children:\"Redux Toolkit\"}),\" and \",(0,n.jsx)(e.a,{href:\"https://redux-saga.js.org/\",children:\"Redux Saga\"}),\". Moving all our data into the Redux store and out of local state meant that we were going to have to change our approach with \",(0,n.jsx)(e.a,{href:\"https://guides.rubyonrails.org/action_cable_overview.html\",children:\"Action Cable\"}),\" and how we were going to receive the messages, store them, and display changes for the user.\"]}),`\n`,(0,n.jsxs)(e.h3,{id:\"action-cable-redux-and-release\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#action-cable-redux-and-release\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Action Cable, Redux, and Release\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Release uses Action Cable in a single direction, which is from the backend to the frontend. The frontend is a separate React application running as a \",(0,n.jsx)(e.a,{href:\"https://docs.releasehub.com/reference-guide/static-service-deployment\",children:\"Static Service Application\"}),\", not a part of Rails. The backend will send messages to the frontend when the state of objects change or to stream logs of deployments and builds. Today we're going to go through the thought process, including code snippets, of how we set up our Redux implementation for Action Cable when Release builds a Docker image. If you\\u2019re curious about how Release builds Docker images, read about we \",(0,n.jsx)(e.a,{href:\"https://releasehub.com/blog/cutting-build-time-in-half-docker-buildx-kubernetes\",children:\"Cut Build Time In Half with Docker\\u2019s Buildx Kubernetes Driver\"}),\".\"]}),`\n`,(0,n.jsxs)(e.h3,{id:\"action-cable-setup\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#action-cable-setup\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Action Cable Setup\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Let\\u2019s start off with how we set up the backend to send updates as a \",(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.em,{children:\"Build\"})}),\" object progresses. We have two \",(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.em,{children:\"ActiveRecord\"})}),\" models to consider in this scenario, \",(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.em,{children:\"Build\"})}),\", and \",(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.em,{children:\"Log\"})}),\". The \",(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.em,{children:\"Build\"})}),\" class includes the \",(0,n.jsx)(e.a,{href:\"https://github.com/aasm/aasm\",children:\"aasm\"}),\" gem functionality to progress it through the lifecycle of actually creating a Docker build. The following is an extremely pared down version of our \",(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.em,{children:\"Build\"})}),\" class, but has enough information to explain how we\\u2019re sending the Action Cable messages.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ruby\",children:`\nclass Build < ApplicationRecord\n \\xA0include AASM\n \\xA0include Logging\n\n \\xA0has_many :logs\n\n \\xA0aasm use_transactions: false do\n \\xA0 \\xA0state :ready, initial: true\n \\xA0 \\xA0state :running, after_enter: Proc.new { update_started_at; log_start }\n \\xA0 \\xA0state :done, after_enter: Proc.new { set_duration; log_done }\n \\xA0 \\xA0state :errored, after_enter: Proc.new { set_duration; log_error }\n\n \\xA0 \\xA0event :start do\n \\xA0 \\xA0 \\xA0transitions from: [:ready], to: :running\n \\xA0 \\xA0end\n\n \\xA0 \\xA0event :finish do\n \\xA0 \\xA0 \\xA0transitions from: [:running], to: :done\n \\xA0 \\xA0end\n\n \\xA0 \\xA0event :error do\n \\xA0 \\xA0 \\xA0transitions from: [:running], to: :errored\n \\xA0 \\xA0end\n\n \\xA0def log_start\n \\xA0 \\xA0message = \"Build starting for #{repository.name}!\"\n \\xA0 \\xA0log_it(:info, message, metadata: log_metadata)\n \\xA0end\n\n \\xA0def log_done\n \\xA0 \\xA0message = \"Build finished for #{repository.name}!\"\n \\xA0 \\xA0log_it(:info, message, metadata: log_metadata)\n \\xA0end\n\n \\xA0def log_error\n \\xA0 \\xA0message = \"Build errored for #{repository.name}!\"\n \\xA0 \\xA0log_it(:error, message, metadata: log_metadata)\n \\xA0end\n\n \\xA0def log_metadata\n \\xA0 \\xA0{\n \\xA0 \\xA0 \\xA0build_id: self.id,\n \\xA0 \\xA0 \\xA0aasm_state: self.aasm_state,\n \\xA0 \\xA0 \\xA0started_at: self.started_at,\n \\xA0 \\xA0 \\xA0duration: self.total_duration\n \\xA0 \\xA0}\n \\xA0end\n\n \\xA0def logs_channel\n \\xA0 \\xA0\"build_channel_#{self.id}\"\n \\xA0end\nend\n\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Whenever the \",(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.em,{children:\"Build\"})}),\" transitions its state, we create a \",(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.em,{children:\"Log\"})}),\" record through the \",(0,n.jsx)(e.em,{children:\"log_it\"}),\" method. A log level is supplied, along with the message, and metadata about the \",(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.em,{children:\"Build\"})}),\" itself. That metadata is used by the frontend to make changes for the user as you\\u2019ll see when we go through the Redux code. \",(0,n.jsx)(e.em,{children:\"log_it\"}),\" also sends the message to the \",(0,n.jsx)(e.em,{children:\"logs_channel\"}),\" through Action Cable. Since that wasn\\u2019t defined above, let\\u2019s look at that now.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ruby\",children:`\nmodule Logging\n \\xA0module Log\n \\xA0 \\xA0def log_it(level, message, metadata: {})\n \\xA0 \\xA0 \\xA0log_hash = {\n \\xA0 \\xA0 \\xA0 \\xA0level: level,\n \\xA0 \\xA0 \\xA0 \\xA0message: message.dup.force_encoding('UTF-8')\n \\xA0 \\xA0 \\xA0}\n\n \\xA0 \\xA0 \\xA0self.logs << ::Log.new(log_hash)\n\n \\xA0 \\xA0 \\xA0payload = log_hash.merge(metadata)\n \\xA0 \\xA0 \\xA0ActionCable.server.broadcast(logs_channel, payload)\n \\xA0 \\xA0end\n \\xA0end\nend\n\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"There is not too much to it. We create the \",(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.em,{children:\"Log\"})}),\" record and ensure the message is properly encoded. Then we combine the level, message, and supplied metadata to Action Cable and broadcast it. We use the \",(0,n.jsx)(e.em,{children:\"log_it\"}),\" method with more classes than just \",(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.em,{children:\"Build\"})}),\" and have found it makes for an easy and reliable way to store and send messages.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"That takes care of our state transitions. The last piece needed to wrap up our backend setup is to create the \",(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.em,{children:\"BuildChannel\"})}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ruby\",children:`\nclass BuildChannel < ApplicationCable::Channel\n \\xA0def subscribed\n \\xA0 \\xA0Rails.logger.info \"Subscribing to: build_channel_#{params['room']}\"\n \\xA0 \\xA0stream_from \"build_channel_#{params['room']}\"\n \\xA0end\nend\n\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The method receives a room parameter to ensure we are sending messages about a specific \",(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.em,{children:\"Build\"})}),\" and does not go to everyone. I like to have the logging message in there so that it is easy to tell in the Rails logs if the frontend has successfully connected to the channel. With all that covered, we\\u2019re ready to dive into the setup on the frontend to receive those messages!\"]}),`\n`,(0,n.jsxs)(e.h3,{id:\"redux-setup\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#redux-setup\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Redux Setup\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/68dcb6fe704aa06c5c855ffbdcf25ff8.png\",alt:\"\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Release Build Screen with Logs\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"As you\\u2019ll recall we\\u2019re using Redux Toolkit and we\\u2019re not going to cover our entire setup with Toolkit, instead focusing only on the portions relevant to updating the \",(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.em,{children:\"Build\"})}),\" when we receive an Action Cable message. From there we\\u2019ll go over a small wrapper component we made to handle receiving the Action Cable messages and tie it all together with a small demo component.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"We\\u2019ll start off with the \",(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.em,{children:\"BuildsSlice\"})}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-javascript\",children:`import { createSlice } from \"@reduxjs/toolkit\";\n\nimport { handleBuildMessageReceived } from \"./helpers/actionCable/builds\";\n\nconst initialState = {\n  activeBuild: undefined, // object\n};\n\nexport const buildsSlice = createSlice({\n  updateBuildFromMessage(state, action) {\n    const message = action.payload;\n\n    const build = state.activeBuild;\n    const newBuild = handleBuildMessageReceived(build, message);\n\n    return {\n      ...state,\n      activeBuild: newBuild,\n    };\n  },\n});\n\nexport const { updateBuildFromMessage } = buildsSlice.actions;\n\nexport default buildsSlice.reducer;\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"You\\u2019ll notice that we import \",(0,n.jsx)(e.em,{children:\"handleBuildMessageReceived\"}),\" from a file under \",(0,n.jsx)(e.em,{children:\"helpers/actionCable\"}),\". We wanted to separate out the code for the logic of updating the build from the slice itself so that our slice file does not grow too enormous. Other than that, the slice itself follows the suggested setup of a slice from the \",(0,n.jsx)(e.a,{href:\"https://redux-toolkit.js.org/api/createslice\",children:\"createSlice\"}),\" documentation.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Now we need to look at our \",(0,n.jsx)(e.em,{children:\"handleBuildMessageReceived\"}),\" function.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-javascript\",children:`const handleBuildMessageReceived = (build, message) => {\n  const buildId = message[\"build_id\"];\n  const aasmState = message[\"aasm_state\"];\n  const duration = message[\"duration\"];\n  const startedAt = message[\"started_at\"];\n  const level = message[\"level\"];\n  const messageLog = message[\"message\"];\n  const logs = build.logs;\n\n  if (build.id !== buildId) {\n    return build;\n  } else {\n    const newLogLine = { level: level, message: messageLog };\n    const newBuild = {\n      ...build,\n      logs: [...logs, newLogLine],\n      aasm_state: aasmState || build.aasm_state,\n      total_duration: duration || build.total_duration,\n      started_at: startedAt || build.started_at,\n    };\n    return newBuild;\n  }\n};\n\nexport { handleBuildMessageReceived };\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"First a sanity check is done to ensure we didn\\u2019t somehow receive a message for a \",(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.em,{children:\"Build\"})}),\" that we aren\\u2019t viewing. This shouldn\\u2019t happen because we open and close our Action Cable subscriptions when we enter and leave a page, but an extra check never hurts. Then we construct a new \",(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.em,{children:\"Build\"})}),\" object by appending the new log line and adding the metadata. If the metadata fields are \",(0,n.jsx)(e.em,{children:\"undefined\"}),\", we\\u2019ll retain what the \",(0,n.jsx)(e.em,{children:\"build\"}),\" variable already had.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"We\\u2019re ready to receive messages so we need a component that will handle that for us. The \",(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.em,{children:\"ActionCableWrapper\"})}),\" component is just that.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-javascript\",children:`import React, { useEffect, useState } from \"react\";\nimport actionCable from \"actioncable\";\n\nexport default function ActionCableWrapper({ channel, room, onReceived }) {\n  const [actionCableConsumer, setActionCableConsumer] = useState(undefined);\n\n  useEffect(() => {\n    if (!actionCableConsumer) {\n      setActionCableConsumer(\n        actionCable.createConsumer(\"ws://localhost:3000/cable\"),\n      );\n    } else {\n      actionCableConsumer.subscriptions.create(\n        { channel, room },\n        {\n          received: onReceived,\n        },\n      );\n    }\n\n    return () => {\n      if (actionCableConsumer) {\n        actionCableConsumer.disconnect();\n      }\n    };\n  }, [actionCableConsumer]);\n\n  return <></>;\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"This component will mount and check to see if \",(0,n.jsx)(e.em,{children:\"actionCableConsumer\"}),\" is not \",(0,n.jsx)(e.em,{children:\"undefined\"}),\". However, if it is \",(0,n.jsx)(e.em,{children:\"undefined\"}),\", which it will be on the first pass through the \",(0,n.jsx)(e.em,{children:\"useEffect\"}),\", we will create a consumer through \",(0,n.jsx)(e.em,{children:\"actionCable.createConsumer\"}),\" connecting to a \",(0,n.jsx)(e.em,{children:\"/cable\"}),\" endpoint. \",(0,n.jsx)(e.em,{children:'\"ws://localhost:3000/cable\"'}),\" is hard coded but the URL should come from an environment variable so the component works locally or in production. That consumer is set into the local state \",(0,n.jsx)(e.em,{children:\"actionCableConsumer\"}),\" and the \",(0,n.jsx)(e.em,{children:\"useEffect\"}),\" will trigger a second time.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"In the second pass through, the \",(0,n.jsx)(e.em,{children:\"else\"}),\" block is entered and a subscription is created with the passed in \",(0,n.jsx)(e.em,{children:\"channel\"}),\", \",(0,n.jsx)(e.em,{children:\"room\"}),\", and \",(0,n.jsx)(e.em,{children:\"onReceived\"}),\" properties. The \",(0,n.jsx)(e.em,{children:\"return\"}),\" function is set to call \",(0,n.jsx)(e.em,{children:\"disconnect()\"}),\" if we have an \",(0,n.jsx)(e.em,{children:\"actionCableConsumer\"}),\" set and will ensure that no web socket connections are left open if a user navigates away from the page. With that, we have a reusable component that will take care of our Action Cable needs throughout the application.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Pulling it all together, we can create a demo component that will display the state and logs and update whenever it receives a message.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-javascript\",children:`import React from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\n\nimport { Grid } from \"@material-ui/core\";\n\nimport ActionCableWrapper from \"../ActionCableWrapper\";\n\nimport { updateBuildFromMessage } from \"redux/slices/builds\";\n\nexport default function BuildDetailsCard(props) {\n  const dispatch = useDispatch();\n  const build = useSelector((state) => state.builds.activeBuild);\n\n  const handleMessageReceived = (message) =>\n    dispatch(updateBuildFromMessage(message));\n\n  return (\n    <>\n      \\xA0 \\xA0 \\xA0{\" \"}\n      <ActionCableWrapper\n        channel=\"BuildChannel\"\n        room={build.id}\n        onReceived={handleMessageReceived}\n      />\n      > \\xA0 \\xA0 \\xA0{\" \"}\n      <Grid container>\n        \\xA0 \\xA0 \\xA0 \\xA0{\" \"}\n        <Grid item xs={3}>\n          \\xA0 \\xA0 \\xA0 \\xA0 \\xA0{\" \"}\n          <div>\n            \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 <b>Repository Name: </b> {build.repository.name}\\xA0 \\xA0 \\xA0 \\xA0\n            \\xA0{\" \"}\n          </div>\n          \\xA0 \\xA0 \\xA0 \\xA0 \\xA0{\" \"}\n          <div>\n            \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 <b>Commit Message: </b> {build.commit_message}\\xA0 \\xA0 \\xA0 \\xA0 \\xA0{\" \"}\n          </div>\n          \\xA0 \\xA0 \\xA0 \\xA0 \\xA0{\" \"}\n          <div>\n            \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 <b>Commit SHA: </b> {build.commit_short}\\xA0 \\xA0 \\xA0 \\xA0 \\xA0{\" \"}\n          </div>\n          \\xA0 \\xA0 \\xA0 \\xA0 \\xA0{\" \"}\n          <div>\n            \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 <b>State: </b> {build.aasm_state}\\xA0 \\xA0 \\xA0 \\xA0 \\xA0{\" \"}\n          </div>\n          \\xA0 \\xA0 \\xA0 \\xA0{\" \"}\n        </Grid>\n        \\xA0 \\xA0 \\xA0 \\xA0{\" \"}\n        <Grid\n          item\n          xs={9}\n          style={{\n            border: \"2px\",\n            backgroundColor: \"#343a40\",\n            fontSize: \"0.9rem\",\n            fontFamily: \"Monaco\",\n            color: \"white\",\n            padding: 10,\n          }}\n        >\n          \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\n          {build.logs.map((log) => (\n            <div>{log.message} </div>\n          ))}\n          \\xA0 \\xA0 \\xA0 \\xA0{\" \"}\n        </Grid>\n        \\xA0 \\xA0 \\xA0{\" \"}\n      </Grid>\n      \\xA0 \\xA0\n    </>\n  );\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"For demo purposes I probably went a little overboard with the styling, but I wanted to create something that resembles our actual application which you saw at the start of this post. The two things needed to power the page are the \",(0,n.jsx)(e.em,{children:\"build\"}),\", which is retrieved with \",(0,n.jsx)(e.em,{children:\"useSelector\"}),\" and the \",(0,n.jsx)(e.em,{children:\"handleMessageReceived\"}),\" function, which dispatches \",(0,n.jsx)(e.em,{children:\"updateBuildFromMessage\"}),\" every time we receive a message through Action Cable. We supply the \",(0,n.jsx)(e.em,{children:\"\\u201DBuildChannel\\u201D\"}),\" and \",(0,n.jsx)(e.em,{children:\"build.id\"}),\" as the channel and room to \",(0,n.jsx)(e.em,{children:\"ActionCableWrapper\"}),\" along with \",(0,n.jsx)(e.em,{children:\"handleMessageReceived\"}),\" as the \",(0,n.jsx)(e.em,{children:\"onReceived\"}),\" function.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"In the video below I\\u2019ll move the build through its different states and we\\u2019ll be able to see the frontend receive the messages, update the state, and add the logs to the screen.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/57d547202f306ddf41f2b8df93ed8650.gif\",alt:\"\"})}),`\n`,(0,n.jsxs)(e.h3,{id:\"conclusion\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#conclusion\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Conclusion\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"That's a wrap on my adventure into how we set up our Action Cable integration with Redux Toolkit. There are tons of places in the application we\\u2019re going to be adding live updates too so that our users will always be up to date on the state of their application. I hope you enjoyed taking a peek inside some development work at Release. If you're interested in having an ephemeral environment created whenever we receive a Pull Request webhook from your Repository, head on over to the \",(0,n.jsx)(e.a,{href:\"https://release.com\",children:\"homepage\"}),\" and sign up! If you\\u2019d like to join our awesome team, check out our \",(0,n.jsx)(e.a,{href:\"https://releasehub.com/company\",children:\"job listings\"}),\".\"]})]})}function _(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(c,t)})):c(t)}var y=_;return v(R);})();\n;return Component;"
  },
  "_id": "blog/posts/how-release-uses-action-cable-redux-toolkit.mdx",
  "_raw": {
    "sourceFilePath": "blog/posts/how-release-uses-action-cable-redux-toolkit.mdx",
    "sourceFileName": "how-release-uses-action-cable-redux-toolkit.mdx",
    "sourceFileDir": "blog/posts",
    "contentType": "mdx",
    "flattenedPath": "blog/posts/how-release-uses-action-cable-redux-toolkit"
  },
  "type": "BlogPost",
  "computedSlug": "how-release-uses-action-cable-redux-toolkit"
}