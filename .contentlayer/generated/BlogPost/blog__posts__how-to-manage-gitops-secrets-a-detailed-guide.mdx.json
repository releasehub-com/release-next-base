{
  "title": "How to Manage GitOps Secrets: A Detailed Guide",
  "summary": "GitOps practices promote storing all your configs in git repositories. Learn how to store your secrets in plain text.",
  "publishDate": "Tue Aug 23 2022 20:41:42 GMT+0000 (Coordinated Universal Time)",
  "author": "ashley-penney",
  "readingTime": 6,
  "categories": [
    "kubernetes",
    "platform-engineering"
  ],
  "mainImage": "/blog-images/96e5afb078f22a510c88413dcb278756.jpg",
  "imageAlt": "a small black toy",
  "showCTA": true,
  "ctaCopy": "Enhance GitOps security with Release's ephemeral environments for secure secret management and streamlined collaboration.",
  "ctaLink": "https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=how-to-manage-gitops-secrets-a-detailed-guide",
  "relatedPosts": [
    ""
  ],
  "ogImage": "/blog-images/96e5afb078f22a510c88413dcb278756.jpg",
  "excerpt": "GitOps practices promote storing all your configs in git repositories. Learn how to store your secrets in plain text.",
  "tags": [
    "kubernetes",
    "platform-engineering"
  ],
  "ctaButton": "Try Release for Free",
  "body": {
    "raw": "\nGitOps is becoming increasingly popular. More and more companies have started using Git as the source of truth for their infrastructure and application configuration. However, with its advantages comes also challenges. For example, if all your configuration is stored in Git, how do you manage secrets? You can't simply commit your passwords and tokens in clear text to the Git repository even if that repository is private and only a few people have access to it. In this post, you'll learn how to manage GitOps secrets securely. Stay tuned.\n\n![](/blog-images/f808540d87cebe56d7ee1d06ba115259.png)\n\n### GitOps vs Secrets\n\nIf you've never used GitOps before, here's a short introduction for you. GitOps is a way of managing infrastructure and application configuration purely via Git repositories in a declarative manner. Here's how it works: You store all the configuration in Git, and then you have a GitOps tool installed somewhere that constantly monitors changes to that Git repository and applies infrastructure and application changes once it detects that something changed in the repository. The whole point of GitOps is that you have one, centralized, single point of truth for all your infrastructure and application configuration. GitOps is most commonly used with Kubernetes.\n\nBut as mentioned in the beginning of this post, there are some challenges when using GitOps. And the biggest one is secret management. There will be many secrets that your infrastructure will require. Your application configuration is probably full of secrets too. And it ought to go without saying that storing secrets in the Git repository in plain text is a security vulnerability. That's true even if that repository is private. You need a different solution for that, but ideally something that still works in a GitOps manner. This means it would be great not to have a separate process to define secrets. I'll show you how it can be done.\n\n### Secrets the GitOps Way\n\nThere are two popular ways of solving this problem. They work quite differently, but both achieve the same outcome: the ability to store secrets or their references in a Git repository. Which one you choose will depend on your company's needs. Let's discuss both of them.\n\n#### SealedSecrets\n\nWe already established that you can't store secrets in plain text in a Git repository. But how about storing them in a non-plain-text version? That's precisely what the [SealedSecrets](https://github.com/bitnami-labs/sealed-secrets) tool does. It allows you to encrypt your secrets and only store their encrypted version in your Git repository. Simple as that.\n\nHow does SealedSecrets work, you ask? You install a SealedSecrets controller on your Kubernetes cluster and the **kubeseal** binary on your local machine. SealedSecrets will generate private and public keys for encrypting the secrets. Before committing a secret to a Git repository, you'll use **kubeseal** binary to encrypt it. Then, in an encrypted form, it's totally safe to store it in a repository, and only the SealedSecrets controller running in your Kubernetes cluster will be able to decrypt it. Quite smart, if you ask me.\n\n#### How to Use SealedSecrets\n\nFirst, follow the installation instructions for SealedSecrets [here](https://github.com/bitnami-labs/sealed-secrets#installation). Once you have it up and running, you can try to seal your first secret with kubeseal. Let's create a simple Kubernetes secret definition YAML file and use kubeseal to seal it.\n\n```yaml\n\napiVersion: v1\nkind: Secret\nmetadata:  \n  name: example-secret\ntype: Opaque\ndata:\n  username: my-username\n  password: super-secret-password\n\n```\n\nOnce you have the file, you can pipe its content to the kubeseal binary.\n\n```yaml\ncat secret.yaml| kubeseal --controller-name=sealed-secrets-controller --format yaml > sealed-secret.yaml\n```\n\nAnd if you now take a look at the created sealed-secret.yaml file, you'll see that the actual username and password values are encrypted.\n\n```yaml\n\n$ cat sealed-secret.yaml\napiVersion: bitnami.com/v1alpha1\nkind: SealedSecret\nmetadata:\n  creationTimestamp: null\n  name: example-secret\n  namespace: default\nspec:\n  encryptedData:\n    password: AgC7jlVk(...)eb+XOk5/99fKHk=\n    username: AgAHbCU7(...)hIgv5D6LDYopF4n\n  template:\n    data: null\n    metadata:\n      creationTimestamp: null\n      name: example-secret\n      namespace: default\n    type: Opaque\n\n```\n\nThis file is now safe to be stored in a Git repository since only a SealedSecrets controller that was used to encrypt this file will be able to decrypt it.\n\nBut how do you consume that secret in your cluster? It's very straightforward. You can directly apply that sealed file to your cluster, and the SealedSecrets controller running on it will automatically unseal it and create a standard Kubernetes secret resource from it. Let's take a look.\n\n```yaml\n$ kubectl apply -f sealed-secret.yaml\nsealedsecret.bitnami.com/example-secret created\n\n$ kubectl get secret\nNAME                                 TYPE                 DATA   AGE\nexample-secret                       Opaque               2      7s\n```\n\nFrom now on, you can use **example-secret** just like any standard Kubernetes secret.\n\n#### ExternalSecrets\n\nAnother way to store secrets for your GitOps needs is using [ExternalSecrets](https://external-secrets.io/). It works differently than SealedSecrets but also solves the problem of storing plain text secrets in a Git repository. ExternalSecrets does this by removing the need to store the actual secret in your repository. Instead, your secret can be safely stored in a secret vault, and you only need to store a reference to a secret in your repository.\n\nSo instead of having, for example, the actual username and password in a file in your Git, you'll instead have a file that says something like \"this username is password is stored in that secret vault, under this key.\" And then it's the external secret operator's job to go and fetch the actual value for you when you need it. Let's try that.\n\n![](/blog-images/51c0cf27ba7ead6a04410e970bd6ce75.png)\n\n#### Using ESO\n\nThe external secrets operator can be installed just like any other tool using Helm. You can follow the installation and initial configuration steps [here](https://external-secrets.io/v0.5.8/guides-getting-started/). Once you have ExternalSecrets up and running, using it is quite simple. You first need to add your secrets to the secret vault that you want to use and then create an ExternalSecrets reference file. This file will be a replacement for your typical Kubernetes secret definition file.\n\nAs explained before, working with ESO means referencing the actual secrets from an external secret vault. So, you create an external secret resource, and the external secret operator will fetch the actual secret from an external vault in the background and create an actual Kubernetes secret for you. Here's an example:\n\n```yaml\n\napiVersion: external-secrets.io/v1beta1\nkind: ExternalSecret\nmetadata:\n  name: database-externalsecret\nspec:\n  refreshInterval: 3h\n  secretStoreRef:\n    name: azure-keyvault\n    kind: SecretStore\n  target:\n    name: database-secret\n    creationPolicy: Owner\n  data:\n  - secretKey: database-secret-dev\n    remoteRef:\n      key: database-secret-dev\n\n```\n\nThat is an ExternalSecrets definition file that tells ESO to fetch the value of the **database-secret-dev** key from the Azure Key Vault and create a Kubernetes secret called **database-secret** from it. As you can see, we don't have actual secret values in this file, so storing it in a Git repository is perfectly fine.\n\nIt's the same when it comes to consuming secrets. You simply apply that ExternalSecrets definition file to your cluster, and the ESO operator will automatically fetch the secret from the defined secret vault and create an actual Kubernetes secret from it.\n\n```yaml\n$ kubectl apply -f external-secret.yaml\nexternalsecret.external-secrets.io/database-externalsecret created\n\n$ kubectl get secret\nNAME                                 TYPE                 DATA   AGE\nexample-secret                       Opaque               2      12m\ndatabase-secret                      Opaque               2      4s\n```\n\n### Summary\n\nAs you can see, the GitOps secrets problem can be solved. It's not even that difficult. However, it does include some extra steps and tools. But once the initial setup is done, it doesn't take much more daily effort to manage secrets securely in your GitOps practices.\n\nIf you want to learn more about secrets or GitOps, you can find more content on [our blog](https://release.com/blog).\n",
    "code": "var Component=(()=>{var d=Object.create;var s=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var g=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),f=(a,e)=>{for(var n in e)s(a,n,{get:e[n],enumerable:!0})},i=(a,e,n,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of p(e))!y.call(a,r)&&r!==n&&s(a,r,{get:()=>e[r],enumerable:!(o=u(e,r))||o.enumerable});return a};var b=(a,e,n)=>(n=a!=null?d(m(a)):{},i(e||!a||!a.__esModule?s(n,\"default\",{value:a,enumerable:!0}):n,a)),w=a=>i(s({},\"__esModule\",{value:!0}),a);var c=g((O,l)=>{l.exports=_jsx_runtime});var S={};f(S,{default:()=>k,frontmatter:()=>v});var t=b(c()),v={title:\"How to Manage GitOps Secrets: A Detailed Guide\",summary:\"GitOps practices promote storing all your configs in git repositories. Learn how to store your secrets in plain text.\",publishDate:\"Tue Aug 23 2022 20:41:42 GMT+0000 (Coordinated Universal Time)\",author:\"ashley-penney\",readingTime:6,categories:[\"kubernetes\",\"platform-engineering\"],mainImage:\"/blog-images/96e5afb078f22a510c88413dcb278756.jpg\",imageAlt:\"a small black toy\",showCTA:!0,ctaCopy:\"Enhance GitOps security with Release's ephemeral environments for secure secret management and streamlined collaboration.\",ctaLink:\"https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=how-to-manage-gitops-secrets-a-detailed-guide\",relatedPosts:[\"\"],ogImage:\"/blog-images/96e5afb078f22a510c88413dcb278756.jpg\",excerpt:\"GitOps practices promote storing all your configs in git repositories. Learn how to store your secrets in plain text.\",tags:[\"kubernetes\",\"platform-engineering\"],ctaButton:\"Try Release for Free\"};function h(a){let e=Object.assign({p:\"p\",img:\"img\",h3:\"h3\",a:\"a\",span:\"span\",h4:\"h4\",strong:\"strong\",pre:\"pre\",code:\"code\"},a.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:\"GitOps is becoming increasingly popular. More and more companies have started using Git as the source of truth for their infrastructure and application configuration. However, with its advantages comes also challenges. For example, if all your configuration is stored in Git, how do you manage secrets? You can't simply commit your passwords and tokens in clear text to the Git repository even if that repository is private and only a few people have access to it. In this post, you'll learn how to manage GitOps secrets securely. Stay tuned.\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/blog-images/f808540d87cebe56d7ee1d06ba115259.png\",alt:\"\"})}),`\n`,(0,t.jsxs)(e.h3,{id:\"gitops-vs-secrets\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#gitops-vs-secrets\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"GitOps vs Secrets\"]}),`\n`,(0,t.jsx)(e.p,{children:\"If you've never used GitOps before, here's a short introduction for you. GitOps is a way of managing infrastructure and application configuration purely via Git repositories in a declarative manner. Here's how it works: You store all the configuration in Git, and then you have a GitOps tool installed somewhere that constantly monitors changes to that Git repository and applies infrastructure and application changes once it detects that something changed in the repository. The whole point of GitOps is that you have one, centralized, single point of truth for all your infrastructure and application configuration. GitOps is most commonly used with Kubernetes.\"}),`\n`,(0,t.jsx)(e.p,{children:\"But as mentioned in the beginning of this post, there are some challenges when using GitOps. And the biggest one is secret management. There will be many secrets that your infrastructure will require. Your application configuration is probably full of secrets too. And it ought to go without saying that storing secrets in the Git repository in plain text is a security vulnerability. That's true even if that repository is private. You need a different solution for that, but ideally something that still works in a GitOps manner. This means it would be great not to have a separate process to define secrets. I'll show you how it can be done.\"}),`\n`,(0,t.jsxs)(e.h3,{id:\"secrets-the-gitops-way\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#secrets-the-gitops-way\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"Secrets the GitOps Way\"]}),`\n`,(0,t.jsx)(e.p,{children:\"There are two popular ways of solving this problem. They work quite differently, but both achieve the same outcome: the ability to store secrets or their references in a Git repository. Which one you choose will depend on your company's needs. Let's discuss both of them.\"}),`\n`,(0,t.jsxs)(e.h4,{id:\"sealedsecrets\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#sealedsecrets\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"SealedSecrets\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"We already established that you can't store secrets in plain text in a Git repository. But how about storing them in a non-plain-text version? That's precisely what the \",(0,t.jsx)(e.a,{href:\"https://github.com/bitnami-labs/sealed-secrets\",children:\"SealedSecrets\"}),\" tool does. It allows you to encrypt your secrets and only store their encrypted version in your Git repository. Simple as that.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"How does SealedSecrets work, you ask? You install a SealedSecrets controller on your Kubernetes cluster and the \",(0,t.jsx)(e.strong,{children:\"kubeseal\"}),\" binary on your local machine. SealedSecrets will generate private and public keys for encrypting the secrets. Before committing a secret to a Git repository, you'll use \",(0,t.jsx)(e.strong,{children:\"kubeseal\"}),\" binary to encrypt it. Then, in an encrypted form, it's totally safe to store it in a repository, and only the SealedSecrets controller running in your Kubernetes cluster will be able to decrypt it. Quite smart, if you ask me.\"]}),`\n`,(0,t.jsxs)(e.h4,{id:\"how-to-use-sealedsecrets\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#how-to-use-sealedsecrets\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"How to Use SealedSecrets\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"First, follow the installation instructions for SealedSecrets \",(0,t.jsx)(e.a,{href:\"https://github.com/bitnami-labs/sealed-secrets#installation\",children:\"here\"}),\". Once you have it up and running, you can try to seal your first secret with kubeseal. Let's create a simple Kubernetes secret definition YAML file and use kubeseal to seal it.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-yaml\",children:`\napiVersion: v1\nkind: Secret\nmetadata: \\xA0\n \\xA0name: example-secret\ntype: Opaque\ndata:\n \\xA0username: my-username\n \\xA0password: super-secret-password\n\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"Once you have the file, you can pipe its content to the kubeseal binary.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-yaml\",children:`cat secret.yaml| kubeseal --controller-name=sealed-secrets-controller --format yaml > sealed-secret.yaml\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"And if you now take a look at the created sealed-secret.yaml file, you'll see that the actual username and password values are encrypted.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-yaml\",children:`\n$ cat sealed-secret.yaml\napiVersion: bitnami.com/v1alpha1\nkind: SealedSecret\nmetadata:\n \\xA0creationTimestamp: null\n \\xA0name: example-secret\n \\xA0namespace: default\nspec:\n \\xA0encryptedData:\n \\xA0 \\xA0password: AgC7jlVk(...)eb+XOk5/99fKHk=\n \\xA0 \\xA0username: AgAHbCU7(...)hIgv5D6LDYopF4n\n \\xA0template:\n \\xA0 \\xA0data: null\n \\xA0 \\xA0metadata:\n \\xA0 \\xA0 \\xA0creationTimestamp: null\n \\xA0 \\xA0 \\xA0name: example-secret\n \\xA0 \\xA0 \\xA0namespace: default\n \\xA0 \\xA0type: Opaque\n\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"This file is now safe to be stored in a Git repository since only a SealedSecrets controller that was used to encrypt this file will be able to decrypt it.\"}),`\n`,(0,t.jsx)(e.p,{children:\"But how do you consume that secret in your cluster? It's very straightforward. You can directly apply that sealed file to your cluster, and the SealedSecrets controller running on it will automatically unseal it and create a standard Kubernetes secret resource from it. Let's take a look.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-yaml\",children:`$ kubectl apply -f sealed-secret.yaml\nsealedsecret.bitnami.com/example-secret created\n\n$ kubectl get secret\nNAME \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 TYPE \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 DATA \\xA0 AGE\nexample-secret \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 Opaque \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 2 \\xA0 \\xA0 \\xA07s\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"From now on, you can use \",(0,t.jsx)(e.strong,{children:\"example-secret\"}),\" just like any standard Kubernetes secret.\"]}),`\n`,(0,t.jsxs)(e.h4,{id:\"externalsecrets\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#externalsecrets\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"ExternalSecrets\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Another way to store secrets for your GitOps needs is using \",(0,t.jsx)(e.a,{href:\"https://external-secrets.io/\",children:\"ExternalSecrets\"}),\". It works differently than SealedSecrets but also solves the problem of storing plain text secrets in a Git repository. ExternalSecrets does this by removing the need to store the actual secret in your repository. Instead, your secret can be safely stored in a secret vault, and you only need to store a reference to a secret in your repository.\"]}),`\n`,(0,t.jsx)(e.p,{children:`So instead of having, for example, the actual username and password in a file in your Git, you'll instead have a file that says something like \"this username is password is stored in that secret vault, under this key.\" And then it's the external secret operator's job to go and fetch the actual value for you when you need it. Let's try that.`}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/blog-images/51c0cf27ba7ead6a04410e970bd6ce75.png\",alt:\"\"})}),`\n`,(0,t.jsxs)(e.h4,{id:\"using-eso\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#using-eso\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"Using ESO\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The external secrets operator can be installed just like any other tool using Helm. You can follow the installation and initial configuration steps \",(0,t.jsx)(e.a,{href:\"https://external-secrets.io/v0.5.8/guides-getting-started/\",children:\"here\"}),\". Once you have ExternalSecrets up and running, using it is quite simple. You first need to add your secrets to the secret vault that you want to use and then create an ExternalSecrets reference file. This file will be a replacement for your typical Kubernetes secret definition file.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"As explained before, working with ESO means referencing the actual secrets from an external secret vault. So, you create an external secret resource, and the external secret operator will fetch the actual secret from an external vault in the background and create an actual Kubernetes secret for you. Here's an example:\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-yaml\",children:`\napiVersion: external-secrets.io/v1beta1\nkind: ExternalSecret\nmetadata:\n \\xA0name: database-externalsecret\nspec:\n \\xA0refreshInterval: 3h\n \\xA0secretStoreRef:\n \\xA0 \\xA0name: azure-keyvault\n \\xA0 \\xA0kind: SecretStore\n \\xA0target:\n \\xA0 \\xA0name: database-secret\n \\xA0 \\xA0creationPolicy: Owner\n \\xA0data:\n \\xA0- secretKey: database-secret-dev\n \\xA0 \\xA0remoteRef:\n \\xA0 \\xA0 \\xA0key: database-secret-dev\n\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"That is an ExternalSecrets definition file that tells ESO to fetch the value of the \",(0,t.jsx)(e.strong,{children:\"database-secret-dev\"}),\" key from the Azure Key Vault and create a Kubernetes secret called \",(0,t.jsx)(e.strong,{children:\"database-secret\"}),\" from it. As you can see, we don't have actual secret values in this file, so storing it in a Git repository is perfectly fine.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"It's the same when it comes to consuming secrets. You simply apply that ExternalSecrets definition file to your cluster, and the ESO operator will automatically fetch the secret from the defined secret vault and create an actual Kubernetes secret from it.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-yaml\",children:`$ kubectl apply -f external-secret.yaml\nexternalsecret.external-secrets.io/database-externalsecret created\n\n$ kubectl get secret\nNAME \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 TYPE \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 DATA \\xA0 AGE\nexample-secret \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 Opaque \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 2 \\xA0 \\xA0 \\xA012m\ndatabase-secret \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0Opaque \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 2 \\xA0 \\xA0 \\xA04s\n`})}),`\n`,(0,t.jsxs)(e.h3,{id:\"summary\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#summary\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"Summary\"]}),`\n`,(0,t.jsx)(e.p,{children:\"As you can see, the GitOps secrets problem can be solved. It's not even that difficult. However, it does include some extra steps and tools. But once the initial setup is done, it doesn't take much more daily effort to manage secrets securely in your GitOps practices.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"If you want to learn more about secrets or GitOps, you can find more content on \",(0,t.jsx)(e.a,{href:\"https://release.com/blog\",children:\"our blog\"}),\".\"]})]})}function x(a={}){let{wrapper:e}=a.components||{};return e?(0,t.jsx)(e,Object.assign({},a,{children:(0,t.jsx)(h,a)})):h(a)}var k=x;return w(S);})();\n;return Component;"
  },
  "_id": "blog/posts/how-to-manage-gitops-secrets-a-detailed-guide.mdx",
  "_raw": {
    "sourceFilePath": "blog/posts/how-to-manage-gitops-secrets-a-detailed-guide.mdx",
    "sourceFileName": "how-to-manage-gitops-secrets-a-detailed-guide.mdx",
    "sourceFileDir": "blog/posts",
    "contentType": "mdx",
    "flattenedPath": "blog/posts/how-to-manage-gitops-secrets-a-detailed-guide"
  },
  "type": "BlogPost",
  "computedSlug": "how-to-manage-gitops-secrets-a-detailed-guide"
}