{
  "title": "How to Make the Most of Kubernetes Environment Variables",
  "summary": "There are a few ways to add Kubernetes environment variables. In this post, we are going to learn what they are and when",
  "publishDate": "Mon Feb 07 2022 09:44:46 GMT+0000 (Coordinated Universal Time)",
  "author": "dawid-ziolkowski",
  "readingTime": 5,
  "categories": [
    "kubernetes",
    "platform-engineering"
  ],
  "mainImage": "/blog-images/e99f6e1d23023143b231d942ed8b8ff8.jpg",
  "imageAlt": "kubernetes environment variable secret",
  "showCTA": true,
  "ctaCopy": "Unlock the power of Kubernetes environment variables with Release's on-demand environments for seamless configuration management and deployment.",
  "ctaLink": "https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=kubernetes-environment-variables",
  "relatedPosts": [
    ""
  ],
  "ogImage": "/blog-images/e99f6e1d23023143b231d942ed8b8ff8.jpg",
  "excerpt": "There are a few ways to add Kubernetes environment variables. In this post, we are going to learn what they are and when",
  "tags": [
    "kubernetes",
    "platform-engineering"
  ],
  "ctaButton": "Try Release for Free",
  "body": {
    "raw": "\nIn traditional systems, environment variables play an important role but not always a crucial one. Some applications make more use of environment variables than others. Some prefer configuration files over environment variables. However, when it comes to Kubernetes, environment variables are more important than you may think. It's partially due to how containers work in general and partially due to the specifics of Kubernetes. In this post, you'll learn all about environment variables in Kubernetes.\n\n![environment variables are dynamic key value variables](/blog-images/fa1486359141ce02924db9ee4ba2a0e8.png)\n\n### The Basics\n\nLet's start with the basics. What are environment variables, and why do they exist? Traditionally, environment variables are dynamic key value variables that are accessible to any process running on the system. The operating system itself will set many environment variables that help running processes understand the specifics of the system. Thanks to this, software developers can include logic in their software that makes the programs adjustable to a specific operating system. Environment variables also hold a lot of important information about the user. Things like username, preferred language, user home directory path, and many other useful bits of information.\n\n### User-Defined Environment Variables\n\nAs a user, you can easily create and access your own environment variables. On Unix-based systems, you can do that by executing the **export** command followed by the name of your variable and its value. So, for example, to create an environment variable called **myvar** with a value of **10**, you need to execute the following:\n\n```yaml\nexport myvar=10\n```\n\nYou can then access the value of your variable using a dollar sign followed by your variable name. In our case to print (using Linux command [echo](<https://en.wikipedia.org/wiki/Echo_(command)>)) the value of our variable, we can execute the following:\n\n```yaml\necho $myvar\n```\n\nAnd if you want to print all the environment variables, you can execute either **printenv** or **env** commands. All of this applies to applications running in your pods too.\n\n### Environment Variables in Kubernetes\n\nThe basic principle of environment variables in Kubernetes is the same. However, Kubernetes uses environment variables quite extensively and for a few different things. Therefore, it's good to understand what role environment variables play in Kubernetes. That's especially true if you want to migrate an existing application that doesn't use environment variables that much. You can still create your pods without any environment variables. But if you ignore environment variables in Kubernetes completely, you may lose some of the value of the more powerful Kubernetes features.\n\nBefore we move any further, you also need to know that it's generally good practice when developing microservices to provide configuration to your Docker containers as environment variables whenever possible. This way you can make your Docker image more generic and possibly reuse the same image for different purposes. With that being said, let's see how you can inject some environment variables into your Kubernetes pods.\n\n![The main use case for environment variables in Kubernetes](/blog-images/54e9ae96af3ef573e4be8b343d09d1fd.png)\n\n### Configuration for Your Pods\n\nThe main use case for environment variables in Kubernetes is similar to the one from traditional software development. That is to provide information about the environment to your software. This information is usually used to alter or adapt the way software works to the specifics of the environment. The definition may seem vague, so let me give you an example. Instead of having separate Docker images for your development and production environments, you can use the same image but run your application in a development or production mode based on an environment variable.\n\nIn Kubernetes, environment variables are scoped to a container, and there are three main ways of adding them. Let's break them down.\n\n#### Direct\n\nThe first option is the most straightforward. You can simply specify environment variables directly in your deployment definition with an **env** keyword:\n\n```yaml\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n   name: example-app\nspec:\n   replicas: 1\n   selector:\n     matchLabels:\n       app: example-app\n   template:\n     metadata:\n       labels:\n         app: example-app\n     spec:\n       containers:\n         - name: example-app-dev\n           image: [yourimage]\n           env:\n             - name: ENVIRONMENT\n               value: \"development\"\n```\n\nAs soon as your application is instructed to read the value of an environment variable called \"ENVIRONMENT\", you can use it directly to run your application in the desired mode.\n\nTo run the same application in a production mode, you can simply reuse the same deployment definition. You'll only need to change the environment variable value (and optionally a name of the pod):\n\n```yaml\n---\napiVersion: apps/v1\nkind: Deployment\n(...)\n      containers:\n        - name: example-app-prod\n          image: [yourimage]\n          env:\n            - name: ENVIRONMENT\n              value: \"production\"\n\n```\n\nHere's another example: Imagine that you have a web application that needs to download a product catalogue. This catalogue will then be served to the users. This catalogue may differ in a few ways (by, for example, a country, month, or supplier). This is a perfect use case for an environment variable. Instead of creating many different versions of your application to accommodate different download options, your application can remain generic. Which catalogue it has to download will be determined by the value of some specific environment variable.\n\n#### Secrets\n\nAnother way of providing environment variables to your application is by passing them from Kubernetes [secrets](https://kubernetes.io/docs/concepts/configuration/secret/). You may guess that this is a good option when you need to pass some sensitive information like passwords or tokens. This way you don't specify the value of the environment variable directly in the deployment as we did before. Instead, you instruct Kubernetes to take the value of a specified secret object and use it as a value of an environment variable for your pod.\n\nFor example, if you have a Kubernetes secret like this:\n\n```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n   name: secret_data\ntype: Opaque\nstringData:\n     username: \"example\"\n     password: \"supersecretpassword\"\n```\n\nand you want to pass the password as an environment variable to your pod, you can reference it in the deployment definition as follows:\n\n```yaml\n---\napiVersion: apps/v1\nkind: Deployment\n(...)\n      containers:\n        - name: example-app-prod\n          image: [yourimage]\n          env:\n            # Inject variables from a Kuberentes secret\n            - name: secret_variables\n              valueFrom:\n                secretKeyRef:\n                  name: secret_data\n                  key: password\n\n```\n\nIn your pod, you will then be able to access the actual password (supersecretpassword) by accessing an environment variable called **secret_variable**. For example, in Python you could do it like this:\n\n```yaml\nimport osPASSWORD = os\n.environ.get['secret_variable']\n```\n\nAs you can see, in our example we have **username** and **password** defined in Kubernetes secret, but we are only passing the **password** value to the pod. If you want to pass all the secrets from a Kubernetes secret without specifying each key, you can use **secretRef** instead of **secretKeyRef**. This way, you only need to specify the Kubernetes secret object name, and all the values from it will be automatically loaded as environment variables:\n\n```yaml\n---\napiVersion: apps/v1\nkind: Deployment\n(...)\n      containers:\n        - name: example-app-prod\n          image: [yourimage]\n          env:\n            # Inject variables from a Kuberentes secret\n            - name: secret_variables\n              valueFrom:\n                secretRef:\n                  name: secret_data\n\n```\n\n#### ConfigMaps\n\nAnother way of injecting environment variables into your pods is by using values from [ConfigMaps](https://kubernetes.io/docs/concepts/configuration/configmap/). For example, if you have ConfigMap like this:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n   name: config-data\ndata:\n   environment: \"dev\"\n   timezone: \"UTC\"\n```\n\nand you want to load both **environment** and **timezone** as environment variables into your pod, you can add the following **valueFrom** definition to your deployment:\n\n```yaml\n---\napiVersion: apps/v1\nkind: Deployment\n(...)\n      containers:\n        - name: example-app-prod\n          image: [yourimage]\n          env:\n            # Inject variables from a Kuberentes ConfigMap\n            - name: config_variables\n              valueFrom:\n                configMapRef:\n                  name: config-data\n\n```\n\nIn your pod, you'll then be able to see both environment variables as defined in your ConfigMap:\n\n```yaml\n# env\n\nHOSTNAME=5ad4e9e78e57\nenvironment=dev\ntimezone=UTC\n```\n\nAs with secrets, if you don't want to load all values from a ConfigMap, you can define specific keys instead by changing **configMapRef** to **configMapKeyRef.**\n\nThe main difference between passing environment variables from ConfigMaps and specifying them directly as in the first example is the fact that here the environment variable lifecycle is separated from the pod lifecycle. This means you can update the value of your variable independently from the running pod. Or, to put it differently, you'll need to restart the pod yourself in order to load the new value of the environment variables into the pod. On the other hand, when you specify environment variables directly in the deployment, every change to the variables will automatically trigger pod restart.\n\n### Summary\n\nEnvironment variables play an important role in Kubernetes. You can use them not only to provide basic information about the operating system to your application. You can also use them as the main configuration mechanism for your pods or for passing sensitive information. It's not uncommon in Kubernetes to extract as much configuration as possible info ConfigMaps and environment variables to keep your Docker images as generic as possible. As you can see, even something simple like environment variables have a few options in Kubernetes. If you want to learn more, [Regis Wilson wrote about why Kubernetes is hard and what you can do about it.](https://release.com/blog/why-kubernetes-is-so-hard)\n",
    "code": "var Component=(()=>{var m=Object.create;var r=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var f=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),y=(a,e)=>{for(var o in e)r(a,o,{get:e[o],enumerable:!0})},s=(a,e,o,t)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of p(e))!v.call(a,i)&&i!==o&&r(a,i,{get:()=>e[i],enumerable:!(t=h(e,i))||t.enumerable});return a};var g=(a,e,o)=>(o=a!=null?m(u(a)):{},s(e||!a||!a.__esModule?r(o,\"default\",{value:a,enumerable:!0}):o,a)),b=a=>s(r({},\"__esModule\",{value:!0}),a);var c=f((K,l)=>{l.exports=_jsx_runtime});var N={};y(N,{default:()=>x,frontmatter:()=>w});var n=g(c()),w={title:\"How to Make the Most of Kubernetes Environment Variables\",summary:\"There are a few ways to add Kubernetes environment variables. In this post, we are going to learn what they are and when\",publishDate:\"Mon Feb 07 2022 09:44:46 GMT+0000 (Coordinated Universal Time)\",author:\"dawid-ziolkowski\",readingTime:5,categories:[\"kubernetes\",\"platform-engineering\"],mainImage:\"/blog-images/e99f6e1d23023143b231d942ed8b8ff8.jpg\",imageAlt:\"kubernetes environment variable secret\",showCTA:!0,ctaCopy:\"Unlock the power of Kubernetes environment variables with Release's on-demand environments for seamless configuration management and deployment.\",ctaLink:\"https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=kubernetes-environment-variables\",relatedPosts:[\"\"],ogImage:\"/blog-images/e99f6e1d23023143b231d942ed8b8ff8.jpg\",excerpt:\"There are a few ways to add Kubernetes environment variables. In this post, we are going to learn what they are and when\",tags:[\"kubernetes\",\"platform-engineering\"],ctaButton:\"Try Release for Free\"};function d(a){let e=Object.assign({p:\"p\",img:\"img\",h3:\"h3\",a:\"a\",span:\"span\",strong:\"strong\",pre:\"pre\",code:\"code\",h4:\"h4\"},a.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"In traditional systems, environment variables play an important role but not always a crucial one. Some applications make more use of environment variables than others. Some prefer configuration files over environment variables. However, when it comes to Kubernetes, environment variables are more important than you may think. It's partially due to how containers work in general and partially due to the specifics of Kubernetes. In this post, you'll learn all about environment variables in Kubernetes.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/fa1486359141ce02924db9ee4ba2a0e8.png\",alt:\"environment variables are dynamic key value variables\"})}),`\n`,(0,n.jsxs)(e.h3,{id:\"the-basics\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#the-basics\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"The Basics\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Let's start with the basics. What are environment variables, and why do they exist? Traditionally, environment variables are dynamic key value variables that are accessible to any process running on the system. The operating system itself will set many environment variables that help running processes understand the specifics of the system. Thanks to this, software developers can include logic in their software that makes the programs adjustable to a specific operating system. Environment variables also hold a lot of important information about the user. Things like username, preferred language, user home directory path, and many other useful bits of information.\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"user-defined-environment-variables\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#user-defined-environment-variables\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"User-Defined Environment Variables\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"As a user, you can easily create and access your own environment variables. On Unix-based systems, you can do that by executing the \",(0,n.jsx)(e.strong,{children:\"export\"}),\" command followed by the name of your variable and its value. So, for example, to create an environment variable called \",(0,n.jsx)(e.strong,{children:\"myvar\"}),\" with a value of \",(0,n.jsx)(e.strong,{children:\"10\"}),\", you need to execute the following:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`export myvar=10\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"You can then access the value of your variable using a dollar sign followed by your variable name. In our case to print (using Linux command \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Echo_(command)\",children:\"echo\"}),\") the value of our variable, we can execute the following:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`echo $myvar\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"And if you want to print all the environment variables, you can execute either \",(0,n.jsx)(e.strong,{children:\"printenv\"}),\" or \",(0,n.jsx)(e.strong,{children:\"env\"}),\" commands. All of this applies to applications running in your pods too.\"]}),`\n`,(0,n.jsxs)(e.h3,{id:\"environment-variables-in-kubernetes\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#environment-variables-in-kubernetes\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Environment Variables in Kubernetes\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The basic principle of environment variables in Kubernetes is the same. However, Kubernetes uses environment variables quite extensively and for a few different things. Therefore, it's good to understand what role environment variables play in Kubernetes. That's especially true if you want to migrate an existing application that doesn't use environment variables that much. You can still create your pods without any environment variables. But if you ignore environment variables in Kubernetes completely, you may lose some of the value of the more powerful Kubernetes features.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Before we move any further, you also need to know that it's generally good practice when developing microservices to provide configuration to your Docker containers as environment variables whenever possible. This way you can make your Docker image more generic and possibly reuse the same image for different purposes. With that being said, let's see how you can inject some environment variables into your Kubernetes pods.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/54e9ae96af3ef573e4be8b343d09d1fd.png\",alt:\"The main use case for environment variables in Kubernetes\"})}),`\n`,(0,n.jsxs)(e.h3,{id:\"configuration-for-your-pods\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#configuration-for-your-pods\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Configuration for Your Pods\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The main use case for environment variables in Kubernetes is similar to the one from traditional software development. That is to provide information about the environment to your software. This information is usually used to alter or adapt the way software works to the specifics of the environment. The definition may seem vague, so let me give you an example. Instead of having separate Docker images for your development and production environments, you can use the same image but run your application in a development or production mode based on an environment variable.\"}),`\n`,(0,n.jsx)(e.p,{children:\"In Kubernetes, environment variables are scoped to a container, and there are three main ways of adding them. Let's break them down.\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"direct\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#direct\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Direct\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The first option is the most straightforward. You can simply specify environment variables directly in your deployment definition with an \",(0,n.jsx)(e.strong,{children:\"env\"}),\" keyword:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  \\xA0name: example-app\nspec:\n  \\xA0replicas: 1\n  \\xA0selector:\n  \\xA0 \\xA0matchLabels:\n  \\xA0 \\xA0 \\xA0app: example-app\n  \\xA0template:\n  \\xA0 \\xA0metadata:\n  \\xA0 \\xA0 \\xA0labels:\n  \\xA0 \\xA0 \\xA0 \\xA0app: example-app\n  \\xA0 \\xA0spec:\n  \\xA0 \\xA0 \\xA0containers:\n  \\xA0 \\xA0 \\xA0 \\xA0- name: example-app-dev\n  \\xA0 \\xA0 \\xA0 \\xA0 \\xA0image: [yourimage]\n  \\xA0 \\xA0 \\xA0 \\xA0 \\xA0env:\n  \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0- name: ENVIRONMENT\n  \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0value: \"development\"\n`})}),`\n`,(0,n.jsx)(e.p,{children:'As soon as your application is instructed to read the value of an environment variable called \"ENVIRONMENT\", you can use it directly to run your application in the desired mode.'}),`\n`,(0,n.jsx)(e.p,{children:\"To run the same application in a production mode, you can simply reuse the same deployment definition. You'll only need to change the environment variable value (and optionally a name of the pod):\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`---\napiVersion: apps/v1\nkind: Deployment\n(...)\n \\xA0 \\xA0 \\xA0containers:\n \\xA0 \\xA0 \\xA0 \\xA0- name: example-app-prod\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0image: [yourimage]\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0env:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0- name: ENVIRONMENT\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0value: \"production\"\n\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Here's another example: Imagine that you have a web application that needs to download a product catalogue. This catalogue will then be served to the users. This catalogue may differ in a few ways (by, for example, a country, month, or supplier). This is a perfect use case for an environment variable. Instead of creating many different versions of your application to accommodate different download options, your application can remain generic. Which catalogue it has to download will be determined by the value of some specific environment variable.\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"secrets\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#secrets\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Secrets\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Another way of providing environment variables to your application is by passing them from Kubernetes \",(0,n.jsx)(e.a,{href:\"https://kubernetes.io/docs/concepts/configuration/secret/\",children:\"secrets\"}),\". You may guess that this is a good option when you need to pass some sensitive information like passwords or tokens. This way you don't specify the value of the environment variable directly in the deployment as we did before. Instead, you instruct Kubernetes to take the value of a specified secret object and use it as a value of an environment variable for your pod.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"For example, if you have a Kubernetes secret like this:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`apiVersion: v1\nkind: Secret\nmetadata:\n  \\xA0name: secret_data\ntype: Opaque\nstringData:\n  \\xA0 \\xA0username: \"example\"\n  \\xA0 \\xA0password: \"supersecretpassword\"\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"and you want to pass the password as an environment variable to your pod, you can reference it in the deployment definition as follows:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`---\napiVersion: apps/v1\nkind: Deployment\n(...)\n \\xA0 \\xA0 \\xA0containers:\n \\xA0 \\xA0 \\xA0 \\xA0- name: example-app-prod\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0image: [yourimage]\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0env:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0# Inject variables from a Kuberentes secret\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0- name: secret_variables\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0valueFrom:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0secretKeyRef:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0name: secret_data\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0key: password\n\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"In your pod, you will then be able to access the actual password (supersecretpassword) by accessing an environment variable called \",(0,n.jsx)(e.strong,{children:\"secret_variable\"}),\". For example, in Python you could do it like this:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`import osPASSWORD = os\n.environ.get['secret_variable']\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"As you can see, in our example we have \",(0,n.jsx)(e.strong,{children:\"username\"}),\" and \",(0,n.jsx)(e.strong,{children:\"password\"}),\" defined in Kubernetes secret, but we are only passing the \",(0,n.jsx)(e.strong,{children:\"password\"}),\" value to the pod. If you want to pass all the secrets from a Kubernetes secret without specifying each key, you can use \",(0,n.jsx)(e.strong,{children:\"secretRef\"}),\" instead of \",(0,n.jsx)(e.strong,{children:\"secretKeyRef\"}),\". This way, you only need to specify the Kubernetes secret object name, and all the values from it will be automatically loaded as environment variables:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`---\napiVersion: apps/v1\nkind: Deployment\n(...)\n \\xA0 \\xA0 \\xA0containers:\n \\xA0 \\xA0 \\xA0 \\xA0- name: example-app-prod\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0image: [yourimage]\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0env:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0# Inject variables from a Kuberentes secret\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0- name: secret_variables\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0valueFrom:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0secretRef:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0name: secret_data\n\n`})}),`\n`,(0,n.jsxs)(e.h4,{id:\"configmaps\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#configmaps\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"ConfigMaps\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Another way of injecting environment variables into your pods is by using values from \",(0,n.jsx)(e.a,{href:\"https://kubernetes.io/docs/concepts/configuration/configmap/\",children:\"ConfigMaps\"}),\". For example, if you have ConfigMap like this:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`apiVersion: v1\nkind: ConfigMap\nmetadata:\n  \\xA0name: config-data\ndata:\n  \\xA0environment: \"dev\"\n  \\xA0timezone: \"UTC\"\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"and you want to load both \",(0,n.jsx)(e.strong,{children:\"environment\"}),\" and \",(0,n.jsx)(e.strong,{children:\"timezone\"}),\" as environment variables into your pod, you can add the following \",(0,n.jsx)(e.strong,{children:\"valueFrom\"}),\" definition to your deployment:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`---\napiVersion: apps/v1\nkind: Deployment\n(...)\n \\xA0 \\xA0 \\xA0containers:\n \\xA0 \\xA0 \\xA0 \\xA0- name: example-app-prod\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0image: [yourimage]\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0env:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0# Inject variables from a Kuberentes ConfigMap\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0- name: config_variables\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0valueFrom:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0configMapRef:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0name: config-data\n\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"In your pod, you'll then be able to see both environment variables as defined in your ConfigMap:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`# env\n\nHOSTNAME=5ad4e9e78e57\nenvironment=dev\ntimezone=UTC\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"As with secrets, if you don't want to load all values from a ConfigMap, you can define specific keys instead by changing \",(0,n.jsx)(e.strong,{children:\"configMapRef\"}),\" to \",(0,n.jsx)(e.strong,{children:\"configMapKeyRef.\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"The main difference between passing environment variables from ConfigMaps and specifying them directly as in the first example is the fact that here the environment variable lifecycle is separated from the pod lifecycle. This means you can update the value of your variable independently from the running pod. Or, to put it differently, you'll need to restart the pod yourself in order to load the new value of the environment variables into the pod. On the other hand, when you specify environment variables directly in the deployment, every change to the variables will automatically trigger pod restart.\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"summary\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#summary\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Summary\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Environment variables play an important role in Kubernetes. You can use them not only to provide basic information about the operating system to your application. You can also use them as the main configuration mechanism for your pods or for passing sensitive information. It's not uncommon in Kubernetes to extract as much configuration as possible info ConfigMaps and environment variables to keep your Docker images as generic as possible. As you can see, even something simple like environment variables have a few options in Kubernetes. If you want to learn more, \",(0,n.jsx)(e.a,{href:\"https://release.com/blog/why-kubernetes-is-so-hard\",children:\"Regis Wilson wrote about why Kubernetes is hard and what you can do about it.\"})]})]})}function k(a={}){let{wrapper:e}=a.components||{};return e?(0,n.jsx)(e,Object.assign({},a,{children:(0,n.jsx)(d,a)})):d(a)}var x=k;return b(N);})();\n;return Component;"
  },
  "_id": "blog/posts/kubernetes-environment-variables.mdx",
  "_raw": {
    "sourceFilePath": "blog/posts/kubernetes-environment-variables.mdx",
    "sourceFileName": "kubernetes-environment-variables.mdx",
    "sourceFileDir": "blog/posts",
    "contentType": "mdx",
    "flattenedPath": "blog/posts/kubernetes-environment-variables"
  },
  "type": "BlogPost",
  "computedSlug": "kubernetes-environment-variables"
}