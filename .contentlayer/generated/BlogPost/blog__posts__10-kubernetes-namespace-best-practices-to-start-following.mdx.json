{
  "title": "10 Kubernetes Namespace Best Practices to Start Following",
  "summary": "This post will discuss how you can use kubernetes namespace to achieve even more efficiency by following best practices.",
  "publishDate": "Mon Sep 19 2022 18:53:42 GMT+0000 (Coordinated Universal Time)",
  "author": "marion-newman",
  "readingTime": 5,
  "categories": [
    "kubernetes",
    "platform-engineering"
  ],
  "mainImage": "/blog-images/b90c46ea0d9d01c1c904f3758308d591.jpg",
  "imageAlt": "a person writing on a book",
  "showCTA": true,
  "ctaCopy": "Improve Kubernetes efficiency with Release's on-demand environments, following best practices for resource segregation and allocation.",
  "ctaLink": "https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=10-kubernetes-namespace-best-practices-to-start-following",
  "relatedPosts": [
    ""
  ],
  "ogImage": "/blog-images/b90c46ea0d9d01c1c904f3758308d591.jpg",
  "excerpt": "This post will discuss how you can use kubernetes namespace to achieve even more efficiency by following best practices.",
  "tags": [
    "kubernetes",
    "platform-engineering"
  ],
  "ctaButton": "Try Release for Free",
  "body": {
    "raw": "\nNamespaces are the most efficient resource segregation and allocation method in the Kubernetes cluster.\n\nThis post will discuss how you can use namespaces to improve efficiency by following best practices.\n\n![](/blog-images/0960ec04f74ef2c8f6a971e6d156cbf7.png)\n\n### What are Namespaces in Kubernetes, and Why are They Important?\n\nBefore moving to best practices, let’s briefly look into what namespaces are and why you should use them.\n\nSuppose you want to use a single cluster as both your performance and dev clusters in order to save cost on computational resources. To do this in Kubernetes, you can use namespaces to segregate [pod](https://release.com/blog/kubernetes-pod-a-beginners-guide-to-an-essential-resource) services while running them on a single cluster.\n\nThe namespace system is not new to computing; almost all programming languages use namespaces. Wherever you have encountered namespaces, the fundamental purpose is the same: They are used for logical grouping.\n\nNamespaces are a feature of the Linux kernel, and containers use namespaces extensively. Each container has its own storage namespace and network namespace for the segregation and allocation of resources.\n\nThe [Kubernetes namespace](https://release.com/blog/kubernetes-namespaces-the-ultimate-guide) refers to virtual clusters that are backed by the same physical cluster. This option is designed for use in environments with multiple users spread across multiple work teams or projects.\n\n### Types of Kubernetes Namespaces\n\nThese are the four initial namespaces that Kubernetes starts with:\n\n- **\"default\"—**The default namespace set by the system. It's intended for objects that don't specify any of the namespaces.\n- **\"kube-system\"—**This namespace is assigned to resources that are created by the Kubernetes system.\n- **\"kube-public\"—**This namespace is created by the system and is visible to all users, even users that aren't authenticated. Usually, this namespace is focused on the internal use of the platform cluster in situations where some of the resources need to be publicly visible and readable for the entire cluster.\n- ‍**\"kube-node-lease \"—**This namespace holds lease objects associated with each node. These leases allow the kubelet to send heartbeats so that you can determine node availability.\n\nIn addition to these four namespaces, you can create custom namespaces.\n\n### Naming Convention of Kubernetes Namespaces\n\nNamespaces in Kubernetes follow the same naming convention as other objects created in Kubernetes.\n\nYou can create a name with a maximum length of 253 characters using only alphanumeric characters and hyphens. Names cannot start with a hyphen and the alpha characters can only be lowercase.\n\n### 10 Kubernetes Namespace Best Practices\n\nLet's take a look at 10 Kubernetes namespace best practices so that you can get the most out of this feature.\n\nIt's important to note that the actual utility of these practices depends on your particular needs and the nature of the project.\n\n#### 1\\. Use Convenient and Scalable Names\n\nNaming is at the root of programming and is one of its basic building blocks. Names should be meaningful and provide context. Therefore, it’s recommended to use names that are expressive and scalable.\n\nFor example, if you're working on a streaming application, you can name the namespace \"stream\". For the different development environments, you can scale this name by adding a suffix, for example, \"stream-dev\" for the development environment, \"stream-test\" for testing, and \"stream-prod\" for production.\n\n#### 2\\. Attach Labels to Namespaces\n\nLabels in Kubernetes are not just a way to distinguish resources, but they're also a major source of metadata that can be used to log, analyze, and audit resources.\n\nThough it’s considered a best practice to use labels throughout Kubernetes, using them in a namespace is essential when you have a large team. Here is an example:\n\n```yaml\nkubectl create namespace namespace_name\nkubectl label namespaces namespace_name labelname=value --overwrite=true\n```\n\n#### 3\\. Use RBAC to Allocate Resources\n\nUsing role-based access control (RBAC), you can authorize and limit users’ access to certain resources. You can manage access locally within a cluster and globally to the entire cluster.\n\nTo use RBAC for a specific namespace, you can use the _Role_ resource type while the _ClusterRole_ resource type can be used globally.\n\nUsing RBAC helps you to secure clusters and manage resources by defining permissions based on roles.\n\n#### 4\\. Use _ResourceQuota_ and _LimitRange_\n\nThe namespaces in a cluster don't all need the same resources. Giving all namespaces equal resources can compromise the performance of key namespaces. Use a resource quota to limit the resource usage of particular namespaces.\n\nUse Kubernetes _ResourceQuota_ to control the number of resources that can be created in a namespace and _LimitRange_ to restrict the consumption of resources by pods.\n\nHere's an example of how to use _ResourceQuota_:\n\n```yaml\n\napiVersion: v1\n      kind: ResourceQuota\n      name: default-resourcequota\n      synchronize: true\n      namespace: stream\n      data:\n        spec:\n          hard:\n            requests.cpu: '4'\n            requests.memory: ‘16Gi’\n            limits.cpu: '4'\n            limits.memory: ‘16Gi’\n\n```\n\nAnd here's an example of how to use _LimitRange_:\n\n```yaml\n\napiVersion: v1\n      kind: LimitRange\n      name: default-limitrange\n      synchronize: true\n      namespace: stream\n      data:\n        spec:\n          limits:\n          - default:\n              cpu: 500m\n              memory: 1Gi\n            defaultRequest:\n              cpu: 200m\n              memory: 256Mi\n\n```\n\n![](/blog-images/8129568b7e7e6ef40c342ba8bd48df8a.png)\n\n#### 5\\. Use a NetworkPolicy\n\nKubernetes allows different pods across clusters to communicate. To secure the pods and only allow the desired traffic to pods from selected sources, it's necessary to use a NetworkPolicy for each namespace along with a CNI plugin to restrict communications.\n\nUsing a NetworkPolicy will allow you to deny ingress, egress, or any unwanted traffic coming into pods through the namespace.  \n\nHere's an example of how to use a NetworkPolicy:\n\n```yaml\n\napiVersion: networking.k8s.io/v1\n      kind: NetworkPolicy\n      name: default-deny\n      namespace: stream\n      synchronize: true\n      data:\n        spec:\n          # select all pods in the Namespace\n          podSelector: {}\n          # deny selected or all traffic\n          policyTypes:\n          - Ingress\n          - Egress\n\n```\n\n#### 6\\. Don’t Create Too Many Namespaces\n\nEven though there's no restriction on how many namespaces you can create and how many namespaces Kubernetes can handle, it's best to avoid creating too many namespaces.\n\nCreating namespaces without any definite function can become difficult to manage and too many namespaces can affect the efficient consumption of resources.\n\n#### 7\\. Don’t Shy Away From Creating a Cluster\n\nNamespaces are used to create virtual clusters to segregate resources and reduce costs. However, it's important to understand that as your team grows, the better FinOps approach is to create additional clusters rather than creating namespaces so that you don't to compromise on performance.\n\n#### 8\\. Don’t Use the Default Namespace\n\nAll objects created without a specified namespace are placed in the Kubernetes \"default\" namespace. If you use the \"default\" namespace, it can become difficult to segregate objects in it or implement RBAC and NetworkPolicies.\n\n#### 9\\. Have an Idea of What’s Inside\n\nFor better management of the Kubernetes cluster, it's important to understand which objects and resources are located in namespaces. This includes objects such as pods, replication controllers managed by the Kubernetes controller manager, and others.\n\nHowever, some elements are responsible for representing these resources are found outside Kubernetes namespaces. Additionally, low-level resources, such as persistent volumes and nodes, aren't found within namespaces. Services like [Release](https://release.com/) use dynamic provisioning in Kubernetes to provide on-demand environments that reduce the management overhead required to create persistent volumes.\n\n![](/blog-images/3a54975116f4f4b2a7d02a6c569e61f4.png)\n\n#### 10\\. Sync Secrets\n\nSecrets in Kubernetes often need to exist in multiple namespaces in a cluster so pods can access them. Registry credentials, for example, need to exist in all namespaces in a cluster. If you have many namespaces, managing registry credentials manually can be tricky.\n\nSyncing secrets allows you to copy \"regcred\" to all new namespaces when they are created and pushes updates to the copied secrets.\n\n### Conclusion\n\nThe use of namespaces in Kubernetes is a convenient way to organize and manage resources. If you know how to use namespaces effectively, it can make a significant difference in the performance of your Kubernetes workflows and help you enhance the operability of your clusters while saving on cost.\n\n‍\n",
    "code": "var Component=(()=>{var m=Object.create;var c=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var g=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),b=(a,e)=>{for(var s in e)c(a,s,{get:e[s],enumerable:!0})},o=(a,e,s,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of u(e))!f.call(a,t)&&t!==s&&c(a,t,{get:()=>e[t],enumerable:!(r=d(e,t))||r.enumerable});return a};var y=(a,e,s)=>(s=a!=null?m(p(a)):{},o(e||!a||!a.__esModule?c(s,\"default\",{value:a,enumerable:!0}):s,a)),w=a=>o(c({},\"__esModule\",{value:!0}),a);var l=g((x,i)=>{i.exports=_jsx_runtime});var T={};b(T,{default:()=>N,frontmatter:()=>k});var n=y(l()),k={title:\"10 Kubernetes Namespace Best Practices to Start Following\",summary:\"This post will discuss how you can use kubernetes namespace to achieve even more efficiency by following best practices.\",publishDate:\"Mon Sep 19 2022 18:53:42 GMT+0000 (Coordinated Universal Time)\",author:\"marion-newman\",readingTime:5,categories:[\"kubernetes\",\"platform-engineering\"],mainImage:\"/blog-images/b90c46ea0d9d01c1c904f3758308d591.jpg\",imageAlt:\"a person writing on a book\",showCTA:!0,ctaCopy:\"Improve Kubernetes efficiency with Release's on-demand environments, following best practices for resource segregation and allocation.\",ctaLink:\"https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=10-kubernetes-namespace-best-practices-to-start-following\",relatedPosts:[\"\"],ogImage:\"/blog-images/b90c46ea0d9d01c1c904f3758308d591.jpg\",excerpt:\"This post will discuss how you can use kubernetes namespace to achieve even more efficiency by following best practices.\",tags:[\"kubernetes\",\"platform-engineering\"],ctaButton:\"Try Release for Free\"};function h(a){let e=Object.assign({p:\"p\",img:\"img\",h3:\"h3\",a:\"a\",span:\"span\",ul:\"ul\",li:\"li\",h4:\"h4\",pre:\"pre\",code:\"code\",em:\"em\"},a.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"Namespaces are the most efficient resource segregation and allocation method in the Kubernetes cluster.\"}),`\n`,(0,n.jsx)(e.p,{children:\"This post will discuss how you can use namespaces to improve efficiency by following best practices.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/0960ec04f74ef2c8f6a971e6d156cbf7.png\",alt:\"\"})}),`\n`,(0,n.jsxs)(e.h3,{id:\"what-are-namespaces-in-kubernetes-and-why-are-they-important\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#what-are-namespaces-in-kubernetes-and-why-are-they-important\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"What are Namespaces in Kubernetes, and Why are They Important?\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Before moving to best practices, let\\u2019s briefly look into what namespaces are and why you should use them.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Suppose you want to use a single cluster as both your performance and dev clusters in order to save cost on computational resources. To do this in Kubernetes, you can use namespaces to segregate \",(0,n.jsx)(e.a,{href:\"https://release.com/blog/kubernetes-pod-a-beginners-guide-to-an-essential-resource\",children:\"pod\"}),\" services while running them on a single cluster.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The namespace system is not new to computing; almost all programming languages use namespaces. Wherever you have encountered namespaces, the fundamental purpose is the same: They are used for logical grouping.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Namespaces are a feature of the Linux kernel, and containers use namespaces extensively. Each container has its own storage namespace and network namespace for the segregation and allocation of resources.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.a,{href:\"https://release.com/blog/kubernetes-namespaces-the-ultimate-guide\",children:\"Kubernetes namespace\"}),\" refers to virtual clusters that are backed by the same physical cluster. This option is designed for use in environments with multiple users spread across multiple work teams or projects.\"]}),`\n`,(0,n.jsxs)(e.h3,{id:\"types-of-kubernetes-namespaces\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#types-of-kubernetes-namespaces\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Types of Kubernetes Namespaces\"]}),`\n`,(0,n.jsx)(e.p,{children:\"These are the four initial namespaces that Kubernetes starts with:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:`**\"default\"\\u2014**The default namespace set by the system. It's intended for objects that don't specify any of the namespaces.`}),`\n`,(0,n.jsx)(e.li,{children:'**\"kube-system\"\\u2014**This namespace is assigned to resources that are created by the Kubernetes system.'}),`\n`,(0,n.jsx)(e.li,{children:`**\"kube-public\"\\u2014**This namespace is created by the system and is visible to all users, even users that aren't authenticated. Usually, this namespace is focused on the internal use of the platform cluster in situations where some of the resources need to be publicly visible and readable for the entire cluster.`}),`\n`,(0,n.jsx)(e.li,{children:'\\u200D**\"kube-node-lease \"\\u2014**This namespace holds lease objects associated with each node. These leases allow the kubelet to send heartbeats so that you can determine node availability.'}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"In addition to these four namespaces, you can create custom namespaces.\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"naming-convention-of-kubernetes-namespaces\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#naming-convention-of-kubernetes-namespaces\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Naming Convention of Kubernetes Namespaces\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Namespaces in Kubernetes follow the same naming convention as other objects created in Kubernetes.\"}),`\n`,(0,n.jsx)(e.p,{children:\"You can create a name with a maximum length of 253 characters using only alphanumeric characters and hyphens. Names cannot start with a hyphen and the alpha characters can only be lowercase.\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"10-kubernetes-namespace-best-practices\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#10-kubernetes-namespace-best-practices\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"10 Kubernetes Namespace Best Practices\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Let's take a look at 10 Kubernetes namespace best practices so that you can get the most out of this feature.\"}),`\n`,(0,n.jsx)(e.p,{children:\"It's important to note that the actual utility of these practices depends on your particular needs and the nature of the project.\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"1-use-convenient-and-scalable-names\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#1-use-convenient-and-scalable-names\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"1. Use Convenient and Scalable Names\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Naming is at the root of programming and is one of its basic building blocks. Names should be meaningful and provide context. Therefore, it\\u2019s recommended to use names that are expressive and scalable.\"}),`\n`,(0,n.jsx)(e.p,{children:`For example, if you're working on a streaming application, you can name the namespace \"stream\". For the different development environments, you can scale this name by adding a suffix, for example, \"stream-dev\" for the development environment, \"stream-test\" for testing, and \"stream-prod\" for production.`}),`\n`,(0,n.jsxs)(e.h4,{id:\"2-attach-labels-to-namespaces\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#2-attach-labels-to-namespaces\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"2. Attach Labels to Namespaces\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Labels in Kubernetes are not just a way to distinguish resources, but they're also a major source of metadata that can be used to log, analyze, and audit resources.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Though it\\u2019s considered a best practice to use labels throughout Kubernetes, using them in a namespace is essential when you have a large team. Here is an example:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`kubectl create namespace namespace_name\nkubectl label namespaces namespace_name labelname=value --overwrite=true\n`})}),`\n`,(0,n.jsxs)(e.h4,{id:\"3-use-rbac-to-allocate-resources\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#3-use-rbac-to-allocate-resources\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"3. Use RBAC to Allocate Resources\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Using role-based access control (RBAC), you can authorize and limit users\\u2019 access to certain resources. You can manage access locally within a cluster and globally to the entire cluster.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"To use RBAC for a specific namespace, you can use the \",(0,n.jsx)(e.em,{children:\"Role\"}),\" resource type while the \",(0,n.jsx)(e.em,{children:\"ClusterRole\"}),\" resource type can be used globally.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Using RBAC helps you to secure clusters and manage resources by defining permissions based on roles.\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"4-use-resourcequota-and-limitrange\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#4-use-resourcequota-and-limitrange\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"4. Use \",(0,n.jsx)(e.em,{children:\"ResourceQuota\"}),\" and \",(0,n.jsx)(e.em,{children:\"LimitRange\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"The namespaces in a cluster don't all need the same resources. Giving all namespaces equal resources can compromise the performance of key namespaces. Use a resource quota to limit the resource usage of particular namespaces.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Use Kubernetes \",(0,n.jsx)(e.em,{children:\"ResourceQuota\"}),\" to control the number of resources that can be created in a namespace and \",(0,n.jsx)(e.em,{children:\"LimitRange\"}),\" to restrict the consumption of resources by pods.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Here's an example of how to use \",(0,n.jsx)(e.em,{children:\"ResourceQuota\"}),\":\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`\napiVersion: v1\n \\xA0 \\xA0 \\xA0kind: ResourceQuota\n \\xA0 \\xA0 \\xA0name: default-resourcequota\n \\xA0 \\xA0 \\xA0synchronize: true\n \\xA0 \\xA0 \\xA0namespace: stream\n \\xA0 \\xA0 \\xA0data:\n \\xA0 \\xA0 \\xA0 \\xA0spec:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0hard:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0requests.cpu: '4'\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0requests.memory: \\u201816Gi\\u2019\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0limits.cpu: '4'\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0limits.memory: \\u201816Gi\\u2019\n\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"And here's an example of how to use \",(0,n.jsx)(e.em,{children:\"LimitRange\"}),\":\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`\napiVersion: v1\n \\xA0 \\xA0 \\xA0kind: LimitRange\n \\xA0 \\xA0 \\xA0name: default-limitrange\n \\xA0 \\xA0 \\xA0synchronize: true\n \\xA0 \\xA0 \\xA0namespace: stream\n \\xA0 \\xA0 \\xA0data:\n \\xA0 \\xA0 \\xA0 \\xA0spec:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0limits:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0- default:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0cpu: 500m\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0memory: 1Gi\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0defaultRequest:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0cpu: 200m\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0memory: 256Mi\n\n`})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/8129568b7e7e6ef40c342ba8bd48df8a.png\",alt:\"\"})}),`\n`,(0,n.jsxs)(e.h4,{id:\"5-use-a-networkpolicy\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#5-use-a-networkpolicy\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"5. Use a NetworkPolicy\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Kubernetes allows different pods across clusters to communicate. To secure the pods and only allow the desired traffic to pods from selected sources, it's necessary to use a NetworkPolicy for each namespace along with a CNI plugin to restrict communications.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Using a NetworkPolicy will allow you to deny ingress, egress, or any unwanted traffic coming into pods through the namespace. \\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"Here's an example of how to use a NetworkPolicy:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`\napiVersion: networking.k8s.io/v1\n \\xA0 \\xA0 \\xA0kind: NetworkPolicy\n \\xA0 \\xA0 \\xA0name: default-deny\n \\xA0 \\xA0 \\xA0namespace: stream\n \\xA0 \\xA0 \\xA0synchronize: true\n \\xA0 \\xA0 \\xA0data:\n \\xA0 \\xA0 \\xA0 \\xA0spec:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0# select all pods in the Namespace\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0podSelector: {}\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0# deny selected or all traffic\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0policyTypes:\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0- Ingress\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0- Egress\n\n`})}),`\n`,(0,n.jsxs)(e.h4,{id:\"6-dont-create-too-many-namespaces\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#6-dont-create-too-many-namespaces\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"6. Don\\u2019t Create Too Many Namespaces\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Even though there's no restriction on how many namespaces you can create and how many namespaces Kubernetes can handle, it's best to avoid creating too many namespaces.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Creating namespaces without any definite function can become difficult to manage and too many namespaces can affect the efficient consumption of resources.\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"7-dont-shy-away-from-creating-a-cluster\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#7-dont-shy-away-from-creating-a-cluster\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"7. Don\\u2019t Shy Away From Creating a Cluster\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Namespaces are used to create virtual clusters to segregate resources and reduce costs. However, it's important to understand that as your team grows, the better FinOps approach is to create additional clusters rather than creating namespaces so that you don't to compromise on performance.\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"8-dont-use-the-default-namespace\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#8-dont-use-the-default-namespace\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"8. Don\\u2019t Use the Default Namespace\"]}),`\n`,(0,n.jsx)(e.p,{children:'All objects created without a specified namespace are placed in the Kubernetes \"default\" namespace. If you use the \"default\" namespace, it can become difficult to segregate objects in it or implement RBAC and NetworkPolicies.'}),`\n`,(0,n.jsxs)(e.h4,{id:\"9-have-an-idea-of-whats-inside\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#9-have-an-idea-of-whats-inside\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"9. Have an Idea of What\\u2019s Inside\"]}),`\n`,(0,n.jsx)(e.p,{children:\"For better management of the Kubernetes cluster, it's important to understand which objects and resources are located in namespaces. This includes objects such as pods, replication controllers managed by the Kubernetes controller manager, and others.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"However, some elements are responsible for representing these resources are found outside Kubernetes namespaces. Additionally, low-level resources, such as persistent volumes and nodes, aren't found within namespaces. Services like \",(0,n.jsx)(e.a,{href:\"https://release.com/\",children:\"Release\"}),\" use dynamic provisioning in Kubernetes to provide on-demand environments that reduce the management overhead required to create persistent volumes.\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/3a54975116f4f4b2a7d02a6c569e61f4.png\",alt:\"\"})}),`\n`,(0,n.jsxs)(e.h4,{id:\"10-sync-secrets\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#10-sync-secrets\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"10. Sync Secrets\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Secrets in Kubernetes often need to exist in multiple namespaces in a cluster so pods can access them. Registry credentials, for example, need to exist in all namespaces in a cluster. If you have many namespaces, managing registry credentials manually can be tricky.\"}),`\n`,(0,n.jsx)(e.p,{children:'Syncing secrets allows you to copy \"regcred\" to all new namespaces when they are created and pushes updates to the copied secrets.'}),`\n`,(0,n.jsxs)(e.h3,{id:\"conclusion\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#conclusion\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Conclusion\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The use of namespaces in Kubernetes is a convenient way to organize and manage resources. If you know how to use namespaces effectively, it can make a significant difference in the performance of your Kubernetes workflows and help you enhance the operability of your clusters while saving on cost.\"}),`\n`,(0,n.jsx)(e.p,{children:\"\\u200D\"})]})}function v(a={}){let{wrapper:e}=a.components||{};return e?(0,n.jsx)(e,Object.assign({},a,{children:(0,n.jsx)(h,a)})):h(a)}var N=v;return w(T);})();\n;return Component;"
  },
  "_id": "blog/posts/10-kubernetes-namespace-best-practices-to-start-following.mdx",
  "_raw": {
    "sourceFilePath": "blog/posts/10-kubernetes-namespace-best-practices-to-start-following.mdx",
    "sourceFileName": "10-kubernetes-namespace-best-practices-to-start-following.mdx",
    "sourceFileDir": "blog/posts",
    "contentType": "mdx",
    "flattenedPath": "blog/posts/10-kubernetes-namespace-best-practices-to-start-following"
  },
  "type": "BlogPost",
  "computedSlug": "10-kubernetes-namespace-best-practices-to-start-following"
}