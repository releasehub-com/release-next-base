{
  "title": "Rails and Kubernetes: A Guide to Using Them Together",
  "summary": "Is Kubernetes only for modern, cloud-native, microservices-based applications or can it be used with Rails monoliths?\n",
  "publishDate": "Mon Sep 26 2022 20:15:41 GMT+0000 (Coordinated Universal Time)",
  "author": "erik-landerholm",
  "readingTime": 3,
  "categories": [
    "kubernetes",
    "platform-engineering"
  ],
  "mainImage": "/blog-images/20dfb68ea8564e9f6a8f0669a46c11e5.jpg",
  "imageAlt": "Rails and Kubernetes: A Guide to Using Them Together",
  "showCTA": true,
  "ctaCopy": "Streamline your Rails application deployment on Kubernetes with Release's on-demand environments for efficient testing and deployment workflows.",
  "ctaLink": "https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=rails-and-kubernetes-a-guide-to-using-them-together",
  "relatedPosts": [
    ""
  ],
  "ogImage": "/blog-images/20dfb68ea8564e9f6a8f0669a46c11e5.jpg",
  "excerpt": "Is Kubernetes only for modern, cloud-native, microservices-based applications or can it be used with Rails monoliths?\n",
  "tags": [
    "kubernetes",
    "platform-engineering"
  ],
  "ctaButton": "Try Release for Free",
  "body": {
    "raw": "\nYou may have heard that Kubernetes is for modern cloud-native, microservices-based applications. Does that mean you can't run it with a monolith Rails application? \n\nNot quite. Technically, nothing will stop you from just deploying your Rails application on Kubernetes. It'll work just fine. But there are a few things to consider to decide if you actually should. \n\nLet's take a look. \n\n### Rails on Kubernetes—Why?\n\nLet's start with the most important question: why would you want to run your Rails application at all? \n\nAs we already mentioned, Rails applications are monolithic, which means most of the application logic is combined into one piece. And Kubernetes was designed to run distributed, a [microservices-based](https://en.wikipedia.org/wiki/Microservices) application where one application consists of multiple smaller pieces. So, it sounds like it's not a good fit for Rails, right? \n\nWell, at first, indeed, it does. But let's dive a bit deeper into it. \n\nWhat's your alternative? Running a Rails application on a normal server, right? \n\nAnd do you have only one server for your Rails application? If it's a very small application or you just started with Rails, then possibly. \n\nBut in most production situations, you'll actually have a few servers working together for one Rails application. This includes one server for the Rails itself, another server handling access to your application—so, for example, NGINX and Puma—a third server for Redis, a fourth server for a database, and a fifth server for background jobs like Delayed Job or Sidekiq. \n\nOn top of that, you'll probably have some load balancer in front of all that and maybe yet another separate server or a dedicated solution for storage. \n\nAnd, suddenly, you realize that your monolithic Rails application actually requires a dozen servers and not just one. **‍**\n\n#### The Problem\n\nThe problem with that approach is that it's not very flexible, and you need to make a lot of compromises. For example, some of your servers may be heavily underutilized most of the time, but you can't scale them down because, from time to time, there is a spike in traffic. And the bigger the application and the more servers you have, the more resources that are probably wasted—or, to put it nicer, not used efficiently. \n\nAnother thing is that it'll take a lot of time and effort to get all these servers maintained—periodic system upgrades, making sure they all have enough free disk space left, etc. \n\nAdding a new server when needed will probably take a while, too. You'll need to deploy it first, then configure the operating system, then install what's needed for Rails, and finally make sure it connects properly with the rest. \n\n![](/blog-images/cfd60170ce84a5144d500bb231a50392.png)\n\n#### Enter the Kubernetes World\n\nThe problems stated in the previous section bring us to Kubernetes. You could simply put all your Rails application pieces to Kubernetes and not worry about individual servers anymore. Kubernetes abstracts infrastructure from you, so you won't need to worry about underlying operating systems, security patching, etc. \n\nSure, your Rails application will still be a monolith, so you won't get all the benefits of Kubernetes, but you'll get some. All the extras that your Rails application may need will still be deployed on Kubernetes as separate pieces, so you'll still benefit from easier scaling and node management.\n\nAnd, last but not least, once your Rails application is on Kubernetes, you'll have an easier path to start decoupling your monolith in microservices if you wish to do so. \n\n#### **How to Use Rails on Kubernetes**‍\n\n‍Now that we know some theory, let's see in practice how to run Rails application on Kubernetes.\n\nIn fact, there's nothing special about running Rails on Kubernetes in comparison with other frameworks. You'll need to package your Rails application into a container and create a YAML manifest file in order to deploy it on Kubernetes. \n\nLet's start with the container. There's no single specific way of packaging Ruby on Rails applications into a container—a lot will depend on how your application is working and how many best practices you want to implement, but here's a good starting point. \n\n#### Docker Container\n\n```yaml\n\nFROM ruby:3.1\n\n# Create directory for our Rails application and set it as working directory\n\nRUN mkdir /app\nWORKDIR /app\n\n# Copy the Gemfile\n\nCOPY Gemfile Gemfile.lock ./\n\n# Install nodejs and yarl (if you need anything else you can add it here)\n\nRUN apt-get update && apt-get install -y nodejs yarn\n\n# Install bundler and run bundle install\n\nRUN gem install bundler\nRUN bundle install\n\n# Copy the Rails application code\n\nCOPY . .\n\n# Precompile the Rails assets.\n\nRUN rake assets:precompile\n\n# Expose your Rails app\n\nEXPOSE 3000\n\n# Run Rails server\n\nCMD [\"rails\", \"server\", \"-b\", \"0.0.0.0\"]\n\n```\n\nSave the above as Dockerfile (with no extension) in your Rails project root directory, and then build your image: \n\n```yaml\n\n$ docker build -t rails_on_k8s:0.1 .\n\nSending build context to Docker daemon  13.58MB\nStep 1/11 : FROM ruby:3.1\n3.1: Pulling from library/ruby\n1671565cc8df: Pull complete\n(...)\n2e02738a3297: Pull complete\nDigest: sha256:74f02cae856057841964d471f0a54a5957dec7079cfe18076c132ce5c6b6ea37\nStatus: Downloaded newer image for ruby:3.1\n ---> e739755aa18e\nStep 2/11 : RUN apt-get update && apt-get install -y nodejs yarn postgresql-client\n ---> Running in 5095ff174667\nGet:1 http://deb.debian.org/debian bullseye InRelease [116 kB]\n(...)\nStep 11/11 : CMD [\"rails\", \"server\", \"-b\", \"0.0.0.0\"]\n ---> Running in ac82bad67bb6\nRemoving intermediate container ac82bad67bb6\n ---> 731093adf23f\nSuccessfully built 731093adf23f\nSuccessfully tagged rails_on_k8s:0.1\n\n```\n\nOK, that's pretty much it. That's how you package a Rails application into a Docker container. \n\nNow what? \n\nWe could start writing out Kubernetes manifest, but it's best to first check if our application is working in the container properly. To do that, run that freshly built image by executing **docker run -p 3000:3000 rails_on_k8s:0.1**, and then open your web browser and head to **localhost:3000.** \n\nIf you see your application, everything is good, and we can proceed. \n\n#### Kubernetes Manifest\n\nOK, we're ready to write a Kubernetes deployment manifest for our Rails application. \n\nIt'll be a fairly simple deployment at first. The only thing you need is to upload your Docker image to some container registry. If you don't have your own private repository, you can use a free account on dockerhub.com. You'll need to register there and follow the instructions on tagging your image and pushing it to the registry. \n\nOnce you have your image ready in a container registry, you can create a Kubernetes manifest: \n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n   name: rails-on-k8s\nspec:\n   replicas: 1\n   selector:\n     matchLabels:\n       app: rails-k8s\n   template:\n     metadata:\n       labels:\n         app: rails-k8s\n     spec:\n       containers:\n       - name: rails-k8s\n         image: davezworka/rails_on_k8s:0.1\n         ports:\n         - containerPort: 3000\n```\n\nOnce created, it's time to deploy it. We'll use the **kubectl apply** command and pass the YAML file with the **\\-f** parameter followed by the file name: \n\n```yaml\n$ kubectl apply -f k8s_deployment.yaml\ndeployment.apps/rails-on-k8s created\n```\n\nOK, it looks like it worked! Let's check: \n\n```yaml\n$ kubectl get pods\nNAME                            READY   STATUS    RESTARTS   AGE\nrails-on-k8s-7b9f7fb574-8l74g   1/1     Running   0          48s\n```\n\nIt seems like, indeed, we successfully deployed our Rails application on Kubernetes. \n\nBut here's the first tip for you. The fact that your Rails pod is running doesn't actually mean that the application inside is too. Without proper checks added to our deployment definition, it's possible that our Rails server actually failed to start properly and Kubernetes doesn't know about it. \n\nTo validate if the application in the pod is indeed running, we can first check the logs: \n\n```yaml\n\n$ kubectl logs rails-on-k8s-7b9f7fb574-8l74g\n=> Booting Puma\n=> Rails 7.0.3.1 application starting in development\n=> Run `bin/rails server --help` for more startup options\nPuma starting in single mode...\n* Puma version: 5.6.5 (ruby 3.1.2-p20) (\"Birdie's Version\")\n*  Min threads: 5\n*  Max threads: 5\n*  Environment: development\n*          PID: 1\n* Listening on http://0.0.0.0:3000\n\n```\n\nThat looks promising. It seems like our Rails server started properly, so, most likely, everything is good. But the ultimate test would be just to try to access the application. To do that, we first need to expose it somehow. In the Kubernetes world, we do that using Kubernetes services. \n\n#### Kubernetes Services\n\nIn order to create a service for our Rails deployment, create another YAML file with content similar to this, but keep in mind that you may need to adjust the type of the service based on what kind of Kubernetes cluster you're using: \n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n   name: rails-service\nspec:\n   type: LoadBalancer\n   selector:\n     app: rails-k8s\n   ports:\n     - port: 80\n       targetPort: 3000\n```\n\nApply the above using **kubectl apply**: \n\n```yaml\n$ kubectl apply -f rails-svc.yaml\nservice/rails-service created\n```\n\nNow, after a few seconds, we should see the IP address of the load balancer that exposes our application: \n\n```yaml\n$ kubectl get svc\nNAME               TYPE           CLUSTER-IP   EXTERNAL-IP     PORT(S)        AGE\nkubernetes         ClusterIP      10.0.0.1               443/TCP        8h\nrails-service      LoadBalancer   10.0.74.93   20.101.11.115   80:31330/TCP   48s\n```\n\nAnd if you open that IP address in your web browser, you should see your application, which in our case is showing a simple \"Hello world\" message: \n\n![](/blog-images/41ada768a12014157ed6f76a40ee7223.jpeg)\n\nAll works well, then. We have a Rails application running on a Kubernetes cluster. \n\nBut this was just a simple example when we only deployed our Rails application. If that's all you'd do, it probably won't give you many benefits to move to Kubernetes. \n\nEarlier in this post, we mentioned that it makes sense to move your Rails application when you have lots of other components supporting your application. \n\nAnd if you do, the process of moving them to Kubernetes would be very similar. You either create a [Docker image](https://release.com/blog/cutting-build-time-in-half-docker-buildx-kubernetes) from scratch for all the components you need or search for ready-to-use images. Companies behind well-known tools like Redis or NGINX are publishing images themselves, so it's a little bit easier to onboard them on Kubernetes. \n\n#### But What About the Database?\n\nThis is a fair question. The database is really important for Rails. Databases can run on Kubernetes too. But depending on your specific needs and due to the nature of databases, it may make more sense to use an SaaS database or keep it on traditional servers. \n\nYou can easily keep your Rails application on a Kubernetes cluster and have it connected to the external database. Of course, for performance reasons, however, you should keep it as close as possible to your Kubernetes, which means ideally in the same cloud provider, the same region, and even the same network. \n\n#### Rails and Kubernetes Summary\n\nWe've only touched the tip of the iceberg here when it comes to Kubernetes, but you learned how to package your Rails application into a container and deploy it on Kubernetes. From there, the next steps will depend on your application and company specifics. \n\nKubernetes itself is a complex system and gives you multiple choices when it comes to deploying applications, networking, and storage. But you now know how to use it for your Rails application and when it wouldn't really make too much sense. \n\nIf you're interested in learning more about Kubernetes, check out our blog [here](https://release.com/blog) for more posts about it.\n",
    "code": "var Component=(()=>{var h=Object.create;var o=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var b=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),g=(a,e)=>{for(var t in e)o(a,t,{get:e[t],enumerable:!0})},s=(a,e,t,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of u(e))!y.call(a,i)&&i!==t&&o(a,i,{get:()=>e[i],enumerable:!(r=p(e,i))||r.enumerable});return a};var f=(a,e,t)=>(t=a!=null?h(m(a)):{},s(e||!a||!a.__esModule?o(t,\"default\",{value:a,enumerable:!0}):t,a)),w=a=>s(o({},\"__esModule\",{value:!0}),a);var c=b((T,l)=>{l.exports=_jsx_runtime});var K={};g(K,{default:()=>R,frontmatter:()=>k});var n=f(c()),k={title:\"Rails and Kubernetes: A Guide to Using Them Together\",summary:`Is Kubernetes only for modern, cloud-native, microservices-based applications or can it be used with Rails monoliths?\n`,publishDate:\"Mon Sep 26 2022 20:15:41 GMT+0000 (Coordinated Universal Time)\",author:\"erik-landerholm\",readingTime:3,categories:[\"kubernetes\",\"platform-engineering\"],mainImage:\"/blog-images/20dfb68ea8564e9f6a8f0669a46c11e5.jpg\",imageAlt:\"Rails and Kubernetes: A Guide to Using Them Together\",showCTA:!0,ctaCopy:\"Streamline your Rails application deployment on Kubernetes with Release's on-demand environments for efficient testing and deployment workflows.\",ctaLink:\"https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=rails-and-kubernetes-a-guide-to-using-them-together\",relatedPosts:[\"\"],ogImage:\"/blog-images/20dfb68ea8564e9f6a8f0669a46c11e5.jpg\",excerpt:`Is Kubernetes only for modern, cloud-native, microservices-based applications or can it be used with Rails monoliths?\n`,tags:[\"kubernetes\",\"platform-engineering\"],ctaButton:\"Try Release for Free\"};function d(a){let e=Object.assign({p:\"p\",h3:\"h3\",a:\"a\",span:\"span\",strong:\"strong\",h4:\"h4\",img:\"img\",pre:\"pre\",code:\"code\"},a.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"You may have heard that Kubernetes is for modern cloud-native, microservices-based applications. Does that mean you can't run it with a monolith Rails application?\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"Not quite. Technically, nothing will stop you from just deploying your Rails application on Kubernetes. It'll work just fine. But there are a few things to consider to decide if you actually should.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"Let's take a look.\\xA0\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"rails-on-kuberneteswhy\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#rails-on-kuberneteswhy\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Rails on Kubernetes\\u2014Why?\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Let's start with the most important question: why would you want to run your Rails application at all?\\xA0\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"As we already mentioned, Rails applications are monolithic, which means most of the application logic is combined into one piece. And Kubernetes was designed to run distributed, a \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Microservices\",children:\"microservices-based\"}),\" application where one application consists of multiple smaller pieces. So, it sounds like it's not a good fit for Rails, right?\\xA0\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Well, at first, indeed, it does. But let's dive a bit deeper into it.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"What's your alternative? Running a Rails application on a normal server, right?\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"And do you have only one server for your Rails application? If it's a very small application or you just started with Rails, then possibly.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"But in most production situations, you'll actually have a few servers working together for one Rails application. This includes one server for the Rails itself, another server handling access to your application\\u2014so, for example, NGINX and Puma\\u2014a third server for Redis, a fourth server for a database, and a fifth server for background jobs like Delayed Job or Sidekiq.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"On top of that, you'll probably have some load balancer in front of all that and maybe yet another separate server or a dedicated solution for storage.\\xA0\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"And, suddenly, you realize that your monolithic Rails application actually requires a dozen servers and not just one.\\xA0\",(0,n.jsx)(e.strong,{children:\"\\u200D\"})]}),`\n`,(0,n.jsxs)(e.h4,{id:\"the-problem\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#the-problem\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"The Problem\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The problem with that approach is that it's not very flexible, and you need to make a lot of compromises. For example, some of your servers may be heavily underutilized most of the time, but you can't scale them down because, from time to time, there is a spike in traffic. And the bigger the application and the more servers you have, the more resources that are probably wasted\\u2014or, to put it nicer, not used efficiently.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"Another thing is that it'll take a lot of time and effort to get all these servers maintained\\u2014periodic system upgrades, making sure they all have enough free disk space left, etc.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"Adding a new server when needed will probably take a while, too. You'll need to deploy it first, then configure the operating system, then install what's needed for Rails, and finally make sure it connects properly with the rest.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/cfd60170ce84a5144d500bb231a50392.png\",alt:\"\"})}),`\n`,(0,n.jsxs)(e.h4,{id:\"enter-the-kubernetes-world\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#enter-the-kubernetes-world\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Enter the Kubernetes World\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The problems stated in the previous section bring us to Kubernetes. You could simply put all your Rails application pieces to Kubernetes and not worry about individual servers anymore. Kubernetes abstracts infrastructure from you, so you won't need to worry about underlying operating systems, security patching, etc.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"Sure, your Rails application will still be a monolith, so you won't get all the benefits of Kubernetes, but you'll get some. All the extras that your Rails application may need will still be deployed on Kubernetes as separate pieces, so you'll still benefit from easier scaling and node management.\"}),`\n`,(0,n.jsx)(e.p,{children:\"And, last but not least, once your Rails application is on Kubernetes, you'll have an easier path to start decoupling your monolith in microservices if you wish to do so.\\xA0\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"how-to-use-rails-on-kubernetes\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#how-to-use-rails-on-kubernetes\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"How to Use Rails on Kubernetes\"}),\"\\u200D\"]}),`\n`,(0,n.jsx)(e.p,{children:\"\\u200DNow that we know some theory, let's see in practice how to run Rails application on Kubernetes.\"}),`\n`,(0,n.jsx)(e.p,{children:\"In fact, there's nothing special about running Rails on Kubernetes in comparison with other frameworks. You'll need to package your Rails application into a container and create a YAML manifest file in order to deploy it on Kubernetes.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"Let's start with the container. There's no single specific way of packaging Ruby on Rails applications into a container\\u2014a lot will depend on how your application is working and how many best practices you want to implement, but here's a good starting point.\\xA0\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"docker-container\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#docker-container\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Docker Container\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`\nFROM ruby:3.1\n\n# Create directory for our Rails application and set it as working directory\n\nRUN mkdir /app\nWORKDIR /app\n\n# Copy the Gemfile\n\nCOPY Gemfile Gemfile.lock ./\n\n# Install nodejs and yarl (if you need anything else you can add it here)\n\nRUN apt-get update && apt-get install -y nodejs yarn\n\n# Install bundler and run bundle install\n\nRUN gem install bundler\nRUN bundle install\n\n# Copy the Rails application code\n\nCOPY . .\n\n# Precompile the Rails assets.\n\nRUN rake assets:precompile\n\n# Expose your Rails app\n\nEXPOSE 3000\n\n# Run Rails server\n\nCMD [\"rails\", \"server\", \"-b\", \"0.0.0.0\"]\n\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Save the above as Dockerfile (with no extension) in your Rails project root directory, and then build your image:\\xA0\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`\n$ docker build -t rails_on_k8s:0.1 .\n\nSending build context to Docker daemon \\xA013.58MB\nStep 1/11 : FROM ruby:3.1\n3.1: Pulling from library/ruby\n1671565cc8df: Pull complete\n(...)\n2e02738a3297: Pull complete\nDigest: sha256:74f02cae856057841964d471f0a54a5957dec7079cfe18076c132ce5c6b6ea37\nStatus: Downloaded newer image for ruby:3.1\n ---> e739755aa18e\nStep 2/11 : RUN apt-get update && apt-get install -y nodejs yarn postgresql-client\n ---> Running in 5095ff174667\nGet:1 http://deb.debian.org/debian bullseye InRelease [116 kB]\n(...)\nStep 11/11 : CMD [\"rails\", \"server\", \"-b\", \"0.0.0.0\"]\n ---> Running in ac82bad67bb6\nRemoving intermediate container ac82bad67bb6\n ---> 731093adf23f\nSuccessfully built 731093adf23f\nSuccessfully tagged rails_on_k8s:0.1\n\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"OK, that's pretty much it. That's how you package a Rails application into a Docker container.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"Now what?\\xA0\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"We could start writing out Kubernetes manifest, but it's best to first check if our application is working in the container properly. To do that, run that freshly built image by executing \",(0,n.jsx)(e.strong,{children:\"docker run -p 3000:3000 rails_on_k8s:0.1\"}),\", and then open your web browser and head to \",(0,n.jsx)(e.strong,{children:\"localhost:3000.\"}),\"\\xA0\"]}),`\n`,(0,n.jsx)(e.p,{children:\"If you see your application, everything is good, and we can proceed.\\xA0\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"kubernetes-manifest\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#kubernetes-manifest\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Kubernetes Manifest\"]}),`\n`,(0,n.jsx)(e.p,{children:\"OK, we're ready to write a Kubernetes deployment manifest for our Rails application.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"It'll be a fairly simple deployment at first. The only thing you need is to upload your Docker image to some container registry. If you don't have your own private repository, you can use a free account on dockerhub.com. You'll need to register there and follow the instructions on tagging your image and pushing it to the registry.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"Once you have your image ready in a container registry, you can create a Kubernetes manifest:\\xA0\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  \\xA0name: rails-on-k8s\nspec:\n  \\xA0replicas: 1\n  \\xA0selector:\n  \\xA0 \\xA0matchLabels:\n  \\xA0 \\xA0 \\xA0app: rails-k8s\n  \\xA0template:\n  \\xA0 \\xA0metadata:\n  \\xA0 \\xA0 \\xA0labels:\n  \\xA0 \\xA0 \\xA0 \\xA0app: rails-k8s\n  \\xA0 \\xA0spec:\n  \\xA0 \\xA0 \\xA0containers:\n  \\xA0 \\xA0 \\xA0- name: rails-k8s\n  \\xA0 \\xA0 \\xA0 \\xA0image: davezworka/rails_on_k8s:0.1\n  \\xA0 \\xA0 \\xA0 \\xA0ports:\n  \\xA0 \\xA0 \\xA0 \\xA0- containerPort: 3000\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Once created, it's time to deploy it. We'll use the \",(0,n.jsx)(e.strong,{children:\"kubectl apply\"}),\" command and pass the YAML file with the \",(0,n.jsx)(e.strong,{children:\"-f\"}),\" parameter followed by the file name:\\xA0\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`$ kubectl apply -f k8s_deployment.yaml\ndeployment.apps/rails-on-k8s created\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"OK, it looks like it worked! Let's check:\\xA0\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`$ kubectl get pods\nNAME \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0READY \\xA0 STATUS \\xA0 \\xA0RESTARTS \\xA0 AGE\nrails-on-k8s-7b9f7fb574-8l74g \\xA0 1/1 \\xA0 \\xA0 Running \\xA0 0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA048s\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"It seems like, indeed, we successfully deployed our Rails application on Kubernetes.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"But here's the first tip for you. The fact that your Rails pod is running doesn't actually mean that the application inside is too. Without proper checks added to our deployment definition, it's possible that our Rails server actually failed to start properly and Kubernetes doesn't know about it.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"To validate if the application in the pod is indeed running, we can first check the logs:\\xA0\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`\n$ kubectl logs rails-on-k8s-7b9f7fb574-8l74g\n=> Booting Puma\n=> Rails 7.0.3.1 application starting in development\n=> Run \\`bin/rails server --help\\` for more startup options\nPuma starting in single mode...\n* Puma version: 5.6.5 (ruby 3.1.2-p20) (\"Birdie's Version\")\n* \\xA0Min threads: 5\n* \\xA0Max threads: 5\n* \\xA0Environment: development\n* \\xA0 \\xA0 \\xA0 \\xA0 \\xA0PID: 1\n* Listening on http://0.0.0.0:3000\n\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"That looks promising. It seems like our Rails server started properly, so, most likely, everything is good. But the ultimate test would be just to try to access the application. To do that, we first need to expose it somehow. In the Kubernetes world, we do that using Kubernetes services.\\xA0\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"kubernetes-services\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#kubernetes-services\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Kubernetes Services\"]}),`\n`,(0,n.jsx)(e.p,{children:\"In order to create a service for our Rails deployment, create another YAML file with content similar to this, but keep in mind that you may need to adjust the type of the service based on what kind of Kubernetes cluster you're using:\\xA0\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`apiVersion: v1\nkind: Service\nmetadata:\n  \\xA0name: rails-service\nspec:\n  \\xA0type: LoadBalancer\n  \\xA0selector:\n  \\xA0 \\xA0app: rails-k8s\n  \\xA0ports:\n  \\xA0 \\xA0- port: 80\n  \\xA0 \\xA0 \\xA0targetPort: 3000\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Apply the above using \",(0,n.jsx)(e.strong,{children:\"kubectl apply\"}),\":\\xA0\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`$ kubectl apply -f rails-svc.yaml\nservice/rails-service created\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Now, after a few seconds, we should see the IP address of the load balancer that exposes our application:\\xA0\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`$ kubectl get svc\nNAME \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 TYPE \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 CLUSTER-IP \\xA0 EXTERNAL-IP \\xA0 \\xA0 PORT(S) \\xA0 \\xA0 \\xA0 \\xA0AGE\nkubernetes \\xA0 \\xA0 \\xA0 \\xA0 ClusterIP \\xA0 \\xA0 \\xA010.0.0.1 \\xA0 \\xA0  \\xA0 \\xA0 \\xA0 \\xA0 \\xA0443/TCP \\xA0 \\xA0 \\xA0 \\xA08h\nrails-service \\xA0 \\xA0 \\xA0LoadBalancer \\xA0 10.0.74.93 \\xA0 20.101.11.115 \\xA0 80:31330/TCP \\xA0 48s\n`})}),`\n`,(0,n.jsx)(e.p,{children:'And if you open that IP address in your web browser, you should see your application, which in our case is showing a simple \"Hello world\" message:\\xA0'}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/41ada768a12014157ed6f76a40ee7223.jpeg\",alt:\"\"})}),`\n`,(0,n.jsx)(e.p,{children:\"All works well, then. We have a Rails application running on a Kubernetes cluster.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"But this was just a simple example when we only deployed our Rails application. If that's all you'd do, it probably won't give you many benefits to move to Kubernetes.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"Earlier in this post, we mentioned that it makes sense to move your Rails application when you have lots of other components supporting your application.\\xA0\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"And if you do, the process of moving them to Kubernetes would be very similar. You either create a \",(0,n.jsx)(e.a,{href:\"https://release.com/blog/cutting-build-time-in-half-docker-buildx-kubernetes\",children:\"Docker image\"}),\" from scratch for all the components you need or search for ready-to-use images. Companies behind well-known tools like Redis or NGINX are publishing images themselves, so it's a little bit easier to onboard them on Kubernetes.\\xA0\"]}),`\n`,(0,n.jsxs)(e.h4,{id:\"but-what-about-the-database\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#but-what-about-the-database\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"But What About the Database?\"]}),`\n`,(0,n.jsx)(e.p,{children:\"This is a fair question. The database is really important for Rails. Databases can run on Kubernetes too. But depending on your specific needs and due to the nature of databases, it may make more sense to use an SaaS database or keep it on traditional servers.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"You can easily keep your Rails application on a Kubernetes cluster and have it connected to the external database. Of course, for performance reasons, however, you should keep it as close as possible to your Kubernetes, which means ideally in the same cloud provider, the same region, and even the same network.\\xA0\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"rails-and-kubernetes-summary\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#rails-and-kubernetes-summary\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Rails and Kubernetes Summary\"]}),`\n`,(0,n.jsx)(e.p,{children:\"We've only touched the tip of the iceberg here when it comes to Kubernetes, but you learned how to package your Rails application into a container and deploy it on Kubernetes. From there, the next steps will depend on your application and company specifics.\\xA0\"}),`\n`,(0,n.jsx)(e.p,{children:\"Kubernetes itself is a complex system and gives you multiple choices when it comes to deploying applications, networking, and storage. But you now know how to use it for your Rails application and when it wouldn't really make too much sense.\\xA0\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"If you're interested in learning more about Kubernetes, check out our blog \",(0,n.jsx)(e.a,{href:\"https://release.com/blog\",children:\"here\"}),\" for more posts about it.\"]})]})}function v(a={}){let{wrapper:e}=a.components||{};return e?(0,n.jsx)(e,Object.assign({},a,{children:(0,n.jsx)(d,a)})):d(a)}var R=v;return w(K);})();\n;return Component;"
  },
  "_id": "blog/posts/rails-and-kubernetes-a-guide-to-using-them-together.mdx",
  "_raw": {
    "sourceFilePath": "blog/posts/rails-and-kubernetes-a-guide-to-using-them-together.mdx",
    "sourceFileName": "rails-and-kubernetes-a-guide-to-using-them-together.mdx",
    "sourceFileDir": "blog/posts",
    "contentType": "mdx",
    "flattenedPath": "blog/posts/rails-and-kubernetes-a-guide-to-using-them-together"
  },
  "type": "BlogPost",
  "computedSlug": "rails-and-kubernetes-a-guide-to-using-them-together"
}