{
  "title": "Extending Release Environments with Terraform",
  "summary": "This blog shows how to utilize Terraform alongside Release to provision additional resources in your cloud account.",
  "publishDate": "Tue Aug 09 2022 23:58:58 GMT+0000 (Coordinated Universal Time)",
  "author": "josh-dirkx",
  "readingTime": 5,
  "categories": [
    "platform-engineering",
    "product"
  ],
  "mainImage": "/blog-images/c710bf4817cae68e73eeb96d596fa5a4.jpg",
  "imageAlt": "Extending Release Environments with Terraform",
  "showCTA": true,
  "ctaCopy": "Simplify managing Terraform environments with Release's ephemeral environments for seamless collaboration and consistent deployments.",
  "ctaLink": "https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=extending-releasehub-environments-with-terraform",
  "relatedPosts": [
    ""
  ],
  "ogImage": "/blog-images/c710bf4817cae68e73eeb96d596fa5a4.jpg",
  "excerpt": "This blog shows how to utilize Terraform alongside Release to provision additional resources in your cloud account.",
  "tags": [
    "platform-engineering",
    "product"
  ],
  "ctaButton": "Try Release for Free",
  "body": {
    "raw": "\n[  \n](https://app.diagrams.net/?page-id=4EaHbZaufD5BJVQ07xAE&scale=auto#G1ZjCA67a8oFC8ztyAz2rx3ehoodHwKE2D)\n\n![](/blog-images/23436a0da5744c17b36da806862964fc.png)\n\n[Release](https://release.com/) offers the ability to easily reproduce your production environment _N_ times in your cloud account. The construction of environments can be accomplished using our website, CLI or API and are useful for a variety of purposes - from quality assurance testing and user acceptance to sales demonstrations and penetration testing.\n\nEnvironments today typically extend beyond a set of Docker images to include a variety of resources from your chosen cloud provider. In order to consistently get those resources alongside your Docker images when building environments, the instructions to get those resources instantiated must be codified somewhere in your application with some flavor of Infrastructure-as-Code (IaC).\n\nA recently launched abstraction within the Release Application Template removes the previous requirements of packaging your Terraform into a Dockerfile, creating the scripts to apply/update/teardown your resources, and managing the variables required to namespace appropriately. Using this new abstraction, the process becomes much more streamlined. Write your Terraform, tell us where to find it, and then tell us when to execute it.\n\n### What is Terraform?\n\n[Terraform](https://www.terraform.io/) is declarative Infrastructure as Code. Said another way, it is a way of programmatically specifying what resources you need created in your cloud provider.\n\nThere are two approaches to IaC - declarative (what) versus imperative (how). Declarative focuses on the desired end state; you tell the system what resources you want provisioned and it figures out how to get you there. Imperative, on the other hand, focuses on the instruction set to get to your end state; you are responsible for maintaining the order of operations required to get to your desired end state.\n\nAnother important concept behind IaC is state and state management. Terraform is no exception here, by default it uses JSON in a local file to persist the state of real world resources created by it. Configurations can be added to allow for remote storage, such as in S3.\n\n### Why should I use Terraform?\n\nTerraform, or any IaC, is an important piece of the puzzle to modern, cloud infrastructure stacks. Codifying the instructions to your production environment allows you to increase visibility and auditability of changes - alterations to your stack are now managed within your source control, allowing you to use change requests for granular inspection of changes before they are applied.\n\nYour infrastructure becomes repeatable, predictable and consistent. Running the _terraform apply_ command will produce the same results every time. This stands in contrast to the manual process of clicking through a web console based on a document containing instructions, or from memory.\n\nIn the event of a full or partial failure of your application, you can quickly and easily replace _everything_.\n\n### _How_ do I use Terraform with Release?\n\n‍*The following example assumes a project layout as outlined in the image below*\n\n![](/blog-images/ba50f60eb0679702ad5c7fae80ba5645.png)\n\nWhen writing your Terraform, it's important to keep in mind that you want it to be repeatable without resource naming collisions, regardless of how many times you execute the same combination of resources. This can be achieved by using dynamic values to namespace resources. Release makes available to you all of the Release generated environment variables for use within your _.tfvars_ file, allowing you to use the environments' context as the namespacing material. For example, you might have the following inside of your _.tfvars_ file\n\n```bash\n# .release/lambda.tfvars\nnamespace = \"${RELEASE_ACCOUNT_ID}/${RELEASE_ENV_ID}/\"\n```\n\n‍\n\nWhen specifying the name of a resource, we'll use a Lambda as an example, you would reference that namespace in the name, like below\n\n```hcl\nresource \"aws_lambda_function\" \"lambda\" {\n  function_name = \"${vars.namespace}/lambda\"\n  # ...\n}\n```\n\n‍\n\nThe inclusion of the environment_id ensures that each time this Terraform is executed by Release, it will be unique.\n\nWIthin the Application Template for a given Release Application, there is an abstraction over IaC providers, such as Terraform, that we can leverage. For the purposes of this demonstration, we will be using Terraform in conjunction with AWS resources.\n\nA new section has been added to the template at the top level - infrastructure. This section takes an array with a few required and optional fields. Required fields are name (this is how you will reference the aforementioned Terraform in the workflows section) and type (for now, the only supported type is Terraform but over time we will add abstractions for Pulumi, CDK, etc.). Optionally, you can also specify a directory (where to find the Terraform) and values (where to find environment variables). By default, if no directory is specified then Release will assume your Terraform is at the root of the repository and if no values file is given, we assume this file does not exist.\n\nWe need to add a few things to our Application Template to support this. We need to first tell Release what to build, then we specify when we execute it.\n\nTo tell Release what we need it to build, we add a new array item to the infrastructure key in our Application Template.\n\n‍\n\n\\# Application Template\n\ninfrastructure:  \n\\- name: lambda  \n **type**: **terraform**  \n directory: \"./terraform\"  \n values: \".release/lambda.tfvar\"\n\n‍\n\nThis section tells Release where within the repository to find the code it needs for execution in the workflows. In the future, Release will support remote repositories. Now to execute this, it must be added to your workflows section\n\n\\# Application Template\n\nworkflows:  \n\\- name: setup  \n order_from:  \n - infrastructure.lambda\n\n‍\n\nThis adds the creation of the Lambda function synchronously to the workflow. Workflows may be parallelized if order of execution is not important during a given step, for more information on how to parallelize your workflows, visit our [documentation](https://docs.releasehub.com/reference-documentation/application-settings/application-template/schema-definition#workflow-parallelization).\n\nResources created during the execution of the workflow will have their state written to the local file store. In an already planned update, Release will extend this functionality to include the additional support of remote backends, like [Amazon S3](https://aws.amazon.com/s3/).\n\n### Summary\n\nThis blog covered at a high level the concepts around Infrastructure-as-Code, some specifics related to Terraform and how to use Terraform in combination with Release Environments to extend their functionality. A repository containing the code written in this sample can be found [here](https://github.com/releasehub-samples/terraform-runner-example). If you have any questions, find me on [LinkedIn](https://www.linkedin.com/in/joshdirkx/) or reach me at josh@release.com.\n",
    "code": "var Component=(()=>{var d=Object.create;var a=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var w=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),g=(t,e)=>{for(var n in e)a(t,n,{get:e[n],enumerable:!0})},s=(t,e,n,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of m(e))!f.call(t,o)&&o!==n&&a(t,o,{get:()=>e[o],enumerable:!(i=u(e,o))||i.enumerable});return t};var y=(t,e,n)=>(n=t!=null?d(p(t)):{},s(e||!t||!t.__esModule?a(n,\"default\",{value:t,enumerable:!0}):n,t)),b=t=>s(a({},\"__esModule\",{value:!0}),t);var c=w((I,l)=>{l.exports=_jsx_runtime});var k={};g(k,{default:()=>x,frontmatter:()=>v});var r=y(c()),v={title:\"Extending Release Environments with Terraform\",summary:\"This blog shows how to utilize Terraform alongside Release to provision additional resources in your cloud account.\",publishDate:\"Tue Aug 09 2022 23:58:58 GMT+0000 (Coordinated Universal Time)\",author:\"josh-dirkx\",readingTime:5,categories:[\"platform-engineering\",\"product\"],mainImage:\"/blog-images/c710bf4817cae68e73eeb96d596fa5a4.jpg\",imageAlt:\"Extending Release Environments with Terraform\",showCTA:!0,ctaCopy:\"Simplify managing Terraform environments with Release's ephemeral environments for seamless collaboration and consistent deployments.\",ctaLink:\"https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=extending-releasehub-environments-with-terraform\",relatedPosts:[\"\"],ogImage:\"/blog-images/c710bf4817cae68e73eeb96d596fa5a4.jpg\",excerpt:\"This blog shows how to utilize Terraform alongside Release to provision additional resources in your cloud account.\",tags:[\"platform-engineering\",\"product\"],ctaButton:\"Try Release for Free\"};function h(t){let e=Object.assign({p:\"p\",a:\"a\",br:\"br\",img:\"img\",em:\"em\",h3:\"h3\",span:\"span\",pre:\"pre\",code:\"code\",strong:\"strong\"},t.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.p,{children:(0,r.jsxs)(e.a,{href:\"https://app.diagrams.net/?page-id=4EaHbZaufD5BJVQ07xAE&scale=auto#G1ZjCA67a8oFC8ztyAz2rx3ehoodHwKE2D\",children:[(0,r.jsx)(e.br,{}),`\n`]})}),`\n`,(0,r.jsx)(e.p,{children:(0,r.jsx)(e.img,{src:\"/blog-images/23436a0da5744c17b36da806862964fc.png\",alt:\"\"})}),`\n`,(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.a,{href:\"https://release.com/\",children:\"Release\"}),\" offers the ability to easily reproduce your production environment \",(0,r.jsx)(e.em,{children:\"N\"}),\" times in your cloud account. The construction of environments can be accomplished using our website, CLI or API and are useful for a variety of purposes - from quality assurance testing and user acceptance to sales demonstrations and penetration testing.\"]}),`\n`,(0,r.jsx)(e.p,{children:\"Environments today typically extend beyond a set of Docker images to include a variety of resources from your chosen cloud provider. In order to consistently get those resources alongside your Docker images when building environments, the instructions to get those resources instantiated must be codified somewhere in your application with some flavor of Infrastructure-as-Code (IaC).\"}),`\n`,(0,r.jsx)(e.p,{children:\"A recently launched abstraction within the Release Application Template removes the previous requirements of packaging your Terraform into a Dockerfile, creating the scripts to apply/update/teardown your resources, and managing the variables required to namespace appropriately. Using this new abstraction, the process becomes much more streamlined. Write your Terraform, tell us where to find it, and then tell us when to execute it.\"}),`\n`,(0,r.jsxs)(e.h3,{id:\"what-is-terraform\",children:[(0,r.jsx)(e.a,{className:\"anchor\",href:\"#what-is-terraform\",children:(0,r.jsx)(e.span,{className:\"icon icon-link\"})}),\"What is Terraform?\"]}),`\n`,(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.a,{href:\"https://www.terraform.io/\",children:\"Terraform\"}),\" is declarative Infrastructure as Code. Said another way, it is a way of programmatically specifying what resources you need created in your cloud provider.\"]}),`\n`,(0,r.jsx)(e.p,{children:\"There are two approaches to IaC - declarative (what) versus imperative (how). Declarative focuses on the desired end state; you tell the system what resources you want provisioned and it figures out how to get you there. Imperative, on the other hand, focuses on the instruction set to get to your end state; you are responsible for maintaining the order of operations required to get to your desired end state.\"}),`\n`,(0,r.jsx)(e.p,{children:\"Another important concept behind IaC is state and state management. Terraform is no exception here, by default it uses JSON in a local file to persist the state of real world resources created by it. Configurations can be added to allow for remote storage, such as in S3.\"}),`\n`,(0,r.jsxs)(e.h3,{id:\"why-should-i-use-terraform\",children:[(0,r.jsx)(e.a,{className:\"anchor\",href:\"#why-should-i-use-terraform\",children:(0,r.jsx)(e.span,{className:\"icon icon-link\"})}),\"Why should I use Terraform?\"]}),`\n`,(0,r.jsx)(e.p,{children:\"Terraform, or any IaC, is an important piece of the puzzle to modern, cloud infrastructure stacks. Codifying the instructions to your production environment allows you to increase visibility and auditability of changes - alterations to your stack are now managed within your source control, allowing you to use change requests for granular inspection of changes before they are applied.\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"Your infrastructure becomes repeatable, predictable and consistent. Running the \",(0,r.jsx)(e.em,{children:\"terraform apply\"}),\" command will produce the same results every time. This stands in contrast to the manual process of clicking through a web console based on a document containing instructions, or from memory.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"In the event of a full or partial failure of your application, you can quickly and easily replace \",(0,r.jsx)(e.em,{children:\"everything\"}),\".\"]}),`\n`,(0,r.jsxs)(e.h3,{id:\"how-do-i-use-terraform-with-release\",children:[(0,r.jsx)(e.a,{className:\"anchor\",href:\"#how-do-i-use-terraform-with-release\",children:(0,r.jsx)(e.span,{className:\"icon icon-link\"})}),(0,r.jsx)(e.em,{children:\"How\"}),\" do I use Terraform with Release?\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"\\u200D\",(0,r.jsx)(e.em,{children:\"The following example assumes a project layout as outlined in the image below\"})]}),`\n`,(0,r.jsx)(e.p,{children:(0,r.jsx)(e.img,{src:\"/blog-images/ba50f60eb0679702ad5c7fae80ba5645.png\",alt:\"\"})}),`\n`,(0,r.jsxs)(e.p,{children:[\"When writing your Terraform, it's important to keep in mind that you want it to be repeatable without resource naming collisions, regardless of how many times you execute the same combination of resources. This can be achieved by using dynamic values to namespace resources. Release makes available to you all of the Release generated environment variables for use within your \",(0,r.jsx)(e.em,{children:\".tfvars\"}),\" file, allowing you to use the environments' context as the namespacing material. For example, you might have the following inside of your \",(0,r.jsx)(e.em,{children:\".tfvars\"}),\" file\"]}),`\n`,(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:\"language-bash\",children:'# .release/lambda.tfvars\\nnamespace = \"${RELEASE_ACCOUNT_ID}/${RELEASE_ENV_ID}/\"\\n'})}),`\n`,(0,r.jsx)(e.p,{children:\"\\u200D\"}),`\n`,(0,r.jsx)(e.p,{children:\"When specifying the name of a resource, we'll use a Lambda as an example, you would reference that namespace in the name, like below\"}),`\n`,(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:\"language-hcl\",children:`resource \"aws_lambda_function\" \"lambda\" {\n  function_name = \"\\${vars.namespace}/lambda\"\n  # ...\n}\n`})}),`\n`,(0,r.jsx)(e.p,{children:\"\\u200D\"}),`\n`,(0,r.jsx)(e.p,{children:\"The inclusion of the environment_id ensures that each time this Terraform is executed by Release, it will be unique.\"}),`\n`,(0,r.jsx)(e.p,{children:\"WIthin the Application Template for a given Release Application, there is an abstraction over IaC providers, such as Terraform, that we can leverage. For the purposes of this demonstration, we will be using Terraform in conjunction with AWS resources.\"}),`\n`,(0,r.jsx)(e.p,{children:\"A new section has been added to the template at the top level - infrastructure. This section takes an array with a few required and optional fields. Required fields are name (this is how you will reference the aforementioned Terraform in the workflows section) and type (for now, the only supported type is Terraform but over time we will add abstractions for Pulumi, CDK, etc.). Optionally, you can also specify a directory (where to find the Terraform) and values (where to find environment variables). By default, if no directory is specified then Release will assume your Terraform is at the root of the repository and if no values file is given, we assume this file does not exist.\"}),`\n`,(0,r.jsx)(e.p,{children:\"We need to add a few things to our Application Template to support this. We need to first tell Release what to build, then we specify when we execute it.\"}),`\n`,(0,r.jsx)(e.p,{children:\"To tell Release what we need it to build, we add a new array item to the infrastructure key in our Application Template.\"}),`\n`,(0,r.jsx)(e.p,{children:\"\\u200D\"}),`\n`,(0,r.jsx)(e.p,{children:\"# Application Template\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"infrastructure:\",(0,r.jsx)(e.br,{}),`\n`,\"- name: lambda\",(0,r.jsx)(e.br,{}),`\n`,(0,r.jsx)(e.strong,{children:\"type\"}),\": \",(0,r.jsx)(e.strong,{children:\"terraform\"}),(0,r.jsx)(e.br,{}),`\n`,'directory: \"./terraform\"',(0,r.jsx)(e.br,{}),`\n`,'values: \".release/lambda.tfvar\"']}),`\n`,(0,r.jsx)(e.p,{children:\"\\u200D\"}),`\n`,(0,r.jsx)(e.p,{children:\"This section tells Release where within the repository to find the code it needs for execution in the workflows. In the future, Release will support remote repositories. Now to execute this, it must be added to your workflows section\"}),`\n`,(0,r.jsx)(e.p,{children:\"# Application Template\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"workflows:\",(0,r.jsx)(e.br,{}),`\n`,\"- name: setup\",(0,r.jsx)(e.br,{}),`\n`,\"order_from:\",(0,r.jsx)(e.br,{}),`\n`,\"- infrastructure.lambda\"]}),`\n`,(0,r.jsx)(e.p,{children:\"\\u200D\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"This adds the creation of the Lambda function synchronously to the workflow. Workflows may be parallelized if order of execution is not important during a given step, for more information on how to parallelize your workflows, visit our \",(0,r.jsx)(e.a,{href:\"https://docs.releasehub.com/reference-documentation/application-settings/application-template/schema-definition#workflow-parallelization\",children:\"documentation\"}),\".\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"Resources created during the execution of the workflow will have their state written to the local file store. In an already planned update, Release will extend this functionality to include the additional support of remote backends, like \",(0,r.jsx)(e.a,{href:\"https://aws.amazon.com/s3/\",children:\"Amazon S3\"}),\".\"]}),`\n`,(0,r.jsxs)(e.h3,{id:\"summary\",children:[(0,r.jsx)(e.a,{className:\"anchor\",href:\"#summary\",children:(0,r.jsx)(e.span,{className:\"icon icon-link\"})}),\"Summary\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"This blog covered at a high level the concepts around Infrastructure-as-Code, some specifics related to Terraform and how to use Terraform in combination with Release Environments to extend their functionality. A repository containing the code written in this sample can be found \",(0,r.jsx)(e.a,{href:\"https://github.com/releasehub-samples/terraform-runner-example\",children:\"here\"}),\". If you have any questions, find me on \",(0,r.jsx)(e.a,{href:\"https://www.linkedin.com/in/joshdirkx/\",children:\"LinkedIn\"}),\" or reach me at \",(0,r.jsx)(e.a,{href:\"mailto:josh@release.com\",children:\"josh@release.com\"}),\".\"]})]})}function T(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(h,t)})):h(t)}var x=T;return b(k);})();\n;return Component;"
  },
  "_id": "blog/posts/extending-releasehub-environments-with-terraform.mdx",
  "_raw": {
    "sourceFilePath": "blog/posts/extending-releasehub-environments-with-terraform.mdx",
    "sourceFileName": "extending-releasehub-environments-with-terraform.mdx",
    "sourceFileDir": "blog/posts",
    "contentType": "mdx",
    "flattenedPath": "blog/posts/extending-releasehub-environments-with-terraform"
  },
  "type": "BlogPost",
  "computedSlug": "extending-releasehub-environments-with-terraform"
}