{
  "title": "Feature Flags and Ephemeral Environments",
  "summary": "Learn about feature flags in devops, feature flags and ephemeral environments, and more.",
  "publishDate": "Tue Jan 26 2021 22:22:08 GMT+0000 (Coordinated Universal Time)",
  "author": "erik-landerholm",
  "readingTime": 7,
  "categories": [
    "platform-engineering",
    "product"
  ],
  "mainImage": "/blog-images/6a19ca3dda8d9f11445e6062ff0936f5.jpg",
  "imageAlt": "Top view of city traffic",
  "showCTA": true,
  "ctaCopy": "Simplify managing ephemeral environments with Release's on-demand environments, enhancing feature flag testing and deployment efficiency.",
  "ctaLink": "https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=feature-flags-and-ephemeral-environments",
  "relatedPosts": [
    ""
  ],
  "ogImage": "/blog-images/6a19ca3dda8d9f11445e6062ff0936f5.jpg",
  "excerpt": "Learn about feature flags in devops, feature flags and ephemeral environments, and more.",
  "tags": [
    "platform-engineering",
    "product"
  ],
  "ctaButton": "Try Release for Free",
  "body": {
    "raw": "\n### Overview\n\n- [Feature Flags in DevOps and Software Development](#devops)\n- [Feature Flag Environments](#environments)\n- [Working with Ephemeral Environments](#ephemeral)\n- Step 1: [Create an Application in Release](#create)\n- Step 2: [Modify the Application Template](#modify)\n- Step 3: [Add Environment Variables](#add)\n- Step 4: [Deploy](#deploy)\n\n‍\n\n### Feature Flags in DevOps\n\nFeature Flags are a necessary and ubiquitous part of modern software development. As your company and the complexity of your application grows it becomes imperative to be able to control what features are available to your internal development teams, stakeholders and customers. In the long-ago, before-times, we would just have a variable that you would toggle between true and false to control behavior of your application. However, as application development transitioned to the Web we needed the same kind of control, except that hard-coded feature flags just weren't going to cut it. Enter Dynamic Feature Flags!\n\nDynamic feature flags were a big improvement over static feature flags, but also added complexity and presented challenges different from static feature flags. Gone were hard-coded flags, but they were replaced with if statements and more importantly, retrieving the appropriate flags for your application. Most people started by rolling their own, but as developing with feature flags gained popularity many different companies popped into existence looking to solve the problems of:\n\n- One interface to manage your flags\n- Easy maintenance of your flags\n- Very fast and reliable retrieval of your flags\n- Splitting traffic to one feature or another\n\nWhile companies like LaunchDarkly, Optimizely, Rollout, Split.io and others made it fairly easy to create and manage these flags this doesn't solve all of your issues. Many software orgs, especially as they grow, need lots of environments for testing. This poses a challenge to your Feature Flag setup specifically if your environments are ephemeral.\n\nEphemeral environments are like any environment except they will be removed in a relatively short amount of time unlike your staging or production environments. Good examples are:\n\n- Feature branches\n- Sales Demos\n- Load Testing\n- Refactors\n\nThese environments may not last a long time, but they are exceedingly important and can be just as complex as production. While a sales demo environment may be able to function with seed data, a load testing environment will need production or production-like data and many replicas of each service to give a valid result. These can be super complex to create and manage and their ephemeral nature can play havoc with your feature flag setup.\n\n### Feature Flag Environments to the Rescue…Sort of\n\nLaunchDarkly (and others) recognized this issue and created the concept of environments in their own applications. You can read about their implementation here. They have apis that allow you to create and manipulate these sets of feature flags on an environment by environment basis. This works great if you have a finite set of environments and the set of them doesn't change often, but with ephemeral environments the ability to spin them up and down is a feature not a bug.\n\nIn order to simplify this issue most people create two kinds of environments in their favorite Feature Flag provider: one for development (or test) and one for production. In larger organizations development teams may have a few, such as development, test, uat, staging, and production. This works fine as long as you don't want to add another one or you never take the plunge toward truly ephemeral application environments.\n\nOnce you move to ephemeral environments most people take the shortcut of assigning every ephemeral environment to a single Feature Flag environment, which is simple enough, but creates a large problem with people stepping on each other's toes.\n\nImagine you have 10 environments all pointing to a single database with writes happening from all those environments: it's the same issue here. The great thing about feature flags is the ability to toggle them and see different behavior, but if every environment is pointing to the same one you now have another resource contention problem. If you toggle Feature A 'on' what's to stop your co-worker from toggling it 'off'? Any issues you have with permanent staging environments are magnified with ephemeral environments.\n\nThe best solution would be upon the creation of an ephemeral environment you would create an environment in LaunchDarkly based on something unique about your ephemeral environment and when it comes up, you would make sure it was using the unique SDK api for that particular Feature Flag Environment. Let's implement the workflow and see how that would work with Release!\n\n![](/blog-images/40fe7f59c236984a8877850971f711ec.png)\n\nEphemeral Environment Creation Workflow\n\n### Working with Ephemeral Environments\n\nIn order to try this out with Release we need a repository with a Docker File that has implemented Feature Flags with LaunchDarkly. I'm going to use [this](https://github.com/elanderholm/rails_postgres_redis) repository on Github and you can do the same by first forking the repository so you can use it to create an application with Release.\n\nOnce you have forked the repository you can navigate to [release.com](https://github.com/elanderholm/rails_postgres_redis) and sign-in using github in order to follow along with this example.\n\nThe steps to get our ephemeral environments created in Release with support for environments in LaunchDarkly are:\n\n1.  Create our application in Release\n2.  Create a job with Release to create the environment in LaunchDarkly\n3.  Add some environment variables so the application can contact LaunchDarkly and pull in the SDK Api key from our newly created LaunchDarkly Environment\n4.  Deploy our Ephemeral Environment\n\n> _If you don't have a launch darkly account, you can create one for free for 30 days to use for this example. You will also need to create at least one feature flag. If you already have a launch darkly account with a lot of feature flags you can just skip this step._\n\n![](/blog-images/b5c97492651bfb28602db700fcac9847.png)\n\n‍\n\n### _Create_ the Application In Release\n\nOnce we are logged into Release we want to click **Create New Application** in the left-hand sidebar. After doing that we will be presented with Create New Application Workflow.\n\n![](/blog-images/d4f8f32c20255f0f69fd15650e994390.png)\n\nFirst, we will click the \"refresh\" button to find our newly forked repository. Then, we will select that repository and \"Docker\" for the \"api\" service. Finally, name your application. Once you have finished click the purple \"Generate App Template\" button.\n\n![](/blog-images/03da5feb8004cd4b44710be338ca0f14.png)\n\nLastly name your application and generate the template for your configuration.\n\n![](/blog-images/370c8324a4c8b543213337e5cc10737b.png)\n\n‍\n\n### Modify the Application Template\n\nBefore we can deploy our environment(s) we need to make a modification to our application template and add a few environment variables. We also need to create a job that will create our LaunchDarkly environment upon initial environment deployment. Jobs in Release are described in detail [here](https://docs.releasehub.com/reference-guide/application-settings/application-template#jobs). The TL;DR is that with a small amount of configuration you can run any arbitrary script or task in a container. For example, these jobs are very useful for running migrations before a deployment of your backend service. In this case we will run a rake task to set up our LaunchDarkly Environment.\n\n```yaml\njobs:\n  - name: create-launch-darkly-env\n    from_services: api\n    args:\n      - bundle\n      - exec\n      - rake\n      - launch_darkly:create_environment\n```\n\n> _The above yaml represents a job in Release_\n\nWe will place the above lines right before the \"services\" stanza in our application template.\n\n```none\n\nmemory:\n   limits: 1Gi\n   requests: 100Mi\n replicas: 1\njobs:\n  - name: create-launch-darkly-env\n    from_services: api\n    args:\n    - bundle\n    - exec\n    - rake\n    - launch_darkly:create_environment\nservices:\n  - name: api\n    image: erik-opsnuts-test-001/rails_postgres_redis/api\n    has_repo: true\n    static: false\n\n```\n\n> _Place the jobs snippet into the Application Template_\n\nIn order for Release to utilize this job as part of the workflow to deploy an environment we will need to add one line near the bottom of the file in the 'workflows\\' section. Under 'setup':order_from' we will add **jobs.create-launch-darkly-env**. Then, click \"Save and Continue.\"\n\n```none\n\nworkflows:\n- name: setup\n  order_from:\n  - jobs.create-launch-darkly-env\n  - services.all\n- name: patch\n  order_from:\n  - services.api\n  - services.sidekiq\n  - services.db\n  - services.redis\n\n```\n\n> _Place jobs.create-launch-darkly-env before services.all under the workflows stanza_\n\n‍**That's all the configuration needed, now we just need to add two environment variables before we deploy!**\n\n‍\n\n### Adding Environment Variables\n\n![](/blog-images/955467d85b9685ec1351a814fb6289b2.png)\n\nClick 'EDIT' for 'Default Environment Variables' to bring up the editor. We will add two environment variables that contain information about LaunchDarkly. They are:\n**LAUNCH_DARKLY_API_KEY**: Your LaunchDarkly Api Key which is found here. If you don't have an api token create the \"+ TOKEN\" button to make one. You will want to give it admin privileges. If you can't do that contact your administrator. **_Once you create it, make sure you copy it and paste it somewhere you can retrieve it._** LaunchDarkly will obfuscate your token and if you don't save it somewhere you will need to generate a new one.\n\n![](/blog-images/825b07bdb6f6bfb0ddcd03b4a7cf7667.png)\n**LAUNCH_DARKLY_PROJECT_NAME**: We will just use 'default' for this example, but if there is another project you would like to test with feel free.\n\n```yaml\ndefaults:\n  - key: POSTGRES_USER\n    value: postgres\n  - key: POSTGRES_PASSWORD\n    value: postgres\n  - key: LAUNCH_DARKLY_PROJECT_NAME\n    value: default\n  - key: LAUNCH_DARKLY_API_KEY\n    value: your-api-key\n    secret: true\n```\n\nClick 'Save' to save your environment variables as part of your application configuration. Then, click 'Build and Deploy'. You will be redirected to the activity dashboard for that application and a Docker build was kicked off in the background. This will be followed by the deployment of the environment for your application. You can view the build and the deployment under the 'builds' and 'deploys' sections respectively.\n\n![](/blog-images/4e9d5eb53f63754d6ebeb974fd1c3f2b.png)\n\n‍\n\n### Your Environment\n\nThis process of doing the docker build will take a few minutes the first time. Once the build and deployment have finished you can find the url for your new environment by clicking 'Environments' on the left and then by clicking into your new environment.\n\n![](/blog-images/d7ffae114d550925ce4397e67d7e1f3b.png)\n\nOnce you click on the url for your newly created ephemeral environment another window in your browser will open to the example rails site with postgres and redis. It should look something like this:\n\n![](/blog-images/5513d5ff58106e72c89f7b71551aeccf.png)\n\nIf you have a flag named 'test-flag' in your launch darkly account you can go ahead and toggle it from 'false' to 'true' and vice versa and reload your environment to see the changes. If you would like to use a different flag, you only need to make one change in: **app/views/welcome/index.html.erb**\n\n```ruby\n# app/views/welcome/index.html.erb\ntest_flag = Rails.configuration.ld_client.variation(\n  \"test-flag\",\n  {key: \"user@test.com\"},\n  false\n)\n```\n\nOnce you have changed 'test-flag' to the flag name of your choosing, you only need to commit and push the change to github. Once that happens, Release will automatically do a build and then deploy your changes. When the process finishes, you will be able to see the welcome page change based on your new flag.\n\nIn your LaunchDarkly interface you will see a newly created environment with a name of the form 'tedfe34\\`. This name is the same as your **RELEASE_ENV_ID** environment variable that Release creates automatically for your new environment. You will see this value in a few places in the Release UI besides the environment variable editor.\n\n![](/blog-images/9d8569299b8c2b955944204408f47141.png)\n\n### Conclusion - What's next?\n\nNow that you can get pristine feature flag environments dedicated to your Release environments what's next? In this example the clean-up would need to be done manually, not a huge deal, but we can do better. Release will be implementing a deeper integration with LaunchDarkly in the near future to make this seamless and handle deleting the environments in LaunchDarkly when your Release environment is removed.\n\nStay tuned for integrations with other feature flag providers in the future. If you would like to have environments for your applications that are fast, simple to define and incredibly powerful send us a note at [support@releasehub.com](mailto:support@releasehub.com) and we will help you and your team become more efficient utilizing ephemeral environments with Release.\n\nHero Image by [Denys Nevozhai](https://unsplash.com/@dnevozhai?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/traffic?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)\n\n### Additional Resources\n\n- [What is an Ephemeral Environment?](https://releasehub.com/ephemeral-environments)\n- [User Acceptance Testing (UAT) with Release Ephemeral Environments](https://releasehub.com/user-acceptance-testing-with-ephemeral-environments)\n- [5 Ways To Improve Developer Velocity Using Ephemeral Environments](https://releasehub.com/blog/improve-developer-velocity-with-ephemeral-environments)\n- [Agile DevOps Methodology](https://releasehub.com/blog/you-need-agile-devops-methodology)\n\n‍\n",
    "code": "var Component=(()=>{var d=Object.create;var o=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var g=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),y=(a,e)=>{for(var t in e)o(a,t,{get:e[t],enumerable:!0})},l=(a,e,t,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of m(e))!f.call(a,i)&&i!==t&&o(a,i,{get:()=>e[i],enumerable:!(r=p(e,i))||r.enumerable});return a};var v=(a,e,t)=>(t=a!=null?d(u(a)):{},l(e||!a||!a.__esModule?o(t,\"default\",{value:a,enumerable:!0}):t,a)),b=a=>l(o({},\"__esModule\",{value:!0}),a);var c=g((T,s)=>{s.exports=_jsx_runtime});var D={};y(D,{default:()=>_,frontmatter:()=>w});var n=v(c()),w={title:\"Feature Flags and Ephemeral Environments\",summary:\"Learn about feature flags in devops, feature flags and ephemeral environments, and more.\",publishDate:\"Tue Jan 26 2021 22:22:08 GMT+0000 (Coordinated Universal Time)\",author:\"erik-landerholm\",readingTime:7,categories:[\"platform-engineering\",\"product\"],mainImage:\"/blog-images/6a19ca3dda8d9f11445e6062ff0936f5.jpg\",imageAlt:\"Top view of city traffic\",showCTA:!0,ctaCopy:\"Simplify managing ephemeral environments with Release's on-demand environments, enhancing feature flag testing and deployment efficiency.\",ctaLink:\"https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=feature-flags-and-ephemeral-environments\",relatedPosts:[\"\"],ogImage:\"/blog-images/6a19ca3dda8d9f11445e6062ff0936f5.jpg\",excerpt:\"Learn about feature flags in devops, feature flags and ephemeral environments, and more.\",tags:[\"platform-engineering\",\"product\"],ctaButton:\"Try Release for Free\"};function h(a){let e=Object.assign({h3:\"h3\",a:\"a\",span:\"span\",ul:\"ul\",li:\"li\",p:\"p\",img:\"img\",ol:\"ol\",blockquote:\"blockquote\",em:\"em\",strong:\"strong\",pre:\"pre\",code:\"code\"},a.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.h3,{id:\"overview\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#overview\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Overview\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"#devops\",children:\"Feature Flags in DevOps and Software Development\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"#environments\",children:\"Feature Flag Environments\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"#ephemeral\",children:\"Working with Ephemeral Environments\"})}),`\n`,(0,n.jsxs)(e.li,{children:[\"Step 1: \",(0,n.jsx)(e.a,{href:\"#create\",children:\"Create an Application in Release\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Step 2: \",(0,n.jsx)(e.a,{href:\"#modify\",children:\"Modify the Application Template\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Step 3: \",(0,n.jsx)(e.a,{href:\"#add\",children:\"Add Environment Variables\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Step 4: \",(0,n.jsx)(e.a,{href:\"#deploy\",children:\"Deploy\"})]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"\\u200D\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"feature-flags-in-devops\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#feature-flags-in-devops\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Feature Flags in DevOps\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Feature Flags are a necessary and ubiquitous part of modern software development. As your company and the complexity of your application grows it becomes imperative to be able to control what features are available to your internal development teams, stakeholders and customers. In the long-ago, before-times, we would just have a variable that you would toggle between true and false to control behavior of your application. However, as application development transitioned to the Web we needed the same kind of control, except that hard-coded feature flags just weren't going to cut it. Enter Dynamic Feature Flags!\"}),`\n`,(0,n.jsx)(e.p,{children:\"Dynamic feature flags were a big improvement over static feature flags, but also added complexity and presented challenges different from static feature flags. Gone were hard-coded flags, but they were replaced with if statements and more importantly, retrieving the appropriate flags for your application. Most people started by rolling their own, but as developing with feature flags gained popularity many different companies popped into existence looking to solve the problems of:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"One interface to manage your flags\"}),`\n`,(0,n.jsx)(e.li,{children:\"Easy maintenance of your flags\"}),`\n`,(0,n.jsx)(e.li,{children:\"Very fast and reliable retrieval of your flags\"}),`\n`,(0,n.jsx)(e.li,{children:\"Splitting traffic to one feature or another\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"While companies like LaunchDarkly, Optimizely, Rollout, Split.io and others made it fairly easy to create and manage these flags this doesn't solve all of your issues. Many software orgs, especially as they grow, need lots of environments for testing. This poses a challenge to your Feature Flag setup specifically if your environments are ephemeral.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Ephemeral environments are like any environment except they will be removed in a relatively short amount of time unlike your staging or production environments. Good examples are:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Feature branches\"}),`\n`,(0,n.jsx)(e.li,{children:\"Sales Demos\"}),`\n`,(0,n.jsx)(e.li,{children:\"Load Testing\"}),`\n`,(0,n.jsx)(e.li,{children:\"Refactors\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"These environments may not last a long time, but they are exceedingly important and can be just as complex as production. While a sales demo environment may be able to function with seed data, a load testing environment will need production or production-like data and many replicas of each service to give a valid result. These can be super complex to create and manage and their ephemeral nature can play havoc with your feature flag setup.\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"feature-flag-environments-to-the-rescuesort-of\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#feature-flag-environments-to-the-rescuesort-of\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Feature Flag Environments to the Rescue\\u2026Sort of\"]}),`\n`,(0,n.jsx)(e.p,{children:\"LaunchDarkly (and others) recognized this issue and created the concept of environments in their own applications. You can read about their implementation here. They have apis that allow you to create and manipulate these sets of feature flags on an environment by environment basis. This works great if you have a finite set of environments and the set of them doesn't change often, but with ephemeral environments the ability to spin them up and down is a feature not a bug.\"}),`\n`,(0,n.jsx)(e.p,{children:\"In order to simplify this issue most people create two kinds of environments in their favorite Feature Flag provider: one for development (or test) and one for production. In larger organizations development teams may have a few, such as development, test, uat, staging, and production. This works fine as long as you don't want to add another one or you never take the plunge toward truly ephemeral application environments.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Once you move to ephemeral environments most people take the shortcut of assigning every ephemeral environment to a single Feature Flag environment, which is simple enough, but creates a large problem with people stepping on each other's toes.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Imagine you have 10 environments all pointing to a single database with writes happening from all those environments: it's the same issue here. The great thing about feature flags is the ability to toggle them and see different behavior, but if every environment is pointing to the same one you now have another resource contention problem. If you toggle Feature A 'on' what's to stop your co-worker from toggling it 'off'? Any issues you have with permanent staging environments are magnified with ephemeral environments.\"}),`\n`,(0,n.jsx)(e.p,{children:\"The best solution would be upon the creation of an ephemeral environment you would create an environment in LaunchDarkly based on something unique about your ephemeral environment and when it comes up, you would make sure it was using the unique SDK api for that particular Feature Flag Environment. Let's implement the workflow and see how that would work with Release!\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/40fe7f59c236984a8877850971f711ec.png\",alt:\"\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Ephemeral Environment Creation Workflow\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"working-with-ephemeral-environments\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#working-with-ephemeral-environments\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Working with Ephemeral Environments\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"In order to try this out with Release we need a repository with a Docker File that has implemented Feature Flags with LaunchDarkly. I'm going to use \",(0,n.jsx)(e.a,{href:\"https://github.com/elanderholm/rails_postgres_redis\",children:\"this\"}),\" repository on Github and you can do the same by first forking the repository so you can use it to create an application with Release.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Once you have forked the repository you can navigate to \",(0,n.jsx)(e.a,{href:\"https://github.com/elanderholm/rails_postgres_redis\",children:\"release.com\"}),\" and sign-in using github in order to follow along with this example.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The steps to get our ephemeral environments created in Release with support for environments in LaunchDarkly are:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Create our application in Release\"}),`\n`,(0,n.jsx)(e.li,{children:\"Create a job with Release to create the environment in LaunchDarkly\"}),`\n`,(0,n.jsx)(e.li,{children:\"Add some environment variables so the application can contact LaunchDarkly and pull in the SDK Api key from our newly created LaunchDarkly Environment\"}),`\n`,(0,n.jsx)(e.li,{children:\"Deploy our Ephemeral Environment\"}),`\n`]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.em,{children:\"If you don't have a launch darkly account, you can create one for free for 30 days to use for this example. You will also need to create at least one feature flag. If you already have a launch darkly account with a lot of feature flags you can just skip this step.\"})}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/b5c97492651bfb28602db700fcac9847.png\",alt:\"\"})}),`\n`,(0,n.jsx)(e.p,{children:\"\\u200D\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"create-the-application-in-release\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#create-the-application-in-release\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.em,{children:\"Create\"}),\" the Application In Release\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Once we are logged into Release we want to click \",(0,n.jsx)(e.strong,{children:\"Create New Application\"}),\" in the left-hand sidebar. After doing that we will be presented with Create New Application Workflow.\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/d4f8f32c20255f0f69fd15650e994390.png\",alt:\"\"})}),`\n`,(0,n.jsx)(e.p,{children:'First, we will click the \"refresh\" button to find our newly forked repository. Then, we will select that repository and \"Docker\" for the \"api\" service. Finally, name your application. Once you have finished click the purple \"Generate App Template\" button.'}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/03da5feb8004cd4b44710be338ca0f14.png\",alt:\"\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Lastly name your application and generate the template for your configuration.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/370c8324a4c8b543213337e5cc10737b.png\",alt:\"\"})}),`\n`,(0,n.jsx)(e.p,{children:\"\\u200D\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"modify-the-application-template\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#modify-the-application-template\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Modify the Application Template\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Before we can deploy our environment(s) we need to make a modification to our application template and add a few environment variables. We also need to create a job that will create our LaunchDarkly environment upon initial environment deployment. Jobs in Release are described in detail \",(0,n.jsx)(e.a,{href:\"https://docs.releasehub.com/reference-guide/application-settings/application-template#jobs\",children:\"here\"}),\". The TL;DR is that with a small amount of configuration you can run any arbitrary script or task in a container. For example, these jobs are very useful for running migrations before a deployment of your backend service. In this case we will run a rake task to set up our LaunchDarkly Environment.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`jobs:\n  - name: create-launch-darkly-env\n    from_services: api\n    args:\n      - bundle\n      - exec\n      - rake\n      - launch_darkly:create_environment\n`})}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.em,{children:\"The above yaml represents a job in Release\"})}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:'We will place the above lines right before the \"services\" stanza in our application template.'}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-none\",children:`\nmemory:\n   limits: 1Gi\n   requests: 100Mi\n replicas: 1\njobs:\n  - name: create-launch-darkly-env\n    from_services: api\n    args:\n    - bundle\n    - exec\n    - rake\n    - launch_darkly:create_environment\nservices:\n  - name: api\n    image: erik-opsnuts-test-001/rails_postgres_redis/api\n    has_repo: true\n    static: false\n\n`})}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.em,{children:\"Place the jobs snippet into the Application Template\"})}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"In order for Release to utilize this job as part of the workflow to deploy an environment we will need to add one line near the bottom of the file in the 'workflows' section. Under 'setup':order_from' we will add \",(0,n.jsx)(e.strong,{children:\"jobs.create-launch-darkly-env\"}),'. Then, click \"Save and Continue.\"']}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-none\",children:`\nworkflows:\n- name: setup\n  order_from:\n  - jobs.create-launch-darkly-env\n  - services.all\n- name: patch\n  order_from:\n  - services.api\n  - services.sidekiq\n  - services.db\n  - services.redis\n\n`})}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.em,{children:\"Place jobs.create-launch-darkly-env before services.all under the workflows stanza\"})}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"\\u200D\",(0,n.jsx)(e.strong,{children:\"That's all the configuration needed, now we just need to add two environment variables before we deploy!\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"\\u200D\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"adding-environment-variables\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#adding-environment-variables\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Adding Environment Variables\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/955467d85b9685ec1351a814fb6289b2.png\",alt:\"\"})}),`\n`,(0,n.jsxs)(e.p,{children:[`Click 'EDIT' for 'Default Environment Variables' to bring up the editor. We will add two environment variables that contain information about LaunchDarkly. They are:\n`,(0,n.jsx)(e.strong,{children:\"LAUNCH_DARKLY_API_KEY\"}),`: Your LaunchDarkly Api Key which is found here. If you don't have an api token create the \"+ TOKEN\" button to make one. You will want to give it admin privileges. If you can't do that contact your administrator. `,(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.em,{children:\"Once you create it, make sure you copy it and paste it somewhere you can retrieve it.\"})}),\" LaunchDarkly will obfuscate your token and if you don't save it somewhere you will need to generate a new one.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.img,{src:\"/blog-images/825b07bdb6f6bfb0ddcd03b4a7cf7667.png\",alt:\"\"}),`\n`,(0,n.jsx)(e.strong,{children:\"LAUNCH_DARKLY_PROJECT_NAME\"}),\": We will just use 'default' for this example, but if there is another project you would like to test with feel free.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-yaml\",children:`defaults:\n  - key: POSTGRES_USER\n    value: postgres\n  - key: POSTGRES_PASSWORD\n    value: postgres\n  - key: LAUNCH_DARKLY_PROJECT_NAME\n    value: default\n  - key: LAUNCH_DARKLY_API_KEY\n    value: your-api-key\n    secret: true\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Click 'Save' to save your environment variables as part of your application configuration. Then, click 'Build and Deploy'. You will be redirected to the activity dashboard for that application and a Docker build was kicked off in the background. This will be followed by the deployment of the environment for your application. You can view the build and the deployment under the 'builds' and 'deploys' sections respectively.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/4e9d5eb53f63754d6ebeb974fd1c3f2b.png\",alt:\"\"})}),`\n`,(0,n.jsx)(e.p,{children:\"\\u200D\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"your-environment\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#your-environment\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Your Environment\"]}),`\n`,(0,n.jsx)(e.p,{children:\"This process of doing the docker build will take a few minutes the first time. Once the build and deployment have finished you can find the url for your new environment by clicking 'Environments' on the left and then by clicking into your new environment.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/d7ffae114d550925ce4397e67d7e1f3b.png\",alt:\"\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Once you click on the url for your newly created ephemeral environment another window in your browser will open to the example rails site with postgres and redis. It should look something like this:\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/5513d5ff58106e72c89f7b71551aeccf.png\",alt:\"\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"If you have a flag named 'test-flag' in your launch darkly account you can go ahead and toggle it from 'false' to 'true' and vice versa and reload your environment to see the changes. If you would like to use a different flag, you only need to make one change in: \",(0,n.jsx)(e.strong,{children:\"app/views/welcome/index.html.erb\"})]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ruby\",children:`# app/views/welcome/index.html.erb\ntest_flag = Rails.configuration.ld_client.variation(\n  \"test-flag\",\n  {key: \"user@test.com\"},\n  false\n)\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Once you have changed 'test-flag' to the flag name of your choosing, you only need to commit and push the change to github. Once that happens, Release will automatically do a build and then deploy your changes. When the process finishes, you will be able to see the welcome page change based on your new flag.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In your LaunchDarkly interface you will see a newly created environment with a name of the form 'tedfe34`. This name is the same as your \",(0,n.jsx)(e.strong,{children:\"RELEASE_ENV_ID\"}),\" environment variable that Release creates automatically for your new environment. You will see this value in a few places in the Release UI besides the environment variable editor.\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/9d8569299b8c2b955944204408f47141.png\",alt:\"\"})}),`\n`,(0,n.jsxs)(e.h3,{id:\"conclusion---whats-next\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#conclusion---whats-next\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Conclusion - What's next?\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Now that you can get pristine feature flag environments dedicated to your Release environments what's next? In this example the clean-up would need to be done manually, not a huge deal, but we can do better. Release will be implementing a deeper integration with LaunchDarkly in the near future to make this seamless and handle deleting the environments in LaunchDarkly when your Release environment is removed.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Stay tuned for integrations with other feature flag providers in the future. If you would like to have environments for your applications that are fast, simple to define and incredibly powerful send us a note at \",(0,n.jsx)(e.a,{href:\"mailto:support@releasehub.com\",children:\"support@releasehub.com\"}),\" and we will help you and your team become more efficient utilizing ephemeral environments with Release.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Hero Image by \",(0,n.jsx)(e.a,{href:\"https://unsplash.com/@dnevozhai?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\",children:\"Denys Nevozhai\"}),\" on \",(0,n.jsx)(e.a,{href:\"https://unsplash.com/s/photos/traffic?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\",children:\"Unsplash\"})]}),`\n`,(0,n.jsxs)(e.h3,{id:\"additional-resources\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#additional-resources\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Additional Resources\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://releasehub.com/ephemeral-environments\",children:\"What is an Ephemeral Environment?\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://releasehub.com/user-acceptance-testing-with-ephemeral-environments\",children:\"User Acceptance Testing (UAT) with Release Ephemeral Environments\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://releasehub.com/blog/improve-developer-velocity-with-ephemeral-environments\",children:\"5 Ways To Improve Developer Velocity Using Ephemeral Environments\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://releasehub.com/blog/you-need-agile-devops-methodology\",children:\"Agile DevOps Methodology\"})}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"\\u200D\"})]})}function k(a={}){let{wrapper:e}=a.components||{};return e?(0,n.jsx)(e,Object.assign({},a,{children:(0,n.jsx)(h,a)})):h(a)}var _=k;return b(D);})();\n;return Component;"
  },
  "_id": "blog/posts/feature-flags-and-ephemeral-environments.mdx",
  "_raw": {
    "sourceFilePath": "blog/posts/feature-flags-and-ephemeral-environments.mdx",
    "sourceFileName": "feature-flags-and-ephemeral-environments.mdx",
    "sourceFileDir": "blog/posts",
    "contentType": "mdx",
    "flattenedPath": "blog/posts/feature-flags-and-ephemeral-environments"
  },
  "type": "BlogPost",
  "computedSlug": "feature-flags-and-ephemeral-environments"
}