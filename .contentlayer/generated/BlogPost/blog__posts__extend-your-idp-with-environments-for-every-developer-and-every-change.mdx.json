{
  "title": "Extend your IDP with Environments for Every Developer and Every Change",
  "summary": "Explore environments as a way to enhance your IDP and elevate the development process.",
  "publishDate": "Thu Oct 19 2023 19:02:24 GMT+0000 (Coordinated Universal Time)",
  "author": "sylvia-fronczak",
  "readingTime": 10,
  "categories": [
    "platform-engineering",
    "product"
  ],
  "mainImage": "/blog-images/09075670f023d3719e9920f0dfb758ec.jpg",
  "imageAlt": "Extend your IDP with Environments for Every Developer and Every Change",
  "showCTA": true,
  "ctaCopy": "Unlock flexible and automated environment management to eliminate configuration drift and testing bottlenecks with Release.",
  "ctaLink": "https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=extend-your-idp-with-environments-for-every-developer-and-every-change",
  "relatedPosts": [
    ""
  ],
  "ogImage": "/blog-images/09075670f023d3719e9920f0dfb758ec.jpg",
  "excerpt": "Explore environments as a way to enhance your IDP and elevate the development process.",
  "tags": [
    "platform-engineering",
    "product"
  ],
  "ctaButton": "Try Release for Free",
  "body": {
    "raw": "\nIn our [previous posts](https://release.com/blog/components-of-a-successful-idp-build-a-product-your-developers-actually-want-to-use), we talked about how the internal developer platform (IDP) is comprised of many components and tools working together to optimize your development team’s workflow. Some of these components, like code repositories, CI/CD, test environments, and development tools, are must-haves.\n\nFor these must-have components, you have two choices. You can cover the basics and call it good, or you can look at your organization’s needs and enhance the components to provide your teams with extra leverage.\n\nIn this post, we’ll talk about environments and how you can extend and enhance your IDP through flexible and automated environment management that mimics your production environment. This flexibility will enable your developers to isolate changes, reduce configuration-drift-related bugs, remove testing bottlenecks, and improve time-to-market in complex environments.\n\nWith Release, you can provide on-demand [environments](https://release.com/get-started) for every change and every pull request (PR), providing multiple efficiencies for your development team.\n\n### Why Do We Need More Flexible Environment Management?\n\nTo begin, let’s talk about common problems that developers experience with static environments and local environments.\n\n#### **#1 It Works on My Machine**\n\nEnvironment discrepancies have been a software development headache since we stopped coding live in production. You may not remember that, but on mainframes, it wasn’t unusual to hop into production and change code live. To be fair, even non-mainframe programmers occasionally would hop onto production servers to make small HTML or JavaScript tweaks. Yes, I know, scary. But in small orgs with few controls, it did happen. Thankfully, we’ve evolved our development practices, and we know we don’t want to go back to those days.\n\nHowever, environment differences continue to plague us with bugs and replication difficulties. Whether it’s differences in the operating system, container configuration, or dependencies like the database, caches, and queues, all of these can cause churning due to unexpected behaviors in each environment, leading to the dreaded problem “but it works on my machine”.\n\n#### **#2 The Overhead of Microservices**\n\nIf you’ve ever been on a team that works in a microservices environment, you already know the pain of trying to run systems locally.\n\nYears ago, I frequently had to start up three, five, eight, or more microservices on my laptop to validate a change, test functionality, or debug a production problem. The fan noise coming off the laptop could be startling, and the heat emanating from the machine could warm a small room in the winter. It was slow, painful, and finicky to get everything running consistently.\n\nIn addition to the local resource burden, testing was often done in static test or staging environments and required multiple validations and deploys to ensure the right versions of APIs and implementation were where you thought they should be.\n\n#### **#3 Load Testing Challenges**\n\nFor operations like load testing or performance benchmarking, we turn to static load testing environments. In previous organizations, I’d see folks scheduling time in environments to conduct load tests, often having to wait weeks for the environment and tools to free up to complete testing.\n\nNot being able to quickly access environments that allow proper load testing delays critical tests and makes automation of these load tests difficult.\n\n![](/blog-images/b035f8ba3bb3806ba73ca14a239184b4.png)\n\n#### **#4 Slow Pivots to Changing Priorities**\n\nPicture this. A developer has been coding a new feature for several days. Though they’re committing and pushing frequently, they still have their local development set up specifically for this work. They’ve set up the data they’re testing with and ensured the environment is right for this particular change. Maybe they’ve even changed their local environment configuration to optimize it for their current task. But suddenly, a hot bug comes in, and they need to switch and focus on shipping a fix.\n\nWithout fast ephemeral development environments, they not only have to check out a new branch and switch focus, but potentially, they’ll have to undo data schema changes they’re in the middle of and then recreate the data for the production scenario on their machine.\n\nIt’s bad enough that your engineering teams have to context switch at times. But switching over local dev environments or test environments to hot priorities shouldn’t be a big ordeal.\n\n#### **#5 Data Degradation**\n\nWith static environments, after a while the data or the whole environment becomes degraded. Sometimes, this is due to testing in that environment with different versions of the code and not as much backward compatibility as we need. Other times, it’s because we’ve had to contrive data into a particular state to test or investigate issues.\n\nRegardless of the reason, static environments experience data degradation and require periodic cleanup. For example, I worked in a group that would go through routine quarterly weeklong data refreshes to get non-production environments to a healthy and working state in order to support further rounds of testing, for the whole next quarter.\n\nIf we treat environments as static, long-living beasts, we aren’t primed to wipe them out and start fresh frequently.\n\n#### **#6 Configuration Drift**\n\nConfiguration drift occurs when our configuration between environments falls out of sync. This can include application configuration, infrastructure configurations or versions, and network differences between environments.\n\nThis is especially true when working in environments where most configurations are managed manually.\n\nConfiguration drift can cause pain when testing, reproducing bugs, or making assumptions about what an environment’s configuration looks like.\n\n#### **#7 Slow Feedback Loops**\n\nShared environments can make testing and feedback loops slow and inefficient because of waiting for environments or debugging issues unrelated to your changes.\n\n#### **#8 Inconsistent Security Measures**\n\nSimilar to configuration drift, security constraints in some environments are not replicated in local or test environments, causing unexpected bugs or security flaws in production.\n\nThough we can’t replicate everything between all environments, key differences can mean more bugs and incidents once the code is deployed to production.\n\n### How Can Development Environments Help?\n\nBefore we dive into the benefits of ephemeral development environments, let’s review typical environment types:\n\n1.  The **developer’s local environment is** where we write code and tests. The audience is limited to the developer(s) on this machine.\n2.  **Static non-production environment**s like test, QA, UAT (user acceptance testing), or SIT (system integration testing), where additional testing is completed. These environments are used by development teams, QA/testing, and both internal and external partner teams for testing and validation. These can also be used for demos both within and outside the organization.\n3.  **Production**, where your product is live for your customers.\n\nWhen bottlenecks emerge with testing in static non-prod environments, organizations might expand the number of environments, hoping it relieves some of the pressure. This does temporarily provide folks with more test environments, but it also creates more of the problems we saw in the previous section.\n\nInstead of adding yet another static environment, consider investing in automated, fine-grained, flexible, and ephemeral environments. With these, spinning up environments as part of your development workflow and IDP takes little to no effort after the initial investment. Your team has purposeful environments for quick bug testing or feature deployment tied to a PR or branch of code.\n\nSo how do these environments solve the problems we see with static environments? Let’s look at some of the answers.\n\n#### **Isolation and Consistency**\n\nWhen testing changes, your development team won’t struggle with isolating one change’s impact from others in static test environments. They’ll work in a production-like setup, and then the CI/CD pipeline will create an environment for further validation/testing after the pull request is made.\n\n#### **Reduced Configuration Drift**\n\nIn long-lived environments, either on a developer’s machine or in a static testing environment, we can’t eliminate drift. However, if we’re frequently rebuilding environments for each change, we keep configurations in sync with production and provide a consistent experience across environments.\n\n![](/blog-images/832e584189dad339f0de0d28182a6e1c.png)\n\n#### **Dependency Management**\n\nWith ephemeral and on-demand environments, you can provide easy dependency management. Developers won’t need to manage their own dependencies (the databases, caches, and queues mentioned above) while developing and testing their app. It can all be included in the release environment setup.\n\nFurthermore, if developers are specifically working on changes to dependencies, they’ll have a full environment to validate their changes.\n\n#### **Fast Feedback**\n\nFirst, automated tests are necessary, and you can’t go without them. But they’re not bulletproof. You can’t test what you don’t expect. With environments set up for each story or issue, you can get fast feedback by starting up an environment, testing your change, and exploring side effects. Then you can receive that feedback immediately instead of waiting to get the change into a test environment.\n\n#### **Production-Like Data**\n\nWith on-demand environments, your development team will have the data and scenarios they need without excessive data setup. Features like [Instant Datasets](https://release.com/product/instant-datasets) preload a pool of production-like datasets (sanitized and truncated, if needed) and have even terabytes of data available in minutes.\n\n#### **Consistent Development Workflows**\n\nFinally, with ready-to-use and fully automated environments, development teams will have a consistent experience rolling out their changes to each environment in your CI/CD pipeline.\n\n### How Do Ephemeral Environments Tie In with Your IDP?\n\nYour IDP consists of multiple components and integrations. Once you have the essential components like CI/CD, where you’re automating basic workflows, then you’re ready to level up.\n\nIf your organization is small and you don’t yet have environmental bottlenecks, adding ephemeral environments might not be your top priority on enhancing your IDP.\n\nOn the other hand, if your teams experience pain or bottlenecks involved in using static development or non-production environments, then it’s time to experiment with [Release](https://release.com/signup). Incorporating automated on-demand ephemeral environments provides benefits like consistency, dependency management, and fast feedback. This helps your teams get new features into production faster and with fewer defects. You’ll manage, provision, and eventually destroy environments quickly and automatically, so that you get the most use out of them when your development team needs them.\n\nIn short, IDPs integrate developer environments into the development workflow. They improve efficiency, collaboration, and quality.\n\n‍*This post was written by Sylvia Fronczak.* [_Sylvia_](https://sylviafronczak.com/) _is a software developer who has worked in various industries with various software methodologies. She’s currently focused on design practices that the whole team can own, understand, and evolve over time._\n",
    "code": "var Component=(()=>{var h=Object.create;var a=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var v=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),f=(t,e)=>{for(var o in e)a(t,o,{get:e[o],enumerable:!0})},s=(t,e,o,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of p(e))!g.call(t,i)&&i!==o&&a(t,i,{get:()=>e[i],enumerable:!(r=m(e,i))||r.enumerable});return t};var y=(t,e,o)=>(o=t!=null?h(u(t)):{},s(e||!t||!t.__esModule?a(o,\"default\",{value:t,enumerable:!0}):o,t)),w=t=>s(a({},\"__esModule\",{value:!0}),t);var l=v((D,c)=>{c.exports=_jsx_runtime});var I={};f(I,{default:()=>x,frontmatter:()=>b});var n=y(l()),b={title:\"Extend your IDP with Environments for Every Developer and Every Change\",summary:\"Explore environments as a way to enhance your IDP and elevate the development process.\",publishDate:\"Thu Oct 19 2023 19:02:24 GMT+0000 (Coordinated Universal Time)\",author:\"sylvia-fronczak\",readingTime:10,categories:[\"platform-engineering\",\"product\"],mainImage:\"/blog-images/09075670f023d3719e9920f0dfb758ec.jpg\",imageAlt:\"Extend your IDP with Environments for Every Developer and Every Change\",showCTA:!0,ctaCopy:\"Unlock flexible and automated environment management to eliminate configuration drift and testing bottlenecks with Release.\",ctaLink:\"https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=extend-your-idp-with-environments-for-every-developer-and-every-change\",relatedPosts:[\"\"],ogImage:\"/blog-images/09075670f023d3719e9920f0dfb758ec.jpg\",excerpt:\"Explore environments as a way to enhance your IDP and elevate the development process.\",tags:[\"platform-engineering\",\"product\"],ctaButton:\"Try Release for Free\"};function d(t){let e=Object.assign({p:\"p\",a:\"a\",h3:\"h3\",span:\"span\",h4:\"h4\",strong:\"strong\",img:\"img\",ol:\"ol\",li:\"li\",em:\"em\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"In our \",(0,n.jsx)(e.a,{href:\"https://release.com/blog/components-of-a-successful-idp-build-a-product-your-developers-actually-want-to-use\",children:\"previous posts\"}),\", we talked about how the internal developer platform (IDP) is comprised of many components and tools working together to optimize your development team\\u2019s workflow. Some of these components, like code repositories, CI/CD, test environments, and development tools, are must-haves.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"For these must-have components, you have two choices. You can cover the basics and call it good, or you can look at your organization\\u2019s needs and enhance the components to provide your teams with extra leverage.\"}),`\n`,(0,n.jsx)(e.p,{children:\"In this post, we\\u2019ll talk about environments and how you can extend and enhance your IDP through flexible and automated environment management that mimics your production environment. This flexibility will enable your developers to isolate changes, reduce configuration-drift-related bugs, remove testing bottlenecks, and improve time-to-market in complex environments.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"With Release, you can provide on-demand \",(0,n.jsx)(e.a,{href:\"https://release.com/get-started\",children:\"environments\"}),\" for every change and every pull request (PR), providing multiple efficiencies for your development team.\"]}),`\n`,(0,n.jsxs)(e.h3,{id:\"why-do-we-need-more-flexible-environment-management\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#why-do-we-need-more-flexible-environment-management\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Why Do We Need More Flexible Environment Management?\"]}),`\n`,(0,n.jsx)(e.p,{children:\"To begin, let\\u2019s talk about common problems that developers experience with static environments and local environments.\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"1-it-works-on-my-machine\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#1-it-works-on-my-machine\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"#1 It Works on My Machine\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"Environment discrepancies have been a software development headache since we stopped coding live in production. You may not remember that, but on mainframes, it wasn\\u2019t unusual to hop into production and change code live. To be fair, even non-mainframe programmers occasionally would hop onto production servers to make small HTML or JavaScript tweaks. Yes, I know, scary. But in small orgs with few controls, it did happen. Thankfully, we\\u2019ve evolved our development practices, and we know we don\\u2019t want to go back to those days.\"}),`\n`,(0,n.jsx)(e.p,{children:\"However, environment differences continue to plague us with bugs and replication difficulties. Whether it\\u2019s differences in the operating system, container configuration, or dependencies like the database, caches, and queues, all of these can cause churning due to unexpected behaviors in each environment, leading to the dreaded problem \\u201Cbut it works on my machine\\u201D.\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"2-the-overhead-of-microservices\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#2-the-overhead-of-microservices\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"#2 The Overhead of Microservices\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"If you\\u2019ve ever been on a team that works in a microservices environment, you already know the pain of trying to run systems locally.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Years ago, I frequently had to start up three, five, eight, or more microservices on my laptop to validate a change, test functionality, or debug a production problem. The fan noise coming off the laptop could be startling, and the heat emanating from the machine could warm a small room in the winter. It was slow, painful, and finicky to get everything running consistently.\"}),`\n`,(0,n.jsx)(e.p,{children:\"In addition to the local resource burden, testing was often done in static test or staging environments and required multiple validations and deploys to ensure the right versions of APIs and implementation were where you thought they should be.\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"3-load-testing-challenges\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#3-load-testing-challenges\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"#3 Load Testing Challenges\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"For operations like load testing or performance benchmarking, we turn to static load testing environments. In previous organizations, I\\u2019d see folks scheduling time in environments to conduct load tests, often having to wait weeks for the environment and tools to free up to complete testing.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Not being able to quickly access environments that allow proper load testing delays critical tests and makes automation of these load tests difficult.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/b035f8ba3bb3806ba73ca14a239184b4.png\",alt:\"\"})}),`\n`,(0,n.jsxs)(e.h4,{id:\"4-slow-pivots-to-changing-priorities\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#4-slow-pivots-to-changing-priorities\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"#4 Slow Pivots to Changing Priorities\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"Picture this. A developer has been coding a new feature for several days. Though they\\u2019re committing and pushing frequently, they still have their local development set up specifically for this work. They\\u2019ve set up the data they\\u2019re testing with and ensured the environment is right for this particular change. Maybe they\\u2019ve even changed their local environment configuration to optimize it for their current task. But suddenly, a hot bug comes in, and they need to switch and focus on shipping a fix.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Without fast ephemeral development environments, they not only have to check out a new branch and switch focus, but potentially, they\\u2019ll have to undo data schema changes they\\u2019re in the middle of and then recreate the data for the production scenario on their machine.\"}),`\n`,(0,n.jsx)(e.p,{children:\"It\\u2019s bad enough that your engineering teams have to context switch at times. But switching over local dev environments or test environments to hot priorities shouldn\\u2019t be a big ordeal.\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"5-data-degradation\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#5-data-degradation\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"#5 Data Degradation\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"With static environments, after a while the data or the whole environment becomes degraded. Sometimes, this is due to testing in that environment with different versions of the code and not as much backward compatibility as we need. Other times, it\\u2019s because we\\u2019ve had to contrive data into a particular state to test or investigate issues.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Regardless of the reason, static environments experience data degradation and require periodic cleanup. For example, I worked in a group that would go through routine quarterly weeklong data refreshes to get non-production environments to a healthy and working state in order to support further rounds of testing, for the whole next quarter.\"}),`\n`,(0,n.jsx)(e.p,{children:\"If we treat environments as static, long-living beasts, we aren\\u2019t primed to wipe them out and start fresh frequently.\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"6-configuration-drift\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#6-configuration-drift\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"#6 Configuration Drift\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"Configuration drift occurs when our configuration between environments falls out of sync. This can include application configuration, infrastructure configurations or versions, and network differences between environments.\"}),`\n`,(0,n.jsx)(e.p,{children:\"This is especially true when working in environments where most configurations are managed manually.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Configuration drift can cause pain when testing, reproducing bugs, or making assumptions about what an environment\\u2019s configuration looks like.\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"7-slow-feedback-loops\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#7-slow-feedback-loops\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"#7 Slow Feedback Loops\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"Shared environments can make testing and feedback loops slow and inefficient because of waiting for environments or debugging issues unrelated to your changes.\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"8-inconsistent-security-measures\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#8-inconsistent-security-measures\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"#8 Inconsistent Security Measures\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"Similar to configuration drift, security constraints in some environments are not replicated in local or test environments, causing unexpected bugs or security flaws in production.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Though we can\\u2019t replicate everything between all environments, key differences can mean more bugs and incidents once the code is deployed to production.\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"how-can-development-environments-help\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#how-can-development-environments-help\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"How Can Development Environments Help?\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Before we dive into the benefits of ephemeral development environments, let\\u2019s review typical environment types:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"The \",(0,n.jsx)(e.strong,{children:\"developer\\u2019s local environment is\"}),\" where we write code and tests. The audience is limited to the developer(s) on this machine.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Static non-production environment\"}),\"s like test, QA, UAT (user acceptance testing), or SIT (system integration testing), where additional testing is completed. These environments are used by development teams, QA/testing, and both internal and external partner teams for testing and validation. These can also be used for demos both within and outside the organization.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Production\"}),\", where your product is live for your customers.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"When bottlenecks emerge with testing in static non-prod environments, organizations might expand the number of environments, hoping it relieves some of the pressure. This does temporarily provide folks with more test environments, but it also creates more of the problems we saw in the previous section.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Instead of adding yet another static environment, consider investing in automated, fine-grained, flexible, and ephemeral environments. With these, spinning up environments as part of your development workflow and IDP takes little to no effort after the initial investment. Your team has purposeful environments for quick bug testing or feature deployment tied to a PR or branch of code.\"}),`\n`,(0,n.jsx)(e.p,{children:\"So how do these environments solve the problems we see with static environments? Let\\u2019s look at some of the answers.\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"isolation-and-consistency\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#isolation-and-consistency\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"Isolation and Consistency\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"When testing changes, your development team won\\u2019t struggle with isolating one change\\u2019s impact from others in static test environments. They\\u2019ll work in a production-like setup, and then the CI/CD pipeline will create an environment for further validation/testing after the pull request is made.\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"reduced-configuration-drift\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#reduced-configuration-drift\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"Reduced Configuration Drift\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"In long-lived environments, either on a developer\\u2019s machine or in a static testing environment, we can\\u2019t eliminate drift. However, if we\\u2019re frequently rebuilding environments for each change, we keep configurations in sync with production and provide a consistent experience across environments.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/blog-images/832e584189dad339f0de0d28182a6e1c.png\",alt:\"\"})}),`\n`,(0,n.jsxs)(e.h4,{id:\"dependency-management\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#dependency-management\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"Dependency Management\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"With ephemeral and on-demand environments, you can provide easy dependency management. Developers won\\u2019t need to manage their own dependencies (the databases, caches, and queues mentioned above) while developing and testing their app. It can all be included in the release environment setup.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Furthermore, if developers are specifically working on changes to dependencies, they\\u2019ll have a full environment to validate their changes.\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"fast-feedback\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#fast-feedback\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"Fast Feedback\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"First, automated tests are necessary, and you can\\u2019t go without them. But they\\u2019re not bulletproof. You can\\u2019t test what you don\\u2019t expect. With environments set up for each story or issue, you can get fast feedback by starting up an environment, testing your change, and exploring side effects. Then you can receive that feedback immediately instead of waiting to get the change into a test environment.\"}),`\n`,(0,n.jsxs)(e.h4,{id:\"production-like-data\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#production-like-data\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"Production-Like Data\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"With on-demand environments, your development team will have the data and scenarios they need without excessive data setup. Features like \",(0,n.jsx)(e.a,{href:\"https://release.com/product/instant-datasets\",children:\"Instant Datasets\"}),\" preload a pool of production-like datasets (sanitized and truncated, if needed) and have even terabytes of data available in minutes.\"]}),`\n`,(0,n.jsxs)(e.h4,{id:\"consistent-development-workflows\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#consistent-development-workflows\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),(0,n.jsx)(e.strong,{children:\"Consistent Development Workflows\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"Finally, with ready-to-use and fully automated environments, development teams will have a consistent experience rolling out their changes to each environment in your CI/CD pipeline.\"}),`\n`,(0,n.jsxs)(e.h3,{id:\"how-do-ephemeral-environments-tie-in-with-your-idp\",children:[(0,n.jsx)(e.a,{className:\"anchor\",href:\"#how-do-ephemeral-environments-tie-in-with-your-idp\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"How Do Ephemeral Environments Tie In with Your IDP?\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Your IDP consists of multiple components and integrations. Once you have the essential components like CI/CD, where you\\u2019re automating basic workflows, then you\\u2019re ready to level up.\"}),`\n`,(0,n.jsx)(e.p,{children:\"If your organization is small and you don\\u2019t yet have environmental bottlenecks, adding ephemeral environments might not be your top priority on enhancing your IDP.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"On the other hand, if your teams experience pain or bottlenecks involved in using static development or non-production environments, then it\\u2019s time to experiment with \",(0,n.jsx)(e.a,{href:\"https://release.com/signup\",children:\"Release\"}),\". Incorporating automated on-demand ephemeral environments provides benefits like consistency, dependency management, and fast feedback. This helps your teams get new features into production faster and with fewer defects. You\\u2019ll manage, provision, and eventually destroy environments quickly and automatically, so that you get the most use out of them when your development team needs them.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"In short, IDPs integrate developer environments into the development workflow. They improve efficiency, collaboration, and quality.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"\\u200D\",(0,n.jsx)(e.em,{children:\"This post was written by Sylvia Fronczak.\"}),\" \",(0,n.jsx)(e.a,{href:\"https://sylviafronczak.com/\",children:(0,n.jsx)(e.em,{children:\"Sylvia\"})}),\" \",(0,n.jsx)(e.em,{children:\"is a software developer who has worked in various industries with various software methodologies. She\\u2019s currently focused on design practices that the whole team can own, understand, and evolve over time.\"})]})]})}function k(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(d,t)})):d(t)}var x=k;return w(I);})();\n;return Component;"
  },
  "_id": "blog/posts/extend-your-idp-with-environments-for-every-developer-and-every-change.mdx",
  "_raw": {
    "sourceFilePath": "blog/posts/extend-your-idp-with-environments-for-every-developer-and-every-change.mdx",
    "sourceFileName": "extend-your-idp-with-environments-for-every-developer-and-every-change.mdx",
    "sourceFileDir": "blog/posts",
    "contentType": "mdx",
    "flattenedPath": "blog/posts/extend-your-idp-with-environments-for-every-developer-and-every-change"
  },
  "type": "BlogPost",
  "computedSlug": "extend-your-idp-with-environments-for-every-developer-and-every-change"
}