---
title: Kubernetes - How to Debug CrashLoopBackOff in a Container
summary: >-
  If youâ€™ve used Kubernetes (k8s), youâ€™ve probably bumped into the dreaded
  CrashLoopBackOff. A CrashLoopBackOff is possibl
publishDate: 'Fri Apr 21 2023 20:04:43 GMT+0000 (Coordinated Universal Time)'
author: david-giffin
readingTime: 3
categories: &ref_0
  - kubernetes
  - platform-engineering
mainImage: /blog-images/4e91e41da26a361f3123c6c7a68815ee.jpg
imageAlt: Storage containers stacked representing a CrashLoopBackOff in a container
showCTA: true
ctaCopy: >-
  Struggling with CrashLoopBackOff in Kubernetes? Use Release for streamlined
  debugging environments and faster issue resolution.
ctaLink: >-
  https://release.com/signup?utm_source=blog&utm_medium=cta&utm_campaign=blog-cta&utm_content=kubernetes-how-to-debug-crashloopbackoff-in-a-container
relatedPosts:
  - ''
ogImage: /blog-images/4e91e41da26a361f3123c6c7a68815ee.jpg
excerpt: >-
  If youâ€™ve used Kubernetes (k8s), youâ€™ve probably bumped into the dreaded
  CrashLoopBackOff. A CrashLoopBackOff is possibl
tags: *ref_0
ctaButton: Try Release for Free
---

If youâ€™ve used Kubernetes (k8s), youâ€™ve probably bumped into the dreaded CrashLoopBackOff. A CrashLoopBackOff is possible for several types of k8s misconfigurations (not able to connect to persistent volumes, init-container misconfiguration, etc). We arenâ€™t going to cover how to configure k8s properly in this article, but instead will focus on the harder problem of debugging your code or, even worse, someone elseâ€™s code ğŸ˜±

Here is the output from kubectl describe pod for a CrashLoopBackOff:

```ruby

Name: Â  Â  Â  Â  Â  frontend-5c49b595fc-sjzkg
Namespace: Â  Â  Â tedbf02-ac-david-nginx-golang-tmcclung-nginx-golang
Priority: Â  Â  Â  0
Start Time: Â  Â  Wed, 23 Dec 2020 14:55:49 -0500
Labels: Â  Â  Â  Â  app=frontend
 Â  Â  Â  Â  Â  Â  Â  Â pod-template-hash=5c49b595fc
 Â  Â  Â  Â  Â  Â  Â  Â tier=frontend
Status: Â  Â  Â  Â  Running
IP: Â  Â  Â  Â  Â  Â  10.1.31.0
IPs: Â  Â  Â  Â  Â  Â 
Controlled By: Â ReplicaSet/frontend-5c49b595fc
Containers:
 Â frontend:
 Â  Â Container ID: Â  docker://a4ed7efcaaa87fe36342cf7532ff1de5cd51b62d3d681dfb9857999300f6c587
 Â  Â Image: Â  Â  Â  Â  Â .amazonaws.com/tommyrelease/awesome-compose/frontend@sha256:dfd762c
 Â  Â Image ID: Â  Â  Â  docker-pullable://.amazonaws.com/tommyrelease/awesome-compose/frontend@sha256:dfd762c
 Â  Â Port: Â  Â  Â  Â  Â  80/TCP
 Â  Â Host Port: Â  Â  Â 0/TCP
 Â  Â State: Â  Â  Â  Â  Â Waiting
 Â  Â  Â Reason: Â  Â  Â  CrashLoopBackOff
 Â  Â Last State: Â  Â  Terminated
 Â  Â  Â Reason: Â  Â  Â  Error
 Â  Â  Â Exit Code: Â  Â 1
 Â  Â  Â Started: Â  Â  Â Sun, 24 Jan 2021 20:25:26 -0500
 Â  Â  Â Finished: Â  Â  Sun, 24 Jan 2021 20:25:26 -0500
 Â  Â Ready: Â  Â  Â  Â  Â False
 Â  Â Restart Count: Â 9043

```

Two common problems when starting a container are OCI runtime create failed (which means you are referencing a binary or script that doesnâ€™t exist on the container) and container â€œCompletedâ€ or â€œErrorâ€ which both mean that the code executing on the container failed to run a service and stay running.

Hereâ€™s an example of an OCI runtime error, trying to execute: â€œhello crashloopâ€:

```ruby

Port: Â  Â  Â  Â  Â 80/TCP
 Â  Â Host Port: Â  Â  0/TCP
 Â  Â Command:
 Â  Â  Â hello
 Â  Â  Â crashloop
 Â  Â State: Â  Â  Â  Â  Â Waiting
 Â  Â  Â Reason: Â  Â  Â  CrashLoopBackOff
 Â  Â Last State: Â  Â  Terminated
 Â  Â  Â Reason: Â  Â  Â  ContainerCannotRun
 Â  Â  Â Message: Â  Â  Â OCI runtime create failed: container_linux.go:370: starting container process caused: exec: "hello": executable file not found in $PATH: unknown
 Â  Â  Â Exit Code: Â  Â 127
 Â  Â  Â Started: Â  Â  Â Mon, 25 Jan 2021 22:20:04 -0500
 Â  Â  Â Finished: Â  Â  Mon, 25 Jan 2021 22:20:04 -0500

```

K8s gives you the exit status of the process in the container when you look at a pod using kubectl or [k9s](https://github.com/derailed/k9s). Common exit statuses from unix processes include 1-125. Each unix command usually has a man page, which provides more details around the various exit codes. Exit code (128 + SIGKILL 9) 137 means that k8s hit the memory limit for your pod and killed your container for you.

Here is the output from kubectl describe pod, showing the container exit code:

```ruby

Last State: Â  Â  Terminated
 Â  Â  Â Reason: Â  Â  Â  Error
 Â  Â  Â Exit Code: Â  Â 1
 Â  Â  Â Started: Â  Â  Â Sun, 24 Jan 2021 20:25:26 -0500
 Â  Â  Â Finished: Â  Â  Sun, 24 Jan 2021 20:25:26 -0500
 Â  Â Ready: Â  Â  Â  Â  Â False
 Â  Â Restart Count: Â 9043

```

### All containers are not created equally.

Docker allows you to define an Entrypoint and Cmd which you can mix and match in a Dockerfile. Entrypoint is the executable, and Cmd are the arguments passed to the Entrypoint. The Dockerfile schema is quite lenient and allows users to set Cmd without Entrypoint, which means that the first argument in Cmd will be the executable to run.

Note: k8s uses a different naming convention for Docker Entrypoint and Cmd. In Kubernetes command is Docker Entrypoint and Kubernetes args is Docker Cmd.

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 

| Description | The command run by the container | Arguments passed to the command |
| --- | --- | --- |
| Docker field name | Entrypoint | Cmd |
| Kubernetes field name | Cmd | args |

There are a few tricks to understanding how the container youâ€™re working with starts up. In order to get the startup command when youâ€™re dealing with someone elseâ€™s container, we need to know the intended Docker Entrypoint and Cmd of the Docker image. If you have the Dockerfile that created the Docker image, then you likely already know the Entrypoint and Cmd, unless you arenâ€™t defining them and inheriting from a base image that has them set.

When dealing with either off the shelf containers, using someone elseâ€™s container and you donâ€™t have the Dockerfile, or youâ€™re inheriting from a base image that you donâ€™t have the Dockerfile for, you can use the following steps to get the values you need. First, we pull the container locally using docker pull, then we inspect the container image to get the Entrypoint and Cmd:
*   docker pull <image id=""></image>
*   docker inspect <image id=""></image>

Here we use jq to filter the JSON response from docker inspect:

```ruby

david@sega:~: docker pull docker.elastic.co/elasticsearch/elasticsearch:7.10.2
7.10.2: Pulling from elasticsearch/elasticsearch
ddf49b9115d7: Pull complete
e736878e27ad: Pull complete
7487c9dcefbe: Pull complete
9ccb7e6e1f0c: Pull complete
dcec6dec98db: Pull complete
8a10b4854661: Pull complete
1e595aee1b7d: Pull complete
06cc198dbf22: Pull complete
55b9b1b50ed8: Pull complete
Digest: sha256:d528cec81720266974fdfe7a0f12fee928dc02e5a2c754b45b9a84c84695bfd9
Status: Downloaded newer image for docker.elastic.co/elasticsearch/elasticsearch:7.10.2
docker.elastic.co/elasticsearch/elasticsearch:7.10.2
david@sega:~: docker inspect docker.elastic.co/elasticsearch/elasticsearch:7.10.2 | jq '.[0] .ContainerConfig .Entrypoint'
[
 Â "/tini",
 Â "--",
 Â "/usr/local/bin/docker-entrypoint.sh"
]
david@sega:~: docker inspect docker.elastic.co/elasticsearch/elasticsearch:7.10.2 | jq '.[0] .ContainerConfig .Cmd'
[
 Â "/bin/sh",
 Â "-c",
 Â "#(nop) ",
 Â "CMD [\"eswrapper\"]"
]

```

### The Dreaded CrashLoopBackOff

Now that you have all that background, letâ€™s get to debugging the CrashLoopBackOff.

In order to understand whatâ€™s happening, itâ€™s important to be able to inspect the container inside of k8s so the application has all the environment variables and dependent services. Updating the deployment and setting the container Entrypoint or k8s command temporarily to tail -f /dev/null or sleep infinity will give you an opportunity to debug why the service doesnâ€™t stay running.

Hereâ€™s how to configure k8s to override the container Entrypoint:

```ruby

apiVersion: extensions/v1beta1
kind: Deployment
metadata:
 Â name: elasticsearch
 Â namespace: elasticsearch
spec:
 Â progressDeadlineSeconds: 600
 Â replicas: 1
 Â revisionHistoryLimit: 3
 Â selector:
 Â  Â matchLabels:
 Â  Â  Â app: backend
 Â  Â  Â tier: backend
 Â strategy:
 Â  Â rollingUpdate:
 Â  Â  Â maxSurge: 25%
 Â  Â  Â maxUnavailable: 25%
 Â  Â type: RollingUpdate
 Â template:
 Â  Â metadata:
 Â  Â  Â creationTimestamp: null
 Â  Â  Â labels:
 Â  Â  Â  Â app: backend
 Â  Â  Â  Â tier: backend
 Â  Â spec:
 Â  Â  Â containers:
 Â  Â  Â - command:
 Â  Â  Â  Â - tail
 Â  Â  Â  Â - "-f"
 Â  Â  Â  Â - /dev/null
 
```

Hereâ€™s the configuration in Release:

```ruby

services:
- name: elasticsearch
 Â image: docker.elastic.co/elasticsearch/elasticsearch:7.10.2
 Â command:
 Â - tail
 Â - "-f"
 Â - /dev/null

```

You can now use kubectl or k9s to exec into the container and take a look around. Using the Entrypoint and Cmd you discovered earlier, you can execute the intended startup command and see how the application is failing.

Depending on the container youâ€™re running, it may be missing many of the tools necessary to debug your problem like: curl, lsof, vim; and if itâ€™s someone elseâ€™s code, you probably donâ€™t know which version of linux was used to create the image. We typically try all of the common package managers until we find the right one. Most containers these days use Alpine Linux (apk package manager) or a Debian, Ubuntu (apt-get package manager) based image. In some cases weâ€™ve seen Centos and Fedora, which both use the yum package manager.

One of the following commands should work depending on the operating system:
*   apk
*   apt-get
*   yum

Dockerfile maintainers often remove the cache from the package manager to shrink the size of the image, so you may also need to run one of the following:
*   apk update
*   apt-get update
*   yum makecache

Now you need to add the necessary tools to help with debugging. Depending on the package manager you found, use one of the following commands to add useful debugging tools:
*   apt-get install -y curl vim procps inetutils-tools net-tools lsof
*   apk add curl vim procps net-tools lsof
*   yum install curl vim procps lsof

At this point, itâ€™s up to you to figure out the problem. You can edit files using vim to tweak the container until you understand whatâ€™s going on. If you forget all of the files youâ€™ve touched on the container, you can alway kill the pod and the container will restart without your changes. Always remember to write down the steps taken to get the container working. Youâ€™ll want to use your notes to alter the Dockerfile or add commands to the container startup scripts.

### Debugging Your Containers

We have created a simple script to get all of the debuging tools, as long as you are working with a container that has curl pre-installed:

```ruby

# install debugging tools on a container with curl pre-installed

/bin/sh -c "$(curl -fsSL https://raw.githubusercontent.com/releaseapp-io/container-debug/main/install.sh)"

```

### Conclusion

In this article, weâ€™ve learnt how to spot and investigate the CrashLoopBackOff errors in containers. We walked you through how to inspect and investigate the container image itself. Weâ€™ve listed and shown some tools that we use to spot problems and investigate issues. We got several useful and basic tools installed on the image, hopefully regardless of base image. With these steps in mind and all the tools ready at your disposal, go forth and fix all the things!
